<!DOCTYPE html>
<html>
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<title> this is a test </title>
<style>/* -*- Mode: CSS; tab-width: 2; indent-tabs-mode: nil; -*- */
/* vim:set ft=css ts=2 sw=2 sts=2 autoindent: */

/* Styling for annotations */

/* alternative font test */
/*
text {
font-size: 13px;
font-family: helvetica,arial,freesans,clean,sans-serif;
}
*/

#svg {
margin: 34px auto 100px;
padding-top: 15px;
}

.center_wrapper {
display: table;
position: absolute;
top: 0;
left: 0;
height: 100%;
width: 100%;
}
.center_wrapper > div {
display: table-cell;
vertical-align: middle;
}
.center_wrapper > div > div {
/* match jQuery UI .ui-widget-content color */
color: #2e6e9e;
margin-left: auto;
margin-right: auto;
width: 30em;
font-size: 12px;
font-family: 'Liberation Sans', Verdana, Arial, Helvetica, sans-serif;
}
.center_wrapper > div > div h1 {
text-align: center;
font-size: 14px;
}
#no_svg_wrapper {
display: none;
}

svg {
width: 100%;
height: 1px;
border: 1px solid #7fa2ff;
font-size: 15px;
/* font-size: 14px; */
}
svg.reselect {
border: 1px solid #ff3333;
}

/* "basic" font */
text {
font-size: 13px;
font-family: 'Liberation Sans', Verdana, Arial, Helvetica, sans-serif;
}

@-webkit-keyframes pulse {
0% { color: #9999ff; margin-top: 0; }
50% { color: #ffffff; margin-top: 7px; }
100% { color: #9999ff; margin-top: 0; }
}

path {
pointer-events: none;
}

/* "basic" font */
.span text {
/*  font-size: 10.5px; */
font-size: 10px;
text-anchor: middle;
font-family: 'PT Sans Caption', sans-serif;
pointer-events: none;
}

/* this should likely match span font */
.span_type_label {
font-size: 11px;
font-family: 'PT Sans Caption', sans-serif;
}
/* this should likely match arc font */
.arc_type_label {
font-size: 11px;
font-family: 'PT Sans Caption', sans-serif;
}
.attribute_type_label .ui-button-text {
font-size: 11px;
font-family: 'PT Sans Caption', sans-serif;
}

.span rect {
stroke-width: 0.75;
}

.glyph {
fill: #444444;
font-family: sans-serif;
font-weight: bold;
}
.attribute_warning {
stroke: red;
}

.span rect.False_positive {
stroke: #ff4141;
stroke-width: 2;
}

.shadow_True_positive {
fill: #00ff00;
}

.shadow_False_positive {
fill: #ff4141;
}

#commentpopup.comment_False_positive {
background-color: #ff4141;
}

.span rect.False_negative {
stroke: #c20000;
fill: #ffffff;
stroke-width: 2;
}

.shadow_False_negative {
fill: #c20000;
}

#commentpopup.comment_False_negative {
background-color: #c20000;
}

.span rect.AnnotationError {
stroke-width: 1;
}

.shadow_AnnotationError {
fill: #ff0000;
}

#commentpopup.comment_AnnotationError {
background-color: #ff7777;
}

.span rect.AnnotationWarning {
stroke-width: 1;
}

.shadow_AnnotationWarning {
fill: #ff8800;
}

#commentpopup.comment_AnnotationWarning {
background-color: #ff9900;
}

.shadow_AnnotatorNotes {
/* fill: #00cc00; */
fill: #3ab7ee;
}
#commentpopup.comment_AnnotatorNotes {
/* background-color: #00cc00; */
/* background-color: #DAF7DC; */
background-color: #d7e7ee;
}

.shadow_Normalized {
/* fill: #00cc00; */
fill: #3aee37;
}
#commentpopup.comment_Normalized {
/* background-color: #00cc00; */
/* background-color: #DAF7DC; */
background-color: #d7eee7;
}
rect.Normalized {
stroke-width: 1.5;
}

.shadow_AnnotationIncomplete {
fill: #aaaaaa;
}
.span rect.AnnotationIncomplete {
stroke: #002200;
stroke-width: 0.5;
fill: #ffffff;
}
#commentpopup.comment_AnnotationIncomplete {
background-color: #ffff77;
}

.shadow_AnnotationUnconfirmed {
fill: #eeeeee;
}
.span rect.AnnotationUnconfirmed {
stroke: #002200;
stroke-width: 0.5;
opacity : 0.5;
}
#commentpopup.comment_AnnotationUnconfirmed {
background-color: #ddddff;
}

.span rect.True_positive {
/* stroke: #007700; */
}

rect.shadow_EditHighlight {
fill: #ffff99;
}
.shadow_EditHighlight_arc {
stroke: #ffff99;
}

.span path {
fill: none;
}

.span path.curly {
/* 'stroke' def here blocks 'stroke' set in JS..? */
/* stroke: grey; */
stroke-width: 0.5;
}

.span path.boxcross {
stroke: black;
opacity: 0.5;
}

.arcs path {
stroke: #989898;
fill: none;
stroke-width: 1;
}

.arcs .highlight path {
stroke: #000000;
stroke-width: 1.5;
opacity: 1;
}
.arcs .highlight text {
stroke: black;
fill: black;
stroke-width: 0.5;
}
.span.highlight rect {
stroke-width: 2px;
}
.span rect.reselect {
stroke-width: 2px;
}
.span rect.reselectTarget {
stroke-width: 2px;
}
.arcs .reselect path {
stroke-width: 2px;
stroke: #ff0000 !important;
}
.arcs .reselect text {
fill: #ff0000 !important;
}

.span rect.badTarget {
stroke: #f00;
}

.arcs text {
font-size: 9px;
text-anchor: middle;
font-family: 'PT Sans Caption', sans-serif;
/* dominant-baseline: central; */
cursor: default;
}

.background0 {
stroke: none;
fill: #ffffff;
}

.background1 {
stroke: none;
fill: #eeeeee;
}

.backgroundHighlight {
stroke: none;
fill: #ffff99;
}

.sentnum text {
fill: #999999;
text-anchor: end;
}

.sentnum path {
stroke: #999999;
stroke-width: 1px;
}

.span_cue {
fill: #eeeeee !important;
}

.drag_stroke {
stroke: black;
}
.drag_fill {
fill: black;
}


.dialog {
display: none;
}
#span_free_div, #arc_free_div {
float: left;
}
fieldset {
/* match relevant parts of jQuery UI .ui-widget-content */
border: 1px solid #a6c9e2;
/* round corners, same as jQuery UI .ui-corner-all */
-moz-border-radius: 5px;
-webkit-border-radius: 5px;
border-radius: 5px;
/* to prevent border from running into legend */
margin-top: 5px;
}
fieldset legend {
font-weight: bold;
font-size: 90%;
-moz-border-radius: 3px;
-webkit-border-radius: 3px;
border-radius: 3px;
background-color: #70a8d2;
color: white;
padding-left: 0.5em;
padding-right: 0.5em;
}
.label-like {
/* for UI consistency, this should match the "fieldset legend" style;
sorry about the duplication. */
font-family: monospace;
font-weight: bold;
font-size: 90%;
/* match jQuery UI .ui-widget-content color */
color: #2e6e9e;
}

.accesskey {
text-decoration: underline;
}


.shadow {
-moz-box-shadow: 5px 5px 5px #444444;
-webkit-box-shadow: 5px 5px 5px #444444;
box-shadow: 5px 5px 5px #444444;
}

#span_selected, #arc_origin, #arc_target {
font-weight: bold;
}

#commentpopup {
font-family: 'Liberation Sans', Verdana, Arial, Helvetica, sans-serif;
position: fixed;
top: 0;
left: 0;
opacity: 0.95;
padding: 10px;
display: none;
border: 1px outset #000000;
background-color: #f5f5f9;
/* background-color: #d7e7ee; */
/* background-color: #eeeeee; */
color: #000000;
z-index: 20;
-moz-box-shadow: 5px 5px 5px #aaaaaa;
-webkit-box-shadow: 5px 5px 5px #aaaaaa;
box-shadow: 5px 5px 5px #aaaaaa;
-moz-border-radius: 3px;
-webkit-border-radius: 3px;
border-radius: 3px;
max-width: 80%;
}
#more_info_readme {
height: 350px;
}
#readme_container {
position: relative;
}
#more_readme_button {
padding: 2px 5px;
position: absolute;
top: -2px;
right: -2px;
}

.comment_id {
vertical-align: top;
float:right;
font-size: 75%;
font-family: monospace;
color: #333333;
}
.comment_type {
/* font-weight: bold; */
}
.comment_text {
font-weight: bold;
}
.comment_type_id_wrapper {
/* padding for floating ID */
padding-right: 2em;
}
.norm_info_label {
font-weight: bold;
font-size: 80%;
}
.norm_info_value {
font-size: 80%;
}
.norm_info_img {
float: right;
margin-left: 1em;
}

#search_form select {
width: 100%; /* deal with overflowing selectboxes */
}

.scroll_fset {
height: 200px;
}
.scroll_fset fieldset {
height: 100%;
overflow-x: hidden;
overflow-y: hidden;
}
/* HACK to display <legend> properly */
.scroll_fset {
margin-bottom: 2.5em;
}
.scroll_fset fieldset {
padding-bottom: 2em;
}
/* end HACK */
.scroll_fset div.scroller {
overflow: auto;
width: 100%;
height: 100%;
}

#span_highlight_link, #arc_highlight_link, #viewspan_highlight_link {
float: right;
}

.unselectable {
-moz-user-select: -moz-none;
-khtml-user-select: none;
-webkit-user-select: none;
-o-user-select: none;
user-select: none;
cursor: default;
}
@font-face {
font-family: 'Liberation Sans';
font-style: normal;
font-weight: normal;
src: local('Liberation Sans'), local('Liberation-Sans'), url('static/fonts/Liberation_Sans-Regular.ttf') format('truetype');
}
@font-face {
font-family: 'PT Sans Caption';
font-style: normal;
font-weight: normal;
src: local('PT Sans Caption'), local('PTSans-Caption'), url('static/fonts/PT_Sans-Caption-Web-Regular.ttf') format('truetype');
}

/* Apple iPad, iPhone, iPod */

* {
-webkit-tap-highlight-color: rgba(0,0,0,0);
-webkit-text-size-adjust: none;
select: none;
}

.span rect.AddedAnnotation {
stroke: #ff4141;
stroke-width: 2;
}
.shadow_AddedAnnotation {
fill: #ff4141;
}
#commentpopup.comment_AddedAnnotation {
background-color: #ffcccc;
}
.span rect.MissingAnnotation {
stroke: #ffffff;
stroke-width: 2;
}
.shadow_MissingAnnotation {
fill: #ff4141;
opacity: 0.3;
}
#commentpopup.comment_MissingAnnotation {
background-color: #ffcccc;
}
.span rect.MissingAnnotation + text {
opacity: 0.5;
}
.span rect.ChangedAnnotation {
stroke: #ffff99;
stroke-width: 2;
}
.shadow_ChangedAnnotation {
fill: #ff4141;
}
#commentpopup.comment_ChangedAnnotation {
background-color: #ffcccc;
}
</style>
</head>

<body oncontextmenu="return false;">
<div id="brat_blok"></div>
<script>
/**
Head JS		The only script in your <HEAD>
Copyright	Tero Piirainen (tipiirai)
License		MIT / http://bit.ly/mit-license
Version		0.9

http://headjs.com
*/(function(a){var b=a.documentElement,c,d,e=[],f=[],g={},h={},i=a.createElement("script").async===true||"MozAppearance"in a.documentElement.style||window.opera;var j=window.head_conf&&head_conf.head||"head",k=window[j]=window[j]||function(){k.ready.apply(null,arguments)};var l=0,m=1,n=2,o=3;i?k.js=function(){var a=arguments,b=a[a.length-1],c=[];t(b)||(b=null),s(a,function(d,e){d!=b&&(d=r(d),c.push(d),x(d,b&&e==a.length-2?function(){u(c)&&p(b)}:null))});return k}:k.js=function(){var a=arguments,b=[].slice.call(a,1),d=b[0];if(!c){f.push(function(){k.js.apply(null,a)});return k}d?(s(b,function(a){t(a)||w(r(a))}),x(r(a[0]),t(d)?d:function(){k.js.apply(null,b)})):x(r(a[0]));return k},k.ready=function(a,b){if(a=="dom"){d?p(b):e.push(b);return k}t(a)&&(b=a,a="ALL");var c=h[a];if(c&&c.state==o||a=="ALL"&&u()&&d){p(b);return k}var f=g[a];f?f.push(b):f=g[a]=[b];return k},k.ready("dom",function(){c&&u()&&s(g.ALL,function(a){p(a)}),k.feature&&k.feature("domloaded",true)});function p(a){a._done||(a(),a._done=1)}function q(a){var b=a.split("/"),c=b[b.length-1],d=c.indexOf("?");return d!=-1?c.substring(0,d):c}function r(a){var b;if(typeof a=="object")for(var c in a)a[c]&&(b={name:c,url:a[c]});else b={name:q(a),url:a};var d=h[b.name];if(d&&d.url===b.url)return d;h[b.name]=b;return b}function s(a,b){if(a){typeof a=="object"&&(a=[].slice.call(a));for(var c=0;c<a.length;c++)b.call(a,a[c],c)}}function t(a){return Object.prototype.toString.call(a)=="[object Function]"}function u(a){a=a||h;var b=false,c=0;for(var d in a){if(a[d].state!=o)return false;b=true,c++}return b||c===0}function v(a){a.state=l,s(a.onpreload,function(a){a.call()})}function w(a,b){a.state||(a.state=m,a.onpreload=[],y({src:a.url,type:"cache"},function(){v(a)}))}function x(a,b){if(a.state==o&&b)return b();if(a.state==n)return k.ready(a.name,b);if(a.state==m)return a.onpreload.push(function(){x(a,b)});a.state=n,y(a.url,function(){a.state=o,b&&b(),s(g[a.name],function(a){p(a)}),d&&u()&&s(g.ALL,function(a){p(a)})})}function y(c,d){var e=a.createElement("script");e.type="text/"+(c.type||"javascript"),e.src=c.src||c,e.async=false,e.onreadystatechange=e.onload=function(){var a=e.readyState;!d.done&&(!a||/loaded|complete/.test(a))&&(d(),d.done=true)},b.appendChild(e)}setTimeout(function(){c=true,s(f,function(a){a()})},0);function z(){d||(d=true,s(e,function(a){p(a)}))}window.addEventListener?(a.addEventListener("DOMContentLoaded",z,false),window.addEventListener("onload",z,false)):window.attachEvent&&(a.attachEvent("onreadystatechange",function(){a.readyState==="complete"&&z()}),window.frameElement==null&&b.doScroll&&function(){try{b.doScroll("left"),z()}catch(a){setTimeout(arguments.callee,1);return}}(),window.attachEvent("onload",z)),!a.readyState&&a.addEventListener&&(a.readyState="loading",a.addEventListener("DOMContentLoaded",handler=function(){a.removeEventListener("DOMContentLoaded",handler,false),a.readyState="complete"},false))})(document)
;

/*! jQuery v1.7.1 jquery.com | jquery.org/license */
(function(a,b){function cy(a){return f.isWindow(a)?a:a.nodeType===9?a.defaultView||a.parentWindow:!1}function cv(a){if(!ck[a]){var b=c.body,d=f("<"+a+">").appendTo(b),e=d.css("display");d.remove();if(e==="none"||e===""){cl||(cl=c.createElement("iframe"),cl.frameBorder=cl.width=cl.height=0),b.appendChild(cl);if(!cm||!cl.createElement)cm=(cl.contentWindow||cl.contentDocument).document,cm.write((c.compatMode==="CSS1Compat"?"<!doctype html>":"")+"<html><body>"),cm.close();d=cm.createElement(a),cm.body.appendChild(d),e=f.css(d,"display"),b.removeChild(cl)}ck[a]=e}return ck[a]}function cu(a,b){var c={};f.each(cq.concat.apply([],cq.slice(0,b)),function(){c[this]=a});return c}function ct(){cr=b}function cs(){setTimeout(ct,0);return cr=f.now()}function cj(){try{return new a.ActiveXObject("Microsoft.XMLHTTP")}catch(b){}}function ci(){try{return new a.XMLHttpRequest}catch(b){}}function cc(a,c){a.dataFilter&&(c=a.dataFilter(c,a.dataType));var d=a.dataTypes,e={},g,h,i=d.length,j,k=d[0],l,m,n,o,p;for(g=1;g<i;g++){if(g===1)for(h in a.converters)typeof h=="string"&&(e[h.toLowerCase()]=a.converters[h]);l=k,k=d[g];if(k==="*")k=l;else if(l!=="*"&&l!==k){m=l+" "+k,n=e[m]||e["* "+k];if(!n){p=b;for(o in e){j=o.split(" ");if(j[0]===l||j[0]==="*"){p=e[j[1]+" "+k];if(p){o=e[o],o===!0?n=p:p===!0&&(n=o);break}}}}!n&&!p&&f.error("No conversion from "+m.replace(" "," to ")),n!==!0&&(c=n?n(c):p(o(c)))}}return c}function cb(a,c,d){var e=a.contents,f=a.dataTypes,g=a.responseFields,h,i,j,k;for(i in g)i in d&&(c[g[i]]=d[i]);while(f[0]==="*")f.shift(),h===b&&(h=a.mimeType||c.getResponseHeader("content-type"));if(h)for(i in e)if(e[i]&&e[i].test(h)){f.unshift(i);break}if(f[0]in d)j=f[0];else{for(i in d){if(!f[0]||a.converters[i+" "+f[0]]){j=i;break}k||(k=i)}j=j||k}if(j){j!==f[0]&&f.unshift(j);return d[j]}}function ca(a,b,c,d){if(f.isArray(b))f.each(b,function(b,e){c||bE.test(a)?d(a,e):ca(a+"["+(typeof e=="object"||f.isArray(e)?b:"")+"]",e,c,d)});else if(!c&&b!=null&&typeof b=="object")for(var e in b)ca(a+"["+e+"]",b[e],c,d);else d(a,b)}function b_(a,c){var d,e,g=f.ajaxSettings.flatOptions||{};for(d in c)c[d]!==b&&((g[d]?a:e||(e={}))[d]=c[d]);e&&f.extend(!0,a,e)}function b$(a,c,d,e,f,g){f=f||c.dataTypes[0],g=g||{},g[f]=!0;var h=a[f],i=0,j=h?h.length:0,k=a===bT,l;for(;i<j&&(k||!l);i++)l=h[i](c,d,e),typeof l=="string"&&(!k||g[l]?l=b:(c.dataTypes.unshift(l),l=b$(a,c,d,e,l,g)));(k||!l)&&!g["*"]&&(l=b$(a,c,d,e,"*",g));return l}function bZ(a){return function(b,c){typeof b!="string"&&(c=b,b="*");if(f.isFunction(c)){var d=b.toLowerCase().split(bP),e=0,g=d.length,h,i,j;for(;e<g;e++)h=d[e],j=/^\+/.test(h),j&&(h=h.substr(1)||"*"),i=a[h]=a[h]||[],i[j?"unshift":"push"](c)}}}function bC(a,b,c){var d=b==="width"?a.offsetWidth:a.offsetHeight,e=b==="width"?bx:by,g=0,h=e.length;if(d>0){if(c!=="border")for(;g<h;g++)c||(d-=parseFloat(f.css(a,"padding"+e[g]))||0),c==="margin"?d+=parseFloat(f.css(a,c+e[g]))||0:d-=parseFloat(f.css(a,"border"+e[g]+"Width"))||0;return d+"px"}d=bz(a,b,b);if(d<0||d==null)d=a.style[b]||0;d=parseFloat(d)||0;if(c)for(;g<h;g++)d+=parseFloat(f.css(a,"padding"+e[g]))||0,c!=="padding"&&(d+=parseFloat(f.css(a,"border"+e[g]+"Width"))||0),c==="margin"&&(d+=parseFloat(f.css(a,c+e[g]))||0);return d+"px"}function bp(a,b){b.src?f.ajax({url:b.src,async:!1,dataType:"script"}):f.globalEval((b.text||b.textContent||b.innerHTML||"").replace(bf,"/*$0*/")),b.parentNode&&b.parentNode.removeChild(b)}function bo(a){var b=c.createElement("div");bh.appendChild(b),b.innerHTML=a.outerHTML;return b.firstChild}function bn(a){var b=(a.nodeName||"").toLowerCase();b==="input"?bm(a):b!=="script"&&typeof a.getElementsByTagName!="undefined"&&f.grep(a.getElementsByTagName("input"),bm)}function bm(a){if(a.type==="checkbox"||a.type==="radio")a.defaultChecked=a.checked}function bl(a){return typeof a.getElementsByTagName!="undefined"?a.getElementsByTagName("*"):typeof a.querySelectorAll!="undefined"?a.querySelectorAll("*"):[]}function bk(a,b){var c;if(b.nodeType===1){b.clearAttributes&&b.clearAttributes(),b.mergeAttributes&&b.mergeAttributes(a),c=b.nodeName.toLowerCase();if(c==="object")b.outerHTML=a.outerHTML;else if(c!=="input"||a.type!=="checkbox"&&a.type!=="radio"){if(c==="option")b.selected=a.defaultSelected;else if(c==="input"||c==="textarea")b.defaultValue=a.defaultValue}else a.checked&&(b.defaultChecked=b.checked=a.checked),b.value!==a.value&&(b.value=a.value);b.removeAttribute(f.expando)}}function bj(a,b){if(b.nodeType===1&&!!f.hasData(a)){var c,d,e,g=f._data(a),h=f._data(b,g),i=g.events;if(i){delete h.handle,h.events={};for(c in i)for(d=0,e=i[c].length;d<e;d++)f.event.add(b,c+(i[c][d].namespace?".":"")+i[c][d].namespace,i[c][d],i[c][d].data)}h.data&&(h.data=f.extend({},h.data))}}function bi(a,b){return f.nodeName(a,"table")?a.getElementsByTagName("tbody")[0]||a.appendChild(a.ownerDocument.createElement("tbody")):a}function U(a){var b=V.split("|"),c=a.createDocumentFragment();if(c.createElement)while(b.length)c.createElement(b.pop());return c}function T(a,b,c){b=b||0;if(f.isFunction(b))return f.grep(a,function(a,d){var e=!!b.call(a,d,a);return e===c});if(b.nodeType)return f.grep(a,function(a,d){return a===b===c});if(typeof b=="string"){var d=f.grep(a,function(a){return a.nodeType===1});if(O.test(b))return f.filter(b,d,!c);b=f.filter(b,d)}return f.grep(a,function(a,d){return f.inArray(a,b)>=0===c})}function S(a){return!a||!a.parentNode||a.parentNode.nodeType===11}function K(){return!0}function J(){return!1}function n(a,b,c){var d=b+"defer",e=b+"queue",g=b+"mark",h=f._data(a,d);h&&(c==="queue"||!f._data(a,e))&&(c==="mark"||!f._data(a,g))&&setTimeout(function(){!f._data(a,e)&&!f._data(a,g)&&(f.removeData(a,d,!0),h.fire())},0)}function m(a){for(var b in a){if(b==="data"&&f.isEmptyObject(a[b]))continue;if(b!=="toJSON")return!1}return!0}function l(a,c,d){if(d===b&&a.nodeType===1){var e="data-"+c.replace(k,"-$1").toLowerCase();d=a.getAttribute(e);if(typeof d=="string"){try{d=d==="true"?!0:d==="false"?!1:d==="null"?null:f.isNumeric(d)?parseFloat(d):j.test(d)?f.parseJSON(d):d}catch(g){}f.data(a,c,d)}else d=b}return d}function h(a){var b=g[a]={},c,d;a=a.split(/\s+/);for(c=0,d=a.length;c<d;c++)b[a[c]]=!0;return b}var c=a.document,d=a.navigator,e=a.location,f=function(){function J(){if(!e.isReady){try{c.documentElement.doScroll("left")}catch(a){setTimeout(J,1);return}e.ready()}}var e=function(a,b){return new e.fn.init(a,b,h)},f=a.jQuery,g=a.$,h,i=/^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/,j=/\S/,k=/^\s+/,l=/\s+$/,m=/^<(\w+)\s*\/?>(?:<\/\1>)?$/,n=/^[\],:{}\s]*$/,o=/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,p=/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,q=/(?:^|:|,)(?:\s*\[)+/g,r=/(webkit)[ \/]([\w.]+)/,s=/(opera)(?:.*version)?[ \/]([\w.]+)/,t=/(msie) ([\w.]+)/,u=/(mozilla)(?:.*? rv:([\w.]+))?/,v=/-([a-z]|[0-9])/ig,w=/^-ms-/,x=function(a,b){return(b+"").toUpperCase()},y=d.userAgent,z,A,B,C=Object.prototype.toString,D=Object.prototype.hasOwnProperty,E=Array.prototype.push,F=Array.prototype.slice,G=String.prototype.trim,H=Array.prototype.indexOf,I={};e.fn=e.prototype={constructor:e,init:function(a,d,f){var g,h,j,k;if(!a)return this;if(a.nodeType){this.context=this[0]=a,this.length=1;return this}if(a==="body"&&!d&&c.body){this.context=c,this[0]=c.body,this.selector=a,this.length=1;return this}if(typeof a=="string"){a.charAt(0)!=="<"||a.charAt(a.length-1)!==">"||a.length<3?g=i.exec(a):g=[null,a,null];if(g&&(g[1]||!d)){if(g[1]){d=d instanceof e?d[0]:d,k=d?d.ownerDocument||d:c,j=m.exec(a),j?e.isPlainObject(d)?(a=[c.createElement(j[1])],e.fn.attr.call(a,d,!0)):a=[k.createElement(j[1])]:(j=e.buildFragment([g[1]],[k]),a=(j.cacheable?e.clone(j.fragment):j.fragment).childNodes);return e.merge(this,a)}h=c.getElementById(g[2]);if(h&&h.parentNode){if(h.id!==g[2])return f.find(a);this.length=1,this[0]=h}this.context=c,this.selector=a;return this}return!d||d.jquery?(d||f).find(a):this.constructor(d).find(a)}if(e.isFunction(a))return f.ready(a);a.selector!==b&&(this.selector=a.selector,this.context=a.context);return e.makeArray(a,this)},selector:"",jquery:"1.7.1",length:0,size:function(){return this.length},toArray:function(){return F.call(this,0)},get:function(a){return a==null?this.toArray():a<0?this[this.length+a]:this[a]},pushStack:function(a,b,c){var d=this.constructor();e.isArray(a)?E.apply(d,a):e.merge(d,a),d.prevObject=this,d.context=this.context,b==="find"?d.selector=this.selector+(this.selector?" ":"")+c:b&&(d.selector=this.selector+"."+b+"("+c+")");return d},each:function(a,b){return e.each(this,a,b)},ready:function(a){e.bindReady(),A.add(a);return this},eq:function(a){a=+a;return a===-1?this.slice(a):this.slice(a,a+1)},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},slice:function(){return this.pushStack(F.apply(this,arguments),"slice",F.call(arguments).join(","))},map:function(a){return this.pushStack(e.map(this,function(b,c){return a.call(b,c,b)}))},end:function(){return this.prevObject||this.constructor(null)},push:E,sort:[].sort,splice:[].splice},e.fn.init.prototype=e.fn,e.extend=e.fn.extend=function(){var a,c,d,f,g,h,i=arguments[0]||{},j=1,k=arguments.length,l=!1;typeof i=="boolean"&&(l=i,i=arguments[1]||{},j=2),typeof i!="object"&&!e.isFunction(i)&&(i={}),k===j&&(i=this,--j);for(;j<k;j++)if((a=arguments[j])!=null)for(c in a){d=i[c],f=a[c];if(i===f)continue;l&&f&&(e.isPlainObject(f)||(g=e.isArray(f)))?(g?(g=!1,h=d&&e.isArray(d)?d:[]):h=d&&e.isPlainObject(d)?d:{},i[c]=e.extend(l,h,f)):f!==b&&(i[c]=f)}return i},e.extend({noConflict:function(b){a.$===e&&(a.$=g),b&&a.jQuery===e&&(a.jQuery=f);return e},isReady:!1,readyWait:1,holdReady:function(a){a?e.readyWait++:e.ready(!0)},ready:function(a){if(a===!0&&!--e.readyWait||a!==!0&&!e.isReady){if(!c.body)return setTimeout(e.ready,1);e.isReady=!0;if(a!==!0&&--e.readyWait>0)return;A.fireWith(c,[e]),e.fn.trigger&&e(c).trigger("ready").off("ready")}},bindReady:function(){if(!A){A=e.Callbacks("once memory");if(c.readyState==="complete")return setTimeout(e.ready,1);if(c.addEventListener)c.addEventListener("DOMContentLoaded",B,!1),a.addEventListener("load",e.ready,!1);else if(c.attachEvent){c.attachEvent("onreadystatechange",B),a.attachEvent("onload",e.ready);var b=!1;try{b=a.frameElement==null}catch(d){}c.documentElement.doScroll&&b&&J()}}},isFunction:function(a){return e.type(a)==="function"},isArray:Array.isArray||function(a){return e.type(a)==="array"},isWindow:function(a){return a&&typeof a=="object"&&"setInterval"in a},isNumeric:function(a){return!isNaN(parseFloat(a))&&isFinite(a)},type:function(a){return a==null?String(a):I[C.call(a)]||"object"},isPlainObject:function(a){if(!a||e.type(a)!=="object"||a.nodeType||e.isWindow(a))return!1;try{if(a.constructor&&!D.call(a,"constructor")&&!D.call(a.constructor.prototype,"isPrototypeOf"))return!1}catch(c){return!1}var d;for(d in a);return d===b||D.call(a,d)},isEmptyObject:function(a){for(var b in a)return!1;return!0},error:function(a){throw new Error(a)},parseJSON:function(b){if(typeof b!="string"||!b)return null;b=e.trim(b);if(a.JSON&&a.JSON.parse)return a.JSON.parse(b);if(n.test(b.replace(o,"@").replace(p,"]").replace(q,"")))return(new Function("return "+b))();e.error("Invalid JSON: "+b)},parseXML:function(c){var d,f;try{a.DOMParser?(f=new DOMParser,d=f.parseFromString(c,"text/xml")):(d=new ActiveXObject("Microsoft.XMLDOM"),d.async="false",d.loadXML(c))}catch(g){d=b}(!d||!d.documentElement||d.getElementsByTagName("parsererror").length)&&e.error("Invalid XML: "+c);return d},noop:function(){},globalEval:function(b){b&&j.test(b)&&(a.execScript||function(b){a.eval.call(a,b)})(b)},camelCase:function(a){return a.replace(w,"ms-").replace(v,x)},nodeName:function(a,b){return a.nodeName&&a.nodeName.toUpperCase()===b.toUpperCase()},each:function(a,c,d){var f,g=0,h=a.length,i=h===b||e.isFunction(a);if(d){if(i){for(f in a)if(c.apply(a[f],d)===!1)break}else for(;g<h;)if(c.apply(a[g++],d)===!1)break}else if(i){for(f in a)if(c.call(a[f],f,a[f])===!1)break}else for(;g<h;)if(c.call(a[g],g,a[g++])===!1)break;return a},trim:G?function(a){return a==null?"":G.call(a)}:function(a){return a==null?"":(a+"").replace(k,"").replace(l,"")},makeArray:function(a,b){var c=b||[];if(a!=null){var d=e.type(a);a.length==null||d==="string"||d==="function"||d==="regexp"||e.isWindow(a)?E.call(c,a):e.merge(c,a)}return c},inArray:function(a,b,c){var d;if(b){if(H)return H.call(b,a,c);d=b.length,c=c?c<0?Math.max(0,d+c):c:0;for(;c<d;c++)if(c in b&&b[c]===a)return c}return-1},merge:function(a,c){var d=a.length,e=0;if(typeof c.length=="number")for(var f=c.length;e<f;e++)a[d++]=c[e];else while(c[e]!==b)a[d++]=c[e++];a.length=d;return a},grep:function(a,b,c){var d=[],e;c=!!c;for(var f=0,g=a.length;f<g;f++)e=!!b(a[f],f),c!==e&&d.push(a[f]);return d},map:function(a,c,d){var f,g,h=[],i=0,j=a.length,k=a instanceof e||j!==b&&typeof j=="number"&&(j>0&&a[0]&&a[j-1]||j===0||e.isArray(a));if(k)for(;i<j;i++)f=c(a[i],i,d),f!=null&&(h[h.length]=f);else for(g in a)f=c(a[g],g,d),f!=null&&(h[h.length]=f);return h.concat.apply([],h)},guid:1,proxy:function(a,c){if(typeof c=="string"){var d=a[c];c=a,a=d}if(!e.isFunction(a))return b;var f=F.call(arguments,2),g=function(){return a.apply(c,f.concat(F.call(arguments)))};g.guid=a.guid=a.guid||g.guid||e.guid++;return g},access:function(a,c,d,f,g,h){var i=a.length;if(typeof c=="object"){for(var j in c)e.access(a,j,c[j],f,g,d);return a}if(d!==b){f=!h&&f&&e.isFunction(d);for(var k=0;k<i;k++)g(a[k],c,f?d.call(a[k],k,g(a[k],c)):d,h);return a}return i?g(a[0],c):b},now:function(){return(new Date).getTime()},uaMatch:function(a){a=a.toLowerCase();var b=r.exec(a)||s.exec(a)||t.exec(a)||a.indexOf("compatible")<0&&u.exec(a)||[];return{browser:b[1]||"",version:b[2]||"0"}},sub:function(){function a(b,c){return new a.fn.init(b,c)}e.extend(!0,a,this),a.superclass=this,a.fn=a.prototype=this(),a.fn.constructor=a,a.sub=this.sub,a.fn.init=function(d,f){f&&f instanceof e&&!(f instanceof a)&&(f=a(f));return e.fn.init.call(this,d,f,b)},a.fn.init.prototype=a.fn;var b=a(c);return a},browser:{}}),e.each("Boolean Number String Function Array Date RegExp Object".split(" "),function(a,b){I["[object "+b+"]"]=b.toLowerCase()}),z=e.uaMatch(y),z.browser&&(e.browser[z.browser]=!0,e.browser.version=z.version),e.browser.webkit&&(e.browser.safari=!0),j.test(" ")&&(k=/^[\s\xA0]+/,l=/[\s\xA0]+$/),h=e(c),c.addEventListener?B=function(){c.removeEventListener("DOMContentLoaded",B,!1),e.ready()}:c.attachEvent&&(B=function(){c.readyState==="complete"&&(c.detachEvent("onreadystatechange",B),e.ready())});return e}(),g={};f.Callbacks=function(a){a=a?g[a]||h(a):{};var c=[],d=[],e,i,j,k,l,m=function(b){var d,e,g,h,i;for(d=0,e=b.length;d<e;d++)g=b[d],h=f.type(g),h==="array"?m(g):h==="function"&&(!a.unique||!o.has(g))&&c.push(g)},n=function(b,f){f=f||[],e=!a.memory||[b,f],i=!0,l=j||0,j=0,k=c.length;for(;c&&l<k;l++)if(c[l].apply(b,f)===!1&&a.stopOnFalse){e=!0;break}i=!1,c&&(a.once?e===!0?o.disable():c=[]:d&&d.length&&(e=d.shift(),o.fireWith(e[0],e[1])))},o={add:function(){if(c){var a=c.length;m(arguments),i?k=c.length:e&&e!==!0&&(j=a,n(e[0],e[1]))}return this},remove:function(){if(c){var b=arguments,d=0,e=b.length;for(;d<e;d++)for(var f=0;f<c.length;f++)if(b[d]===c[f]){i&&f<=k&&(k--,f<=l&&l--),c.splice(f--,1);if(a.unique)break}}return this},has:function(a){if(c){var b=0,d=c.length;for(;b<d;b++)if(a===c[b])return!0}return!1},empty:function(){c=[];return this},disable:function(){c=d=e=b;return this},disabled:function(){return!c},lock:function(){d=b,(!e||e===!0)&&o.disable();return this},locked:function(){return!d},fireWith:function(b,c){d&&(i?a.once||d.push([b,c]):(!a.once||!e)&&n(b,c));return this},fire:function(){o.fireWith(this,arguments);return this},fired:function(){return!!e}};return o};var i=[].slice;f.extend({Deferred:function(a){var b=f.Callbacks("once memory"),c=f.Callbacks("once memory"),d=f.Callbacks("memory"),e="pending",g={resolve:b,reject:c,notify:d},h={done:b.add,fail:c.add,progress:d.add,state:function(){return e},isResolved:b.fired,isRejected:c.fired,then:function(a,b,c){i.done(a).fail(b).progress(c);return this},always:function(){i.done.apply(i,arguments).fail.apply(i,arguments);return this},pipe:function(a,b,c){return f.Deferred(function(d){f.each({done:[a,"resolve"],fail:[b,"reject"],progress:[c,"notify"]},function(a,b){var c=b[0],e=b[1],g;f.isFunction(c)?i[a](function(){g=c.apply(this,arguments),g&&f.isFunction(g.promise)?g.promise().then(d.resolve,d.reject,d.notify):d[e+"With"](this===i?d:this,[g])}):i[a](d[e])})}).promise()},promise:function(a){if(a==null)a=h;else for(var b in h)a[b]=h[b];return a}},i=h.promise({}),j;for(j in g)i[j]=g[j].fire,i[j+"With"]=g[j].fireWith;i.done(function(){e="resolved"},c.disable,d.lock).fail(function(){e="rejected"},b.disable,d.lock),a&&a.call(i,i);return i},when:function(a){function m(a){return function(b){e[a]=arguments.length>1?i.call(arguments,0):b,j.notifyWith(k,e)}}function l(a){return function(c){b[a]=arguments.length>1?i.call(arguments,0):c,--g||j.resolveWith(j,b)}}var b=i.call(arguments,0),c=0,d=b.length,e=Array(d),g=d,h=d,j=d<=1&&a&&f.isFunction(a.promise)?a:f.Deferred(),k=j.promise();if(d>1){for(;c<d;c++)b[c]&&b[c].promise&&f.isFunction(b[c].promise)?b[c].promise().then(l(c),j.reject,m(c)):--g;g||j.resolveWith(j,b)}else j!==a&&j.resolveWith(j,d?[a]:[]);return k}}),f.support=function(){var b,d,e,g,h,i,j,k,l,m,n,o,p,q=c.createElement("div"),r=c.documentElement;q.setAttribute("className","t"),q.innerHTML="   <link/><table></table><a href='/a' style='top:1px;float:left;opacity:.55;'>a</a><input type='checkbox'/>",d=q.getElementsByTagName("*"),e=q.getElementsByTagName("a")[0];if(!d||!d.length||!e)return{};g=c.createElement("select"),h=g.appendChild(c.createElement("option")),i=q.getElementsByTagName("input")[0],b={leadingWhitespace:q.firstChild.nodeType===3,tbody:!q.getElementsByTagName("tbody").length,htmlSerialize:!!q.getElementsByTagName("link").length,style:/top/.test(e.getAttribute("style")),hrefNormalized:e.getAttribute("href")==="/a",opacity:/^0.55/.test(e.style.opacity),cssFloat:!!e.style.cssFloat,checkOn:i.value==="on",optSelected:h.selected,getSetAttribute:q.className!=="t",enctype:!!c.createElement("form").enctype,html5Clone:c.createElement("nav").cloneNode(!0).outerHTML!=="<:nav></:nav>",submitBubbles:!0,changeBubbles:!0,focusinBubbles:!1,deleteExpando:!0,noCloneEvent:!0,inlineBlockNeedsLayout:!1,shrinkWrapBlocks:!1,reliableMarginRight:!0},i.checked=!0,b.noCloneChecked=i.cloneNode(!0).checked,g.disabled=!0,b.optDisabled=!h.disabled;try{delete q.test}catch(s){b.deleteExpando=!1}!q.addEventListener&&q.attachEvent&&q.fireEvent&&(q.attachEvent("onclick",function(){b.noCloneEvent=!1}),q.cloneNode(!0).fireEvent("onclick")),i=c.createElement("input"),i.value="t",i.setAttribute("type","radio"),b.radioValue=i.value==="t",i.setAttribute("checked","checked"),q.appendChild(i),k=c.createDocumentFragment(),k.appendChild(q.lastChild),b.checkClone=k.cloneNode(!0).cloneNode(!0).lastChild.checked,b.appendChecked=i.checked,k.removeChild(i),k.appendChild(q),q.innerHTML="",a.getComputedStyle&&(j=c.createElement("div"),j.style.width="0",j.style.marginRight="0",q.style.width="2px",q.appendChild(j),b.reliableMarginRight=(parseInt((a.getComputedStyle(j,null)||{marginRight:0}).marginRight,10)||0)===0);if(q.attachEvent)for(o in{submit:1,change:1,focusin:1})n="on"+o,p=n in q,p||(q.setAttribute(n,"return;"),p=typeof q[n]=="function"),b[o+"Bubbles"]=p;k.removeChild(q),k=g=h=j=q=i=null,f(function(){var a,d,e,g,h,i,j,k,m,n,o,r=c.getElementsByTagName("body")[0];!r||(j=1,k="position:absolute;top:0;left:0;width:1px;height:1px;margin:0;",m="visibility:hidden;border:0;",n="style='"+k+"border:5px solid #000;padding:0;'",o="<div "+n+"><div></div></div>"+"<table "+n+" cellpadding='0' cellspacing='0'>"+"<tr><td></td></tr></table>",a=c.createElement("div"),a.style.cssText=m+"width:0;height:0;position:static;top:0;margin-top:"+j+"px",r.insertBefore(a,r.firstChild),q=c.createElement("div"),a.appendChild(q),q.innerHTML="<table><tr><td style='padding:0;border:0;display:none'></td><td>t</td></tr></table>",l=q.getElementsByTagName("td"),p=l[0].offsetHeight===0,l[0].style.display="",l[1].style.display="none",b.reliableHiddenOffsets=p&&l[0].offsetHeight===0,q.innerHTML="",q.style.width=q.style.paddingLeft="1px",f.boxModel=b.boxModel=q.offsetWidth===2,typeof q.style.zoom!="undefined"&&(q.style.display="inline",q.style.zoom=1,b.inlineBlockNeedsLayout=q.offsetWidth===2,q.style.display="",q.innerHTML="<div style='width:4px;'></div>",b.shrinkWrapBlocks=q.offsetWidth!==2),q.style.cssText=k+m,q.innerHTML=o,d=q.firstChild,e=d.firstChild,h=d.nextSibling.firstChild.firstChild,i={doesNotAddBorder:e.offsetTop!==5,doesAddBorderForTableAndCells:h.offsetTop===5},e.style.position="fixed",e.style.top="20px",i.fixedPosition=e.offsetTop===20||e.offsetTop===15,e.style.position=e.style.top="",d.style.overflow="hidden",d.style.position="relative",i.subtractsBorderForOverflowNotVisible=e.offsetTop===-5,i.doesNotIncludeMarginInBodyOffset=r.offsetTop!==j,r.removeChild(a),q=a=null,f.extend(b,i))});return b}();var j=/^(?:\{.*\}|\[.*\])$/,k=/([A-Z])/g;f.extend({cache:{},uuid:0,expando:"jQuery"+(f.fn.jquery+Math.random()).replace(/\D/g,""),noData:{embed:!0,object:"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",applet:!0},hasData:function(a){a=a.nodeType?f.cache[a[f.expando]]:a[f.expando];return!!a&&!m(a)},data:function(a,c,d,e){if(!!f.acceptData(a)){var g,h,i,j=f.expando,k=typeof c=="string",l=a.nodeType,m=l?f.cache:a,n=l?a[j]:a[j]&&j,o=c==="events";if((!n||!m[n]||!o&&!e&&!m[n].data)&&k&&d===b)return;n||(l?a[j]=n=++f.uuid:n=j),m[n]||(m[n]={},l||(m[n].toJSON=f.noop));if(typeof c=="object"||typeof c=="function")e?m[n]=f.extend(m[n],c):m[n].data=f.extend(m[n].data,c);g=h=m[n],e||(h.data||(h.data={}),h=h.data),d!==b&&(h[f.camelCase(c)]=d);if(o&&!h[c])return g.events;k?(i=h[c],i==null&&(i=h[f.camelCase(c)])):i=h;return i}},removeData:function(a,b,c){if(!!f.acceptData(a)){var d,e,g,h=f.expando,i=a.nodeType,j=i?f.cache:a,k=i?a[h]:h;if(!j[k])return;if(b){d=c?j[k]:j[k].data;if(d){f.isArray(b)||(b in d?b=[b]:(b=f.camelCase(b),b in d?b=[b]:b=b.split(" ")));for(e=0,g=b.length;e<g;e++)delete d[b[e]];if(!(c?m:f.isEmptyObject)(d))return}}if(!c){delete j[k].data;if(!m(j[k]))return}f.support.deleteExpando||!j.setInterval?delete j[k]:j[k]=null,i&&(f.support.deleteExpando?delete a[h]:a.removeAttribute?a.removeAttribute(h):a[h]=null)}},_data:function(a,b,c){return f.data(a,b,c,!0)},acceptData:function(a){if(a.nodeName){var b=f.noData[a.nodeName.toLowerCase()];if(b)return b!==!0&&a.getAttribute("classid")===b}return!0}}),f.fn.extend({data:function(a,c){var d,e,g,h=null;if(typeof a=="undefined"){if(this.length){h=f.data(this[0]);if(this[0].nodeType===1&&!f._data(this[0],"parsedAttrs")){e=this[0].attributes;for(var i=0,j=e.length;i<j;i++)g=e[i].name,g.indexOf("data-")===0&&(g=f.camelCase(g.substring(5)),l(this[0],g,h[g]));f._data(this[0],"parsedAttrs",!0)}}return h}if(typeof a=="object")return this.each(function(){f.data(this,a)});d=a.split("."),d[1]=d[1]?"."+d[1]:"";if(c===b){h=this.triggerHandler("getData"+d[1]+"!",[d[0]]),h===b&&this.length&&(h=f.data(this[0],a),h=l(this[0],a,h));return h===b&&d[1]?this.data(d[0]):h}return this.each(function(){var b=f(this),e=[d[0],c];b.triggerHandler("setData"+d[1]+"!",e),f.data(this,a,c),b.triggerHandler("changeData"+d[1]+"!",e)})},removeData:function(a){return this.each(function(){f.removeData(this,a)})}}),f.extend({_mark:function(a,b){a&&(b=(b||"fx")+"mark",f._data(a,b,(f._data(a,b)||0)+1))},_unmark:function(a,b,c){a!==!0&&(c=b,b=a,a=!1);if(b){c=c||"fx";var d=c+"mark",e=a?0:(f._data(b,d)||1)-1;e?f._data(b,d,e):(f.removeData(b,d,!0),n(b,c,"mark"))}},queue:function(a,b,c){var d;if(a){b=(b||"fx")+"queue",d=f._data(a,b),c&&(!d||f.isArray(c)?d=f._data(a,b,f.makeArray(c)):d.push(c));return d||[]}},dequeue:function(a,b){b=b||"fx";var c=f.queue(a,b),d=c.shift(),e={};d==="inprogress"&&(d=c.shift()),d&&(b==="fx"&&c.unshift("inprogress"),f._data(a,b+".run",e),d.call(a,function(){f.dequeue(a,b)},e)),c.length||(f.removeData(a,b+"queue "+b+".run",!0),n(a,b,"queue"))}}),f.fn.extend({queue:function(a,c){typeof a!="string"&&(c=a,a="fx");if(c===b)return f.queue(this[0],a);return this.each(function(){var b=f.queue(this,a,c);a==="fx"&&b[0]!=="inprogress"&&f.dequeue(this,a)})},dequeue:function(a){return this.each(function(){f.dequeue(this,a)})},delay:function(a,b){a=f.fx?f.fx.speeds[a]||a:a,b=b||"fx";return this.queue(b,function(b,c){var d=setTimeout(b,a);c.stop=function(){clearTimeout(d)}})},clearQueue:function(a){return this.queue(a||"fx",[])},promise:function(a,c){function m(){--h||d.resolveWith(e,[e])}typeof a!="string"&&(c=a,a=b),a=a||"fx";var d=f.Deferred(),e=this,g=e.length,h=1,i=a+"defer",j=a+"queue",k=a+"mark",l;while(g--)if(l=f.data(e[g],i,b,!0)||(f.data(e[g],j,b,!0)||f.data(e[g],k,b,!0))&&f.data(e[g],i,f.Callbacks("once memory"),!0))h++,l.add(m);m();return d.promise()}});var o=/[\n\t\r]/g,p=/\s+/,q=/\r/g,r=/^(?:button|input)$/i,s=/^(?:button|input|object|select|textarea)$/i,t=/^a(?:rea)?$/i,u=/^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,v=f.support.getSetAttribute,w,x,y;f.fn.extend({attr:function(a,b){return f.access(this,a,b,!0,f.attr)},removeAttr:function(a){return this.each(function(){f.removeAttr(this,a)})},prop:function(a,b){return f.access(this,a,b,!0,f.prop)},removeProp:function(a){a=f.propFix[a]||a;return this.each(function(){try{this[a]=b,delete this[a]}catch(c){}})},addClass:function(a){var b,c,d,e,g,h,i;if(f.isFunction(a))return this.each(function(b){f(this).addClass(a.call(this,b,this.className))});if(a&&typeof a=="string"){b=a.split(p);for(c=0,d=this.length;c<d;c++){e=this[c];if(e.nodeType===1)if(!e.className&&b.length===1)e.className=a;else{g=" "+e.className+" ";for(h=0,i=b.length;h<i;h++)~g.indexOf(" "+b[h]+" ")||(g+=b[h]+" ");e.className=f.trim(g)}}}return this},removeClass:function(a){var c,d,e,g,h,i,j;if(f.isFunction(a))return this.each(function(b){f(this).removeClass(a.call(this,b,this.className))});if(a&&typeof a=="string"||a===b){c=(a||"").split(p);for(d=0,e=this.length;d<e;d++){g=this[d];if(g.nodeType===1&&g.className)if(a){h=(" "+g.className+" ").replace(o," ");for(i=0,j=c.length;i<j;i++)h=h.replace(" "+c[i]+" "," ");g.className=f.trim(h)}else g.className=""}}return this},toggleClass:function(a,b){var c=typeof a,d=typeof b=="boolean";if(f.isFunction(a))return this.each(function(c){f(this).toggleClass(a.call(this,c,this.className,b),b)});return this.each(function(){if(c==="string"){var e,g=0,h=f(this),i=b,j=a.split(p);while(e=j[g++])i=d?i:!h.hasClass(e),h[i?"addClass":"removeClass"](e)}else if(c==="undefined"||c==="boolean")this.className&&f._data(this,"__className__",this.className),this.className=this.className||a===!1?"":f._data(this,"__className__")||""})},hasClass:function(a){var b=" "+a+" ",c=0,d=this.length;for(;c<d;c++)if(this[c].nodeType===1&&(" "+this[c].className+" ").replace(o," ").indexOf(b)>-1)return!0;return!1},val:function(a){var c,d,e,g=this[0];{if(!!arguments.length){e=f.isFunction(a);return this.each(function(d){var g=f(this),h;if(this.nodeType===1){e?h=a.call(this,d,g.val()):h=a,h==null?h="":typeof h=="number"?h+="":f.isArray(h)&&(h=f.map(h,function(a){return a==null?"":a+""})),c=f.valHooks[this.nodeName.toLowerCase()]||f.valHooks[this.type];if(!c||!("set"in c)||c.set(this,h,"value")===b)this.value=h}})}if(g){c=f.valHooks[g.nodeName.toLowerCase()]||f.valHooks[g.type];if(c&&"get"in c&&(d=c.get(g,"value"))!==b)return d;d=g.value;return typeof d=="string"?d.replace(q,""):d==null?"":d}}}}),f.extend({valHooks:{option:{get:function(a){var b=a.attributes.value;return!b||b.specified?a.value:a.text}},select:{get:function(a){var b,c,d,e,g=a.selectedIndex,h=[],i=a.options,j=a.type==="select-one";if(g<0)return null;c=j?g:0,d=j?g+1:i.length;for(;c<d;c++){e=i[c];if(e.selected&&(f.support.optDisabled?!e.disabled:e.getAttribute("disabled")===null)&&(!e.parentNode.disabled||!f.nodeName(e.parentNode,"optgroup"))){b=f(e).val();if(j)return b;h.push(b)}}if(j&&!h.length&&i.length)return f(i[g]).val();return h},set:function(a,b){var c=f.makeArray(b);f(a).find("option").each(function(){this.selected=f.inArray(f(this).val(),c)>=0}),c.length||(a.selectedIndex=-1);return c}}},attrFn:{val:!0,css:!0,html:!0,text:!0,data:!0,width:!0,height:!0,offset:!0},attr:function(a,c,d,e){var g,h,i,j=a.nodeType;if(!!a&&j!==3&&j!==8&&j!==2){if(e&&c in f.attrFn)return f(a)[c](d);if(typeof a.getAttribute=="undefined")return f.prop(a,c,d);i=j!==1||!f.isXMLDoc(a),i&&(c=c.toLowerCase(),h=f.attrHooks[c]||(u.test(c)?x:w));if(d!==b){if(d===null){f.removeAttr(a,c);return}if(h&&"set"in h&&i&&(g=h.set(a,d,c))!==b)return g;a.setAttribute(c,""+d);return d}if(h&&"get"in h&&i&&(g=h.get(a,c))!==null)return g;g=a.getAttribute(c);return g===null?b:g}},removeAttr:function(a,b){var c,d,e,g,h=0;if(b&&a.nodeType===1){d=b.toLowerCase().split(p),g=d.length;for(;h<g;h++)e=d[h],e&&(c=f.propFix[e]||e,f.attr(a,e,""),a.removeAttribute(v?e:c),u.test(e)&&c in a&&(a[c]=!1))}},attrHooks:{type:{set:function(a,b){if(r.test(a.nodeName)&&a.parentNode)f.error("type property can't be changed");else if(!f.support.radioValue&&b==="radio"&&f.nodeName(a,"input")){var c=a.value;a.setAttribute("type",b),c&&(a.value=c);return b}}},value:{get:function(a,b){if(w&&f.nodeName(a,"button"))return w.get(a,b);return b in a?a.value:null},set:function(a,b,c){if(w&&f.nodeName(a,"button"))return w.set(a,b,c);a.value=b}}},propFix:{tabindex:"tabIndex",readonly:"readOnly","for":"htmlFor","class":"className",maxlength:"maxLength",cellspacing:"cellSpacing",cellpadding:"cellPadding",rowspan:"rowSpan",colspan:"colSpan",usemap:"useMap",frameborder:"frameBorder",contenteditable:"contentEditable"},prop:function(a,c,d){var e,g,h,i=a.nodeType;if(!!a&&i!==3&&i!==8&&i!==2){h=i!==1||!f.isXMLDoc(a),h&&(c=f.propFix[c]||c,g=f.propHooks[c]);return d!==b?g&&"set"in g&&(e=g.set(a,d,c))!==b?e:a[c]=d:g&&"get"in g&&(e=g.get(a,c))!==null?e:a[c]}},propHooks:{tabIndex:{get:function(a){var c=a.getAttributeNode("tabindex");return c&&c.specified?parseInt(c.value,10):s.test(a.nodeName)||t.test(a.nodeName)&&a.href?0:b}}}}),f.attrHooks.tabindex=f.propHooks.tabIndex,x={get:function(a,c){var d,e=f.prop(a,c);return e===!0||typeof e!="boolean"&&(d=a.getAttributeNode(c))&&d.nodeValue!==!1?c.toLowerCase():b},set:function(a,b,c){var d;b===!1?f.removeAttr(a,c):(d=f.propFix[c]||c,d in a&&(a[d]=!0),a.setAttribute(c,c.toLowerCase()));return c}},v||(y={name:!0,id:!0},w=f.valHooks.button={get:function(a,c){var d;d=a.getAttributeNode(c);return d&&(y[c]?d.nodeValue!=="":d.specified)?d.nodeValue:b},set:function(a,b,d){var e=a.getAttributeNode(d);e||(e=c.createAttribute(d),a.setAttributeNode(e));return e.nodeValue=b+""}},f.attrHooks.tabindex.set=w.set,f.each(["width","height"],function(a,b){f.attrHooks[b]=f.extend(f.attrHooks[b],{set:function(a,c){if(c===""){a.setAttribute(b,"auto");return c}}})}),f.attrHooks.contenteditable={get:w.get,set:function(a,b,c){b===""&&(b="false"),w.set(a,b,c)}}),f.support.hrefNormalized||f.each(["href","src","width","height"],function(a,c){f.attrHooks[c]=f.extend(f.attrHooks[c],{get:function(a){var d=a.getAttribute(c,2);return d===null?b:d}})}),f.support.style||(f.attrHooks.style={get:function(a){return a.style.cssText.toLowerCase()||b},set:function(a,b){return a.style.cssText=""+b}}),f.support.optSelected||(f.propHooks.selected=f.extend(f.propHooks.selected,{get:function(a){var b=a.parentNode;b&&(b.selectedIndex,b.parentNode&&b.parentNode.selectedIndex);return null}})),f.support.enctype||(f.propFix.enctype="encoding"),f.support.checkOn||f.each(["radio","checkbox"],function(){f.valHooks[this]={get:function(a){return a.getAttribute("value")===null?"on":a.value}}}),f.each(["radio","checkbox"],function(){f.valHooks[this]=f.extend(f.valHooks[this],{set:function(a,b){if(f.isArray(b))return a.checked=f.inArray(f(a).val(),b)>=0}})});var z=/^(?:textarea|input|select)$/i,A=/^([^\.]*)?(?:\.(.+))?$/,B=/\bhover(\.\S+)?\b/,C=/^key/,D=/^(?:mouse|contextmenu)|click/,E=/^(?:focusinfocus|focusoutblur)$/,F=/^(\w*)(?:#([\w\-]+))?(?:\.([\w\-]+))?$/,G=function(a){var b=F.exec(a);b&&(b[1]=(b[1]||"").toLowerCase(),b[3]=b[3]&&new RegExp("(?:^|\\s)"+b[3]+"(?:\\s|$)"));return b},H=function(a,b){var c=a.attributes||{};return(!b[1]||a.nodeName.toLowerCase()===b[1])&&(!b[2]||(c.id||{}).value===b[2])&&(!b[3]||b[3].test((c["class"]||{}).value))},I=function(a){return f.event.special.hover?a:a.replace(B,"mouseenter$1 mouseleave$1")};
f.event={add:function(a,c,d,e,g){var h,i,j,k,l,m,n,o,p,q,r,s;if(!(a.nodeType===3||a.nodeType===8||!c||!d||!(h=f._data(a)))){d.handler&&(p=d,d=p.handler),d.guid||(d.guid=f.guid++),j=h.events,j||(h.events=j={}),i=h.handle,i||(h.handle=i=function(a){return typeof f!="undefined"&&(!a||f.event.triggered!==a.type)?f.event.dispatch.apply(i.elem,arguments):b},i.elem=a),c=f.trim(I(c)).split(" ");for(k=0;k<c.length;k++){l=A.exec(c[k])||[],m=l[1],n=(l[2]||"").split(".").sort(),s=f.event.special[m]||{},m=(g?s.delegateType:s.bindType)||m,s=f.event.special[m]||{},o=f.extend({type:m,origType:l[1],data:e,handler:d,guid:d.guid,selector:g,quick:G(g),namespace:n.join(".")},p),r=j[m];if(!r){r=j[m]=[],r.delegateCount=0;if(!s.setup||s.setup.call(a,e,n,i)===!1)a.addEventListener?a.addEventListener(m,i,!1):a.attachEvent&&a.attachEvent("on"+m,i)}s.add&&(s.add.call(a,o),o.handler.guid||(o.handler.guid=d.guid)),g?r.splice(r.delegateCount++,0,o):r.push(o),f.event.global[m]=!0}a=null}},global:{},remove:function(a,b,c,d,e){var g=f.hasData(a)&&f._data(a),h,i,j,k,l,m,n,o,p,q,r,s;if(!!g&&!!(o=g.events)){b=f.trim(I(b||"")).split(" ");for(h=0;h<b.length;h++){i=A.exec(b[h])||[],j=k=i[1],l=i[2];if(!j){for(j in o)f.event.remove(a,j+b[h],c,d,!0);continue}p=f.event.special[j]||{},j=(d?p.delegateType:p.bindType)||j,r=o[j]||[],m=r.length,l=l?new RegExp("(^|\\.)"+l.split(".").sort().join("\\.(?:.*\\.)?")+"(\\.|$)"):null;for(n=0;n<r.length;n++)s=r[n],(e||k===s.origType)&&(!c||c.guid===s.guid)&&(!l||l.test(s.namespace))&&(!d||d===s.selector||d==="**"&&s.selector)&&(r.splice(n--,1),s.selector&&r.delegateCount--,p.remove&&p.remove.call(a,s));r.length===0&&m!==r.length&&((!p.teardown||p.teardown.call(a,l)===!1)&&f.removeEvent(a,j,g.handle),delete o[j])}f.isEmptyObject(o)&&(q=g.handle,q&&(q.elem=null),f.removeData(a,["events","handle"],!0))}},customEvent:{getData:!0,setData:!0,changeData:!0},trigger:function(c,d,e,g){if(!e||e.nodeType!==3&&e.nodeType!==8){var h=c.type||c,i=[],j,k,l,m,n,o,p,q,r,s;if(E.test(h+f.event.triggered))return;h.indexOf("!")>=0&&(h=h.slice(0,-1),k=!0),h.indexOf(".")>=0&&(i=h.split("."),h=i.shift(),i.sort());if((!e||f.event.customEvent[h])&&!f.event.global[h])return;c=typeof c=="object"?c[f.expando]?c:new f.Event(h,c):new f.Event(h),c.type=h,c.isTrigger=!0,c.exclusive=k,c.namespace=i.join("."),c.namespace_re=c.namespace?new RegExp("(^|\\.)"+i.join("\\.(?:.*\\.)?")+"(\\.|$)"):null,o=h.indexOf(":")<0?"on"+h:"";if(!e){j=f.cache;for(l in j)j[l].events&&j[l].events[h]&&f.event.trigger(c,d,j[l].handle.elem,!0);return}c.result=b,c.target||(c.target=e),d=d!=null?f.makeArray(d):[],d.unshift(c),p=f.event.special[h]||{};if(p.trigger&&p.trigger.apply(e,d)===!1)return;r=[[e,p.bindType||h]];if(!g&&!p.noBubble&&!f.isWindow(e)){s=p.delegateType||h,m=E.test(s+h)?e:e.parentNode,n=null;for(;m;m=m.parentNode)r.push([m,s]),n=m;n&&n===e.ownerDocument&&r.push([n.defaultView||n.parentWindow||a,s])}for(l=0;l<r.length&&!c.isPropagationStopped();l++)m=r[l][0],c.type=r[l][1],q=(f._data(m,"events")||{})[c.type]&&f._data(m,"handle"),q&&q.apply(m,d),q=o&&m[o],q&&f.acceptData(m)&&q.apply(m,d)===!1&&c.preventDefault();c.type=h,!g&&!c.isDefaultPrevented()&&(!p._default||p._default.apply(e.ownerDocument,d)===!1)&&(h!=="click"||!f.nodeName(e,"a"))&&f.acceptData(e)&&o&&e[h]&&(h!=="focus"&&h!=="blur"||c.target.offsetWidth!==0)&&!f.isWindow(e)&&(n=e[o],n&&(e[o]=null),f.event.triggered=h,e[h](),f.event.triggered=b,n&&(e[o]=n));return c.result}},dispatch:function(c){c=f.event.fix(c||a.event);var d=(f._data(this,"events")||{})[c.type]||[],e=d.delegateCount,g=[].slice.call(arguments,0),h=!c.exclusive&&!c.namespace,i=[],j,k,l,m,n,o,p,q,r,s,t;g[0]=c,c.delegateTarget=this;if(e&&!c.target.disabled&&(!c.button||c.type!=="click")){m=f(this),m.context=this.ownerDocument||this;for(l=c.target;l!=this;l=l.parentNode||this){o={},q=[],m[0]=l;for(j=0;j<e;j++)r=d[j],s=r.selector,o[s]===b&&(o[s]=r.quick?H(l,r.quick):m.is(s)),o[s]&&q.push(r);q.length&&i.push({elem:l,matches:q})}}d.length>e&&i.push({elem:this,matches:d.slice(e)});for(j=0;j<i.length&&!c.isPropagationStopped();j++){p=i[j],c.currentTarget=p.elem;for(k=0;k<p.matches.length&&!c.isImmediatePropagationStopped();k++){r=p.matches[k];if(h||!c.namespace&&!r.namespace||c.namespace_re&&c.namespace_re.test(r.namespace))c.data=r.data,c.handleObj=r,n=((f.event.special[r.origType]||{}).handle||r.handler).apply(p.elem,g),n!==b&&(c.result=n,n===!1&&(c.preventDefault(),c.stopPropagation()))}}return c.result},props:"attrChange attrName relatedNode srcElement altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(a,b){a.which==null&&(a.which=b.charCode!=null?b.charCode:b.keyCode);return a}},mouseHooks:{props:"button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(a,d){var e,f,g,h=d.button,i=d.fromElement;a.pageX==null&&d.clientX!=null&&(e=a.target.ownerDocument||c,f=e.documentElement,g=e.body,a.pageX=d.clientX+(f&&f.scrollLeft||g&&g.scrollLeft||0)-(f&&f.clientLeft||g&&g.clientLeft||0),a.pageY=d.clientY+(f&&f.scrollTop||g&&g.scrollTop||0)-(f&&f.clientTop||g&&g.clientTop||0)),!a.relatedTarget&&i&&(a.relatedTarget=i===a.target?d.toElement:i),!a.which&&h!==b&&(a.which=h&1?1:h&2?3:h&4?2:0);return a}},fix:function(a){if(a[f.expando])return a;var d,e,g=a,h=f.event.fixHooks[a.type]||{},i=h.props?this.props.concat(h.props):this.props;a=f.Event(g);for(d=i.length;d;)e=i[--d],a[e]=g[e];a.target||(a.target=g.srcElement||c),a.target.nodeType===3&&(a.target=a.target.parentNode),a.metaKey===b&&(a.metaKey=a.ctrlKey);return h.filter?h.filter(a,g):a},special:{ready:{setup:f.bindReady},load:{noBubble:!0},focus:{delegateType:"focusin"},blur:{delegateType:"focusout"},beforeunload:{setup:function(a,b,c){f.isWindow(this)&&(this.onbeforeunload=c)},teardown:function(a,b){this.onbeforeunload===b&&(this.onbeforeunload=null)}}},simulate:function(a,b,c,d){var e=f.extend(new f.Event,c,{type:a,isSimulated:!0,originalEvent:{}});d?f.event.trigger(e,null,b):f.event.dispatch.call(b,e),e.isDefaultPrevented()&&c.preventDefault()}},f.event.handle=f.event.dispatch,f.removeEvent=c.removeEventListener?function(a,b,c){a.removeEventListener&&a.removeEventListener(b,c,!1)}:function(a,b,c){a.detachEvent&&a.detachEvent("on"+b,c)},f.Event=function(a,b){if(!(this instanceof f.Event))return new f.Event(a,b);a&&a.type?(this.originalEvent=a,this.type=a.type,this.isDefaultPrevented=a.defaultPrevented||a.returnValue===!1||a.getPreventDefault&&a.getPreventDefault()?K:J):this.type=a,b&&f.extend(this,b),this.timeStamp=a&&a.timeStamp||f.now(),this[f.expando]=!0},f.Event.prototype={preventDefault:function(){this.isDefaultPrevented=K;var a=this.originalEvent;!a||(a.preventDefault?a.preventDefault():a.returnValue=!1)},stopPropagation:function(){this.isPropagationStopped=K;var a=this.originalEvent;!a||(a.stopPropagation&&a.stopPropagation(),a.cancelBubble=!0)},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=K,this.stopPropagation()},isDefaultPrevented:J,isPropagationStopped:J,isImmediatePropagationStopped:J},f.each({mouseenter:"mouseover",mouseleave:"mouseout"},function(a,b){f.event.special[a]={delegateType:b,bindType:b,handle:function(a){var c=this,d=a.relatedTarget,e=a.handleObj,g=e.selector,h;if(!d||d!==c&&!f.contains(c,d))a.type=e.origType,h=e.handler.apply(this,arguments),a.type=b;return h}}}),f.support.submitBubbles||(f.event.special.submit={setup:function(){if(f.nodeName(this,"form"))return!1;f.event.add(this,"click._submit keypress._submit",function(a){var c=a.target,d=f.nodeName(c,"input")||f.nodeName(c,"button")?c.form:b;d&&!d._submit_attached&&(f.event.add(d,"submit._submit",function(a){this.parentNode&&!a.isTrigger&&f.event.simulate("submit",this.parentNode,a,!0)}),d._submit_attached=!0)})},teardown:function(){if(f.nodeName(this,"form"))return!1;f.event.remove(this,"._submit")}}),f.support.changeBubbles||(f.event.special.change={setup:function(){if(z.test(this.nodeName)){if(this.type==="checkbox"||this.type==="radio")f.event.add(this,"propertychange._change",function(a){a.originalEvent.propertyName==="checked"&&(this._just_changed=!0)}),f.event.add(this,"click._change",function(a){this._just_changed&&!a.isTrigger&&(this._just_changed=!1,f.event.simulate("change",this,a,!0))});return!1}f.event.add(this,"beforeactivate._change",function(a){var b=a.target;z.test(b.nodeName)&&!b._change_attached&&(f.event.add(b,"change._change",function(a){this.parentNode&&!a.isSimulated&&!a.isTrigger&&f.event.simulate("change",this.parentNode,a,!0)}),b._change_attached=!0)})},handle:function(a){var b=a.target;if(this!==b||a.isSimulated||a.isTrigger||b.type!=="radio"&&b.type!=="checkbox")return a.handleObj.handler.apply(this,arguments)},teardown:function(){f.event.remove(this,"._change");return z.test(this.nodeName)}}),f.support.focusinBubbles||f.each({focus:"focusin",blur:"focusout"},function(a,b){var d=0,e=function(a){f.event.simulate(b,a.target,f.event.fix(a),!0)};f.event.special[b]={setup:function(){d++===0&&c.addEventListener(a,e,!0)},teardown:function(){--d===0&&c.removeEventListener(a,e,!0)}}}),f.fn.extend({on:function(a,c,d,e,g){var h,i;if(typeof a=="object"){typeof c!="string"&&(d=c,c=b);for(i in a)this.on(i,c,d,a[i],g);return this}d==null&&e==null?(e=c,d=c=b):e==null&&(typeof c=="string"?(e=d,d=b):(e=d,d=c,c=b));if(e===!1)e=J;else if(!e)return this;g===1&&(h=e,e=function(a){f().off(a);return h.apply(this,arguments)},e.guid=h.guid||(h.guid=f.guid++));return this.each(function(){f.event.add(this,a,e,d,c)})},one:function(a,b,c,d){return this.on.call(this,a,b,c,d,1)},off:function(a,c,d){if(a&&a.preventDefault&&a.handleObj){var e=a.handleObj;f(a.delegateTarget).off(e.namespace?e.type+"."+e.namespace:e.type,e.selector,e.handler);return this}if(typeof a=="object"){for(var g in a)this.off(g,c,a[g]);return this}if(c===!1||typeof c=="function")d=c,c=b;d===!1&&(d=J);return this.each(function(){f.event.remove(this,a,d,c)})},bind:function(a,b,c){return this.on(a,null,b,c)},unbind:function(a,b){return this.off(a,null,b)},live:function(a,b,c){f(this.context).on(a,this.selector,b,c);return this},die:function(a,b){f(this.context).off(a,this.selector||"**",b);return this},delegate:function(a,b,c,d){return this.on(b,a,c,d)},undelegate:function(a,b,c){return arguments.length==1?this.off(a,"**"):this.off(b,a,c)},trigger:function(a,b){return this.each(function(){f.event.trigger(a,b,this)})},triggerHandler:function(a,b){if(this[0])return f.event.trigger(a,b,this[0],!0)},toggle:function(a){var b=arguments,c=a.guid||f.guid++,d=0,e=function(c){var e=(f._data(this,"lastToggle"+a.guid)||0)%d;f._data(this,"lastToggle"+a.guid,e+1),c.preventDefault();return b[e].apply(this,arguments)||!1};e.guid=c;while(d<b.length)b[d++].guid=c;return this.click(e)},hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)}}),f.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "),function(a,b){f.fn[b]=function(a,c){c==null&&(c=a,a=null);return arguments.length>0?this.on(b,null,a,c):this.trigger(b)},f.attrFn&&(f.attrFn[b]=!0),C.test(b)&&(f.event.fixHooks[b]=f.event.keyHooks),D.test(b)&&(f.event.fixHooks[b]=f.event.mouseHooks)}),function(){function x(a,b,c,e,f,g){for(var h=0,i=e.length;h<i;h++){var j=e[h];if(j){var k=!1;j=j[a];while(j){if(j[d]===c){k=e[j.sizset];break}if(j.nodeType===1){g||(j[d]=c,j.sizset=h);if(typeof b!="string"){if(j===b){k=!0;break}}else if(m.filter(b,[j]).length>0){k=j;break}}j=j[a]}e[h]=k}}}function w(a,b,c,e,f,g){for(var h=0,i=e.length;h<i;h++){var j=e[h];if(j){var k=!1;j=j[a];while(j){if(j[d]===c){k=e[j.sizset];break}j.nodeType===1&&!g&&(j[d]=c,j.sizset=h);if(j.nodeName.toLowerCase()===b){k=j;break}j=j[a]}e[h]=k}}}var a=/((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,d="sizcache"+(Math.random()+"").replace(".",""),e=0,g=Object.prototype.toString,h=!1,i=!0,j=/\\/g,k=/\r\n/g,l=/\W/;[0,0].sort(function(){i=!1;return 0});var m=function(b,d,e,f){e=e||[],d=d||c;var h=d;if(d.nodeType!==1&&d.nodeType!==9)return[];if(!b||typeof b!="string")return e;var i,j,k,l,n,q,r,t,u=!0,v=m.isXML(d),w=[],x=b;do{a.exec(""),i=a.exec(x);if(i){x=i[3],w.push(i[1]);if(i[2]){l=i[3];break}}}while(i);if(w.length>1&&p.exec(b))if(w.length===2&&o.relative[w[0]])j=y(w[0]+w[1],d,f);else{j=o.relative[w[0]]?[d]:m(w.shift(),d);while(w.length)b=w.shift(),o.relative[b]&&(b+=w.shift()),j=y(b,j,f)}else{!f&&w.length>1&&d.nodeType===9&&!v&&o.match.ID.test(w[0])&&!o.match.ID.test(w[w.length-1])&&(n=m.find(w.shift(),d,v),d=n.expr?m.filter(n.expr,n.set)[0]:n.set[0]);if(d){n=f?{expr:w.pop(),set:s(f)}:m.find(w.pop(),w.length===1&&(w[0]==="~"||w[0]==="+")&&d.parentNode?d.parentNode:d,v),j=n.expr?m.filter(n.expr,n.set):n.set,w.length>0?k=s(j):u=!1;while(w.length)q=w.pop(),r=q,o.relative[q]?r=w.pop():q="",r==null&&(r=d),o.relative[q](k,r,v)}else k=w=[]}k||(k=j),k||m.error(q||b);if(g.call(k)==="[object Array]")if(!u)e.push.apply(e,k);else if(d&&d.nodeType===1)for(t=0;k[t]!=null;t++)k[t]&&(k[t]===!0||k[t].nodeType===1&&m.contains(d,k[t]))&&e.push(j[t]);else for(t=0;k[t]!=null;t++)k[t]&&k[t].nodeType===1&&e.push(j[t]);else s(k,e);l&&(m(l,h,e,f),m.uniqueSort(e));return e};m.uniqueSort=function(a){if(u){h=i,a.sort(u);if(h)for(var b=1;b<a.length;b++)a[b]===a[b-1]&&a.splice(b--,1)}return a},m.matches=function(a,b){return m(a,null,null,b)},m.matchesSelector=function(a,b){return m(b,null,null,[a]).length>0},m.find=function(a,b,c){var d,e,f,g,h,i;if(!a)return[];for(e=0,f=o.order.length;e<f;e++){h=o.order[e];if(g=o.leftMatch[h].exec(a)){i=g[1],g.splice(1,1);if(i.substr(i.length-1)!=="\\"){g[1]=(g[1]||"").replace(j,""),d=o.find[h](g,b,c);if(d!=null){a=a.replace(o.match[h],"");break}}}}d||(d=typeof b.getElementsByTagName!="undefined"?b.getElementsByTagName("*"):[]);return{set:d,expr:a}},m.filter=function(a,c,d,e){var f,g,h,i,j,k,l,n,p,q=a,r=[],s=c,t=c&&c[0]&&m.isXML(c[0]);while(a&&c.length){for(h in o.filter)if((f=o.leftMatch[h].exec(a))!=null&&f[2]){k=o.filter[h],l=f[1],g=!1,f.splice(1,1);if(l.substr(l.length-1)==="\\")continue;s===r&&(r=[]);if(o.preFilter[h]){f=o.preFilter[h](f,s,d,r,e,t);if(!f)g=i=!0;else if(f===!0)continue}if(f)for(n=0;(j=s[n])!=null;n++)j&&(i=k(j,f,n,s),p=e^i,d&&i!=null?p?g=!0:s[n]=!1:p&&(r.push(j),g=!0));if(i!==b){d||(s=r),a=a.replace(o.match[h],"");if(!g)return[];break}}if(a===q)if(g==null)m.error(a);else break;q=a}return s},m.error=function(a){throw new Error("Syntax error, unrecognized expression: "+a)};var n=m.getText=function(a){var b,c,d=a.nodeType,e="";if(d){if(d===1||d===9){if(typeof a.textContent=="string")return a.textContent;if(typeof a.innerText=="string")return a.innerText.replace(k,"");for(a=a.firstChild;a;a=a.nextSibling)e+=n(a)}else if(d===3||d===4)return a.nodeValue}else for(b=0;c=a[b];b++)c.nodeType!==8&&(e+=n(c));return e},o=m.selectors={order:["ID","NAME","TAG"],match:{ID:/#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,CLASS:/\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,NAME:/\[name=['"]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['"]*\]/,ATTR:/\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(?:(['"])(.*?)\3|(#?(?:[\w\u00c0-\uFFFF\-]|\\.)*)|)|)\s*\]/,TAG:/^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)/,CHILD:/:(only|nth|last|first)-child(?:\(\s*(even|odd|(?:[+\-]?\d+|(?:[+\-]?\d*)?n\s*(?:[+\-]\s*\d+)?))\s*\))?/,POS:/:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^\-]|$)/,PSEUDO:/:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/},leftMatch:{},attrMap:{"class":"className","for":"htmlFor"},attrHandle:{href:function(a){return a.getAttribute("href")},type:function(a){return a.getAttribute("type")}},relative:{"+":function(a,b){var c=typeof b=="string",d=c&&!l.test(b),e=c&&!d;d&&(b=b.toLowerCase());for(var f=0,g=a.length,h;f<g;f++)if(h=a[f]){while((h=h.previousSibling)&&h.nodeType!==1);a[f]=e||h&&h.nodeName.toLowerCase()===b?h||!1:h===b}e&&m.filter(b,a,!0)},">":function(a,b){var c,d=typeof b=="string",e=0,f=a.length;if(d&&!l.test(b)){b=b.toLowerCase();for(;e<f;e++){c=a[e];if(c){var g=c.parentNode;a[e]=g.nodeName.toLowerCase()===b?g:!1}}}else{for(;e<f;e++)c=a[e],c&&(a[e]=d?c.parentNode:c.parentNode===b);d&&m.filter(b,a,!0)}},"":function(a,b,c){var d,f=e++,g=x;typeof b=="string"&&!l.test(b)&&(b=b.toLowerCase(),d=b,g=w),g("parentNode",b,f,a,d,c)},"~":function(a,b,c){var d,f=e++,g=x;typeof b=="string"&&!l.test(b)&&(b=b.toLowerCase(),d=b,g=w),g("previousSibling",b,f,a,d,c)}},find:{ID:function(a,b,c){if(typeof b.getElementById!="undefined"&&!c){var d=b.getElementById(a[1]);return d&&d.parentNode?[d]:[]}},NAME:function(a,b){if(typeof b.getElementsByName!="undefined"){var c=[],d=b.getElementsByName(a[1]);for(var e=0,f=d.length;e<f;e++)d[e].getAttribute("name")===a[1]&&c.push(d[e]);return c.length===0?null:c}},TAG:function(a,b){if(typeof b.getElementsByTagName!="undefined")return b.getElementsByTagName(a[1])}},preFilter:{CLASS:function(a,b,c,d,e,f){a=" "+a[1].replace(j,"")+" ";if(f)return a;for(var g=0,h;(h=b[g])!=null;g++)h&&(e^(h.className&&(" "+h.className+" ").replace(/[\t\n\r]/g," ").indexOf(a)>=0)?c||d.push(h):c&&(b[g]=!1));return!1},ID:function(a){return a[1].replace(j,"")},TAG:function(a,b){return a[1].replace(j,"").toLowerCase()},CHILD:function(a){if(a[1]==="nth"){a[2]||m.error(a[0]),a[2]=a[2].replace(/^\+|\s*/g,"");var b=/(-?)(\d*)(?:n([+\-]?\d*))?/.exec(a[2]==="even"&&"2n"||a[2]==="odd"&&"2n+1"||!/\D/.test(a[2])&&"0n+"+a[2]||a[2]);a[2]=b[1]+(b[2]||1)-0,a[3]=b[3]-0}else a[2]&&m.error(a[0]);a[0]=e++;return a},ATTR:function(a,b,c,d,e,f){var g=a[1]=a[1].replace(j,"");!f&&o.attrMap[g]&&(a[1]=o.attrMap[g]),a[4]=(a[4]||a[5]||"").replace(j,""),a[2]==="~="&&(a[4]=" "+a[4]+" ");return a},PSEUDO:function(b,c,d,e,f){if(b[1]==="not")if((a.exec(b[3])||"").length>1||/^\w/.test(b[3]))b[3]=m(b[3],null,null,c);else{var g=m.filter(b[3],c,d,!0^f);d||e.push.apply(e,g);return!1}else if(o.match.POS.test(b[0])||o.match.CHILD.test(b[0]))return!0;return b},POS:function(a){a.unshift(!0);return a}},filters:{enabled:function(a){return a.disabled===!1&&a.type!=="hidden"},disabled:function(a){return a.disabled===!0},checked:function(a){return a.checked===!0},selected:function(a){a.parentNode&&a.parentNode.selectedIndex;return a.selected===!0},parent:function(a){return!!a.firstChild},empty:function(a){return!a.firstChild},has:function(a,b,c){return!!m(c[3],a).length},header:function(a){return/h\d/i.test(a.nodeName)},text:function(a){var b=a.getAttribute("type"),c=a.type;return a.nodeName.toLowerCase()==="input"&&"text"===c&&(b===c||b===null)},radio:function(a){return a.nodeName.toLowerCase()==="input"&&"radio"===a.type},checkbox:function(a){return a.nodeName.toLowerCase()==="input"&&"checkbox"===a.type},file:function(a){return a.nodeName.toLowerCase()==="input"&&"file"===a.type},password:function(a){return a.nodeName.toLowerCase()==="input"&&"password"===a.type},submit:function(a){var b=a.nodeName.toLowerCase();return(b==="input"||b==="button")&&"submit"===a.type},image:function(a){return a.nodeName.toLowerCase()==="input"&&"image"===a.type},reset:function(a){var b=a.nodeName.toLowerCase();return(b==="input"||b==="button")&&"reset"===a.type},button:function(a){var b=a.nodeName.toLowerCase();return b==="input"&&"button"===a.type||b==="button"},input:function(a){return/input|select|textarea|button/i.test(a.nodeName)},focus:function(a){return a===a.ownerDocument.activeElement}},setFilters:{first:function(a,b){return b===0},last:function(a,b,c,d){return b===d.length-1},even:function(a,b){return b%2===0},odd:function(a,b){return b%2===1},lt:function(a,b,c){return b<c[3]-0},gt:function(a,b,c){return b>c[3]-0},nth:function(a,b,c){return c[3]-0===b},eq:function(a,b,c){return c[3]-0===b}},filter:{PSEUDO:function(a,b,c,d){var e=b[1],f=o.filters[e];if(f)return f(a,c,b,d);if(e==="contains")return(a.textContent||a.innerText||n([a])||"").indexOf(b[3])>=0;if(e==="not"){var g=b[3];for(var h=0,i=g.length;h<i;h++)if(g[h]===a)return!1;return!0}m.error(e)},CHILD:function(a,b){var c,e,f,g,h,i,j,k=b[1],l=a;switch(k){case"only":case"first":while(l=l.previousSibling)if(l.nodeType===1)return!1;if(k==="first")return!0;l=a;case"last":while(l=l.nextSibling)if(l.nodeType===1)return!1;return!0;case"nth":c=b[2],e=b[3];if(c===1&&e===0)return!0;f=b[0],g=a.parentNode;if(g&&(g[d]!==f||!a.nodeIndex)){i=0;for(l=g.firstChild;l;l=l.nextSibling)l.nodeType===1&&(l.nodeIndex=++i);g[d]=f}j=a.nodeIndex-e;return c===0?j===0:j%c===0&&j/c>=0}},ID:function(a,b){return a.nodeType===1&&a.getAttribute("id")===b},TAG:function(a,b){return b==="*"&&a.nodeType===1||!!a.nodeName&&a.nodeName.toLowerCase()===b},CLASS:function(a,b){return(" "+(a.className||a.getAttribute("class"))+" ").indexOf(b)>-1},ATTR:function(a,b){var c=b[1],d=m.attr?m.attr(a,c):o.attrHandle[c]?o.attrHandle[c](a):a[c]!=null?a[c]:a.getAttribute(c),e=d+"",f=b[2],g=b[4];return d==null?f==="!=":!f&&m.attr?d!=null:f==="="?e===g:f==="*="?e.indexOf(g)>=0:f==="~="?(" "+e+" ").indexOf(g)>=0:g?f==="!="?e!==g:f==="^="?e.indexOf(g)===0:f==="$="?e.substr(e.length-g.length)===g:f==="|="?e===g||e.substr(0,g.length+1)===g+"-":!1:e&&d!==!1},POS:function(a,b,c,d){var e=b[2],f=o.setFilters[e];if(f)return f(a,c,b,d)}}},p=o.match.POS,q=function(a,b){return"\\"+(b-0+1)};for(var r in o.match)o.match[r]=new RegExp(o.match[r].source+/(?![^\[]*\])(?![^\(]*\))/.source),o.leftMatch[r]=new RegExp(/(^(?:.|\r|\n)*?)/.source+o.match[r].source.replace(/\\(\d+)/g,q));var s=function(a,b){a=Array.prototype.slice.call(a,0);if(b){b.push.apply(b,a);return b}return a};try{Array.prototype.slice.call(c.documentElement.childNodes,0)[0].nodeType}catch(t){s=function(a,b){var c=0,d=b||[];if(g.call(a)==="[object Array]")Array.prototype.push.apply(d,a);else if(typeof a.length=="number")for(var e=a.length;c<e;c++)d.push(a[c]);else for(;a[c];c++)d.push(a[c]);return d}}var u,v;c.documentElement.compareDocumentPosition?u=function(a,b){if(a===b){h=!0;return 0}if(!a.compareDocumentPosition||!b.compareDocumentPosition)return a.compareDocumentPosition?-1:1;return a.compareDocumentPosition(b)&4?-1:1}:(u=function(a,b){if(a===b){h=!0;return 0}if(a.sourceIndex&&b.sourceIndex)return a.sourceIndex-b.sourceIndex;var c,d,e=[],f=[],g=a.parentNode,i=b.parentNode,j=g;if(g===i)return v(a,b);if(!g)return-1;if(!i)return 1;while(j)e.unshift(j),j=j.parentNode;j=i;while(j)f.unshift(j),j=j.parentNode;c=e.length,d=f.length;for(var k=0;k<c&&k<d;k++)if(e[k]!==f[k])return v(e[k],f[k]);return k===c?v(a,f[k],-1):v(e[k],b,1)},v=function(a,b,c){if(a===b)return c;var d=a.nextSibling;while(d){if(d===b)return-1;d=d.nextSibling}return 1}),function(){var a=c.createElement("div"),d="script"+(new Date).getTime(),e=c.documentElement;a.innerHTML="<a name='"+d+"'/>",e.insertBefore(a,e.firstChild),c.getElementById(d)&&(o.find.ID=function(a,c,d){if(typeof c.getElementById!="undefined"&&!d){var e=c.getElementById(a[1]);return e?e.id===a[1]||typeof e.getAttributeNode!="undefined"&&e.getAttributeNode("id").nodeValue===a[1]?[e]:b:[]}},o.filter.ID=function(a,b){var c=typeof a.getAttributeNode!="undefined"&&a.getAttributeNode("id");return a.nodeType===1&&c&&c.nodeValue===b}),e.removeChild(a),e=a=null}(),function(){var a=c.createElement("div");a.appendChild(c.createComment("")),a.getElementsByTagName("*").length>0&&(o.find.TAG=function(a,b){var c=b.getElementsByTagName(a[1]);if(a[1]==="*"){var d=[];for(var e=0;c[e];e++)c[e].nodeType===1&&d.push(c[e]);c=d}return c}),a.innerHTML="<a href='#'></a>",a.firstChild&&typeof a.firstChild.getAttribute!="undefined"&&a.firstChild.getAttribute("href")!=="#"&&(o.attrHandle.href=function(a){return a.getAttribute("href",2)}),a=null}(),c.querySelectorAll&&function(){var a=m,b=c.createElement("div"),d="__sizzle__";b.innerHTML="<p class='TEST'></p>";if(!b.querySelectorAll||b.querySelectorAll(".TEST").length!==0){m=function(b,e,f,g){e=e||c;if(!g&&!m.isXML(e)){var h=/^(\w+$)|^\.([\w\-]+$)|^#([\w\-]+$)/.exec(b);if(h&&(e.nodeType===1||e.nodeType===9)){if(h[1])return s(e.getElementsByTagName(b),f);if(h[2]&&o.find.CLASS&&e.getElementsByClassName)return s(e.getElementsByClassName(h[2]),f)}if(e.nodeType===9){if(b==="body"&&e.body)return s([e.body],f);if(h&&h[3]){var i=e.getElementById(h[3]);if(!i||!i.parentNode)return s([],f);if(i.id===h[3])return s([i],f)}try{return s(e.querySelectorAll(b),f)}catch(j){}}else if(e.nodeType===1&&e.nodeName.toLowerCase()!=="object"){var k=e,l=e.getAttribute("id"),n=l||d,p=e.parentNode,q=/^\s*[+~]/.test(b);l?n=n.replace(/'/g,"\\$&"):e.setAttribute("id",n),q&&p&&(e=e.parentNode);try{if(!q||p)return s(e.querySelectorAll("[id='"+n+"'] "+b),f)}catch(r){}finally{l||k.removeAttribute("id")}}}return a(b,e,f,g)};for(var e in a)m[e]=a[e];b=null}}(),function(){var a=c.documentElement,b=a.matchesSelector||a.mozMatchesSelector||a.webkitMatchesSelector||a.msMatchesSelector;if(b){var d=!b.call(c.createElement("div"),"div"),e=!1;try{b.call(c.documentElement,"[test!='']:sizzle")}catch(f){e=!0}m.matchesSelector=function(a,c){c=c.replace(/\=\s*([^'"\]]*)\s*\]/g,"='$1']");if(!m.isXML(a))try{if(e||!o.match.PSEUDO.test(c)&&!/!=/.test(c)){var f=b.call(a,c);if(f||!d||a.document&&a.document.nodeType!==11)return f}}catch(g){}return m(c,null,null,[a]).length>0}}}(),function(){var a=c.createElement("div");a.innerHTML="<div class='test e'></div><div class='test'></div>";if(!!a.getElementsByClassName&&a.getElementsByClassName("e").length!==0){a.lastChild.className="e";if(a.getElementsByClassName("e").length===1)return;o.order.splice(1,0,"CLASS"),o.find.CLASS=function(a,b,c){if(typeof b.getElementsByClassName!="undefined"&&!c)return b.getElementsByClassName(a[1])},a=null}}(),c.documentElement.contains?m.contains=function(a,b){return a!==b&&(a.contains?a.contains(b):!0)}:c.documentElement.compareDocumentPosition?m.contains=function(a,b){return!!(a.compareDocumentPosition(b)&16)}:m.contains=function(){return!1},m.isXML=function(a){var b=(a?a.ownerDocument||a:0).documentElement;return b?b.nodeName!=="HTML":!1};var y=function(a,b,c){var d,e=[],f="",g=b.nodeType?[b]:b;while(d=o.match.PSEUDO.exec(a))f+=d[0],a=a.replace(o.match.PSEUDO,"");a=o.relative[a]?a+"*":a;for(var h=0,i=g.length;h<i;h++)m(a,g[h],e,c);return m.filter(f,e)};m.attr=f.attr,m.selectors.attrMap={},f.find=m,f.expr=m.selectors,f.expr[":"]=f.expr.filters,f.unique=m.uniqueSort,f.text=m.getText,f.isXMLDoc=m.isXML,f.contains=m.contains}();var L=/Until$/,M=/^(?:parents|prevUntil|prevAll)/,N=/,/,O=/^.[^:#\[\.,]*$/,P=Array.prototype.slice,Q=f.expr.match.POS,R={children:!0,contents:!0,next:!0,prev:!0};f.fn.extend({find:function(a){var b=this,c,d;if(typeof a!="string")return f(a).filter(function(){for(c=0,d=b.length;c<d;c++)if(f.contains(b[c],this))return!0});var e=this.pushStack("","find",a),g,h,i;for(c=0,d=this.length;c<d;c++){g=e.length,f.find(a,this[c],e);if(c>0)for(h=g;h<e.length;h++)for(i=0;i<g;i++)if(e[i]===e[h]){e.splice(h--,1);break}}return e},has:function(a){var b=f(a);return this.filter(function(){for(var a=0,c=b.length;a<c;a++)if(f.contains(this,b[a]))return!0})},not:function(a){return this.pushStack(T(this,a,!1),"not",a)},filter:function(a){return this.pushStack(T(this,a,!0),"filter",a)},is:function(a){return!!a&&(typeof a=="string"?Q.test(a)?f(a,this.context).index(this[0])>=0:f.filter(a,this).length>0:this.filter(a).length>0)},closest:function(a,b){var c=[],d,e,g=this[0];if(f.isArray(a)){var h=1;while(g&&g.ownerDocument&&g!==b){for(d=0;d<a.length;d++)f(g).is(a[d])&&c.push({selector:a[d],elem:g,level:h});g=g.parentNode,h++}return c}var i=Q.test(a)||typeof a!="string"?f(a,b||this.context):0;for(d=0,e=this.length;d<e;d++){g=this[d];while(g){if(i?i.index(g)>-1:f.find.matchesSelector(g,a)){c.push(g);break}g=g.parentNode;if(!g||!g.ownerDocument||g===b||g.nodeType===11)break}}c=c.length>1?f.unique(c):c;return this.pushStack(c,"closest",a)},index:function(a){if(!a)return this[0]&&this[0].parentNode?this.prevAll().length:-1;if(typeof a=="string")return f.inArray(this[0],f(a));return f.inArray(a.jquery?a[0]:a,this)},add:function(a,b){var c=typeof a=="string"?f(a,b):f.makeArray(a&&a.nodeType?[a]:a),d=f.merge(this.get(),c);return this.pushStack(S(c[0])||S(d[0])?d:f.unique(d))},andSelf:function(){return this.add(this.prevObject)}}),f.each({parent:function(a){var b=a.parentNode;return b&&b.nodeType!==11?b:null},parents:function(a){return f.dir(a,"parentNode")},parentsUntil:function(a,b,c){return f.dir(a,"parentNode",c)},next:function(a){return f.nth(a,2,"nextSibling")},prev:function(a){return f.nth(a,2,"previousSibling")},nextAll:function(a){return f.dir(a,"nextSibling")},prevAll:function(a){return f.dir(a,"previousSibling")},nextUntil:function(a,b,c){return f.dir(a,"nextSibling",c)},prevUntil:function(a,b,c){return f.dir(a,"previousSibling",c)},siblings:function(a){return f.sibling(a.parentNode.firstChild,a)},children:function(a){return f.sibling(a.firstChild)},contents:function(a){return f.nodeName(a,"iframe")?a.contentDocument||a.contentWindow.document:f.makeArray(a.childNodes)}},function(a,b){f.fn[a]=function(c,d){var e=f.map(this,b,c);L.test(a)||(d=c),d&&typeof d=="string"&&(e=f.filter(d,e)),e=this.length>1&&!R[a]?f.unique(e):e,(this.length>1||N.test(d))&&M.test(a)&&(e=e.reverse());return this.pushStack(e,a,P.call(arguments).join(","))}}),f.extend({filter:function(a,b,c){c&&(a=":not("+a+")");return b.length===1?f.find.matchesSelector(b[0],a)?[b[0]]:[]:f.find.matches(a,b)},dir:function(a,c,d){var e=[],g=a[c];while(g&&g.nodeType!==9&&(d===b||g.nodeType!==1||!f(g).is(d)))g.nodeType===1&&e.push(g),g=g[c];return e},nth:function(a,b,c,d){b=b||1;var e=0;for(;a;a=a[c])if(a.nodeType===1&&++e===b)break;return a},sibling:function(a,b){var c=[];for(;a;a=a.nextSibling)a.nodeType===1&&a!==b&&c.push(a);return c}});var V="abbr|article|aside|audio|canvas|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",W=/ jQuery\d+="(?:\d+|null)"/g,X=/^\s+/,Y=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,Z=/<([\w:]+)/,$=/<tbody/i,_=/<|&#?\w+;/,ba=/<(?:script|style)/i,bb=/<(?:script|object|embed|option|style)/i,bc=new RegExp("<(?:"+V+")","i"),bd=/checked\s*(?:[^=]|=\s*.checked.)/i,be=/\/(java|ecma)script/i,bf=/^\s*<!(?:\[CDATA\[|\-\-)/,bg={option:[1,"<select multiple='multiple'>","</select>"],legend:[1,"<fieldset>","</fieldset>"],thead:[1,"<table>","</table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],col:[2,"<table><tbody></tbody><colgroup>","</colgroup></table>"],area:[1,"<map>","</map>"],_default:[0,"",""]},bh=U(c);bg.optgroup=bg.option,bg.tbody=bg.tfoot=bg.colgroup=bg.caption=bg.thead,bg.th=bg.td,f.support.htmlSerialize||(bg._default=[1,"div<div>","</div>"]),f.fn.extend({text:function(a){if(f.isFunction(a))return this.each(function(b){var c=f(this);c.text(a.call(this,b,c.text()))});if(typeof a!="object"&&a!==b)return this.empty().append((this[0]&&this[0].ownerDocument||c).createTextNode(a));return f.text(this)},wrapAll:function(a){if(f.isFunction(a))return this.each(function(b){f(this).wrapAll(a.call(this,b))});if(this[0]){var b=f(a,this[0].ownerDocument).eq(0).clone(!0);this[0].parentNode&&b.insertBefore(this[0]),b.map(function(){var a=this;while(a.firstChild&&a.firstChild.nodeType===1)a=a.firstChild;return a}).append(this)}return this},wrapInner:function(a){if(f.isFunction(a))return this.each(function(b){f(this).wrapInner(a.call(this,b))});return this.each(function(){var b=f(this),c=b.contents();c.length?c.wrapAll(a):b.append(a)})},wrap:function(a){var b=f.isFunction(a);return this.each(function(c){f(this).wrapAll(b?a.call(this,c):a)})},unwrap:function(){return this.parent().each(function(){f.nodeName(this,"body")||f(this).replaceWith(this.childNodes)}).end()},append:function(){return this.domManip(arguments,!0,function(a){this.nodeType===1&&this.appendChild(a)})},prepend:function(){return this.domManip(arguments,!0,function(a){this.nodeType===1&&this.insertBefore(a,this.firstChild)})},before:function(){if(this[0]&&this[0].parentNode)return this.domManip(arguments,!1,function(a){this.parentNode.insertBefore(a,this)});if(arguments.length){var a=f.clean(arguments);a.push.apply(a,this.toArray());return this.pushStack(a,"before",arguments)}},after:function(){if(this[0]&&this[0].parentNode)return this.domManip(arguments,!1,function(a){this.parentNode.insertBefore(a,this.nextSibling)});if(arguments.length){var a=this.pushStack(this,"after",arguments);a.push.apply(a,f.clean(arguments));return a}},remove:function(a,b){for(var c=0,d;(d=this[c])!=null;c++)if(!a||f.filter(a,[d]).length)!b&&d.nodeType===1&&(f.cleanData(d.getElementsByTagName("*")),f.cleanData([d])),d.parentNode&&d.parentNode.removeChild(d);return this},empty:function()
{for(var a=0,b;(b=this[a])!=null;a++){b.nodeType===1&&f.cleanData(b.getElementsByTagName("*"));while(b.firstChild)b.removeChild(b.firstChild)}return this},clone:function(a,b){a=a==null?!1:a,b=b==null?a:b;return this.map(function(){return f.clone(this,a,b)})},html:function(a){if(a===b)return this[0]&&this[0].nodeType===1?this[0].innerHTML.replace(W,""):null;if(typeof a=="string"&&!ba.test(a)&&(f.support.leadingWhitespace||!X.test(a))&&!bg[(Z.exec(a)||["",""])[1].toLowerCase()]){a=a.replace(Y,"<$1></$2>");try{for(var c=0,d=this.length;c<d;c++)this[c].nodeType===1&&(f.cleanData(this[c].getElementsByTagName("*")),this[c].innerHTML=a)}catch(e){this.empty().append(a)}}else f.isFunction(a)?this.each(function(b){var c=f(this);c.html(a.call(this,b,c.html()))}):this.empty().append(a);return this},replaceWith:function(a){if(this[0]&&this[0].parentNode){if(f.isFunction(a))return this.each(function(b){var c=f(this),d=c.html();c.replaceWith(a.call(this,b,d))});typeof a!="string"&&(a=f(a).detach());return this.each(function(){var b=this.nextSibling,c=this.parentNode;f(this).remove(),b?f(b).before(a):f(c).append(a)})}return this.length?this.pushStack(f(f.isFunction(a)?a():a),"replaceWith",a):this},detach:function(a){return this.remove(a,!0)},domManip:function(a,c,d){var e,g,h,i,j=a[0],k=[];if(!f.support.checkClone&&arguments.length===3&&typeof j=="string"&&bd.test(j))return this.each(function(){f(this).domManip(a,c,d,!0)});if(f.isFunction(j))return this.each(function(e){var g=f(this);a[0]=j.call(this,e,c?g.html():b),g.domManip(a,c,d)});if(this[0]){i=j&&j.parentNode,f.support.parentNode&&i&&i.nodeType===11&&i.childNodes.length===this.length?e={fragment:i}:e=f.buildFragment(a,this,k),h=e.fragment,h.childNodes.length===1?g=h=h.firstChild:g=h.firstChild;if(g){c=c&&f.nodeName(g,"tr");for(var l=0,m=this.length,n=m-1;l<m;l++)d.call(c?bi(this[l],g):this[l],e.cacheable||m>1&&l<n?f.clone(h,!0,!0):h)}k.length&&f.each(k,bp)}return this}}),f.buildFragment=function(a,b,d){var e,g,h,i,j=a[0];b&&b[0]&&(i=b[0].ownerDocument||b[0]),i.createDocumentFragment||(i=c),a.length===1&&typeof j=="string"&&j.length<512&&i===c&&j.charAt(0)==="<"&&!bb.test(j)&&(f.support.checkClone||!bd.test(j))&&(f.support.html5Clone||!bc.test(j))&&(g=!0,h=f.fragments[j],h&&h!==1&&(e=h)),e||(e=i.createDocumentFragment(),f.clean(a,i,e,d)),g&&(f.fragments[j]=h?e:1);return{fragment:e,cacheable:g}},f.fragments={},f.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(a,b){f.fn[a]=function(c){var d=[],e=f(c),g=this.length===1&&this[0].parentNode;if(g&&g.nodeType===11&&g.childNodes.length===1&&e.length===1){e[b](this[0]);return this}for(var h=0,i=e.length;h<i;h++){var j=(h>0?this.clone(!0):this).get();f(e[h])[b](j),d=d.concat(j)}return this.pushStack(d,a,e.selector)}}),f.extend({clone:function(a,b,c){var d,e,g,h=f.support.html5Clone||!bc.test("<"+a.nodeName)?a.cloneNode(!0):bo(a);if((!f.support.noCloneEvent||!f.support.noCloneChecked)&&(a.nodeType===1||a.nodeType===11)&&!f.isXMLDoc(a)){bk(a,h),d=bl(a),e=bl(h);for(g=0;d[g];++g)e[g]&&bk(d[g],e[g])}if(b){bj(a,h);if(c){d=bl(a),e=bl(h);for(g=0;d[g];++g)bj(d[g],e[g])}}d=e=null;return h},clean:function(a,b,d,e){var g;b=b||c,typeof b.createElement=="undefined"&&(b=b.ownerDocument||b[0]&&b[0].ownerDocument||c);var h=[],i;for(var j=0,k;(k=a[j])!=null;j++){typeof k=="number"&&(k+="");if(!k)continue;if(typeof k=="string")if(!_.test(k))k=b.createTextNode(k);else{k=k.replace(Y,"<$1></$2>");var l=(Z.exec(k)||["",""])[1].toLowerCase(),m=bg[l]||bg._default,n=m[0],o=b.createElement("div");b===c?bh.appendChild(o):U(b).appendChild(o),o.innerHTML=m[1]+k+m[2];while(n--)o=o.lastChild;if(!f.support.tbody){var p=$.test(k),q=l==="table"&&!p?o.firstChild&&o.firstChild.childNodes:m[1]==="<table>"&&!p?o.childNodes:[];for(i=q.length-1;i>=0;--i)f.nodeName(q[i],"tbody")&&!q[i].childNodes.length&&q[i].parentNode.removeChild(q[i])}!f.support.leadingWhitespace&&X.test(k)&&o.insertBefore(b.createTextNode(X.exec(k)[0]),o.firstChild),k=o.childNodes}var r;if(!f.support.appendChecked)if(k[0]&&typeof (r=k.length)=="number")for(i=0;i<r;i++)bn(k[i]);else bn(k);k.nodeType?h.push(k):h=f.merge(h,k)}if(d){g=function(a){return!a.type||be.test(a.type)};for(j=0;h[j];j++)if(e&&f.nodeName(h[j],"script")&&(!h[j].type||h[j].type.toLowerCase()==="text/javascript"))e.push(h[j].parentNode?h[j].parentNode.removeChild(h[j]):h[j]);else{if(h[j].nodeType===1){var s=f.grep(h[j].getElementsByTagName("script"),g);h.splice.apply(h,[j+1,0].concat(s))}d.appendChild(h[j])}}return h},cleanData:function(a){var b,c,d=f.cache,e=f.event.special,g=f.support.deleteExpando;for(var h=0,i;(i=a[h])!=null;h++){if(i.nodeName&&f.noData[i.nodeName.toLowerCase()])continue;c=i[f.expando];if(c){b=d[c];if(b&&b.events){for(var j in b.events)e[j]?f.event.remove(i,j):f.removeEvent(i,j,b.handle);b.handle&&(b.handle.elem=null)}g?delete i[f.expando]:i.removeAttribute&&i.removeAttribute(f.expando),delete d[c]}}}});var bq=/alpha\([^)]*\)/i,br=/opacity=([^)]*)/,bs=/([A-Z]|^ms)/g,bt=/^-?\d+(?:px)?$/i,bu=/^-?\d/,bv=/^([\-+])=([\-+.\de]+)/,bw={position:"absolute",visibility:"hidden",display:"block"},bx=["Left","Right"],by=["Top","Bottom"],bz,bA,bB;f.fn.css=function(a,c){if(arguments.length===2&&c===b)return this;return f.access(this,a,c,!0,function(a,c,d){return d!==b?f.style(a,c,d):f.css(a,c)})},f.extend({cssHooks:{opacity:{get:function(a,b){if(b){var c=bz(a,"opacity","opacity");return c===""?"1":c}return a.style.opacity}}},cssNumber:{fillOpacity:!0,fontWeight:!0,lineHeight:!0,opacity:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":f.support.cssFloat?"cssFloat":"styleFloat"},style:function(a,c,d,e){if(!!a&&a.nodeType!==3&&a.nodeType!==8&&!!a.style){var g,h,i=f.camelCase(c),j=a.style,k=f.cssHooks[i];c=f.cssProps[i]||i;if(d===b){if(k&&"get"in k&&(g=k.get(a,!1,e))!==b)return g;return j[c]}h=typeof d,h==="string"&&(g=bv.exec(d))&&(d=+(g[1]+1)*+g[2]+parseFloat(f.css(a,c)),h="number");if(d==null||h==="number"&&isNaN(d))return;h==="number"&&!f.cssNumber[i]&&(d+="px");if(!k||!("set"in k)||(d=k.set(a,d))!==b)try{j[c]=d}catch(l){}}},css:function(a,c,d){var e,g;c=f.camelCase(c),g=f.cssHooks[c],c=f.cssProps[c]||c,c==="cssFloat"&&(c="float");if(g&&"get"in g&&(e=g.get(a,!0,d))!==b)return e;if(bz)return bz(a,c)},swap:function(a,b,c){var d={};for(var e in b)d[e]=a.style[e],a.style[e]=b[e];c.call(a);for(e in b)a.style[e]=d[e]}}),f.curCSS=f.css,f.each(["height","width"],function(a,b){f.cssHooks[b]={get:function(a,c,d){var e;if(c){if(a.offsetWidth!==0)return bC(a,b,d);f.swap(a,bw,function(){e=bC(a,b,d)});return e}},set:function(a,b){if(!bt.test(b))return b;b=parseFloat(b);if(b>=0)return b+"px"}}}),f.support.opacity||(f.cssHooks.opacity={get:function(a,b){return br.test((b&&a.currentStyle?a.currentStyle.filter:a.style.filter)||"")?parseFloat(RegExp.$1)/100+"":b?"1":""},set:function(a,b){var c=a.style,d=a.currentStyle,e=f.isNumeric(b)?"alpha(opacity="+b*100+")":"",g=d&&d.filter||c.filter||"";c.zoom=1;if(b>=1&&f.trim(g.replace(bq,""))===""){c.removeAttribute("filter");if(d&&!d.filter)return}c.filter=bq.test(g)?g.replace(bq,e):g+" "+e}}),f(function(){f.support.reliableMarginRight||(f.cssHooks.marginRight={get:function(a,b){var c;f.swap(a,{display:"inline-block"},function(){b?c=bz(a,"margin-right","marginRight"):c=a.style.marginRight});return c}})}),c.defaultView&&c.defaultView.getComputedStyle&&(bA=function(a,b){var c,d,e;b=b.replace(bs,"-$1").toLowerCase(),(d=a.ownerDocument.defaultView)&&(e=d.getComputedStyle(a,null))&&(c=e.getPropertyValue(b),c===""&&!f.contains(a.ownerDocument.documentElement,a)&&(c=f.style(a,b)));return c}),c.documentElement.currentStyle&&(bB=function(a,b){var c,d,e,f=a.currentStyle&&a.currentStyle[b],g=a.style;f===null&&g&&(e=g[b])&&(f=e),!bt.test(f)&&bu.test(f)&&(c=g.left,d=a.runtimeStyle&&a.runtimeStyle.left,d&&(a.runtimeStyle.left=a.currentStyle.left),g.left=b==="fontSize"?"1em":f||0,f=g.pixelLeft+"px",g.left=c,d&&(a.runtimeStyle.left=d));return f===""?"auto":f}),bz=bA||bB,f.expr&&f.expr.filters&&(f.expr.filters.hidden=function(a){var b=a.offsetWidth,c=a.offsetHeight;return b===0&&c===0||!f.support.reliableHiddenOffsets&&(a.style&&a.style.display||f.css(a,"display"))==="none"},f.expr.filters.visible=function(a){return!f.expr.filters.hidden(a)});var bD=/%20/g,bE=/\[\]$/,bF=/\r?\n/g,bG=/#.*$/,bH=/^(.*?):[ \t]*([^\r\n]*)\r?$/mg,bI=/^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,bJ=/^(?:about|app|app\-storage|.+\-extension|file|res|widget):$/,bK=/^(?:GET|HEAD)$/,bL=/^\/\//,bM=/\?/,bN=/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,bO=/^(?:select|textarea)/i,bP=/\s+/,bQ=/([?&])_=[^&]*/,bR=/^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+))?)?/,bS=f.fn.load,bT={},bU={},bV,bW,bX=["*/"]+["*"];try{bV=e.href}catch(bY){bV=c.createElement("a"),bV.href="",bV=bV.href}bW=bR.exec(bV.toLowerCase())||[],f.fn.extend({load:function(a,c,d){if(typeof a!="string"&&bS)return bS.apply(this,arguments);if(!this.length)return this;var e=a.indexOf(" ");if(e>=0){var g=a.slice(e,a.length);a=a.slice(0,e)}var h="GET";c&&(f.isFunction(c)?(d=c,c=b):typeof c=="object"&&(c=f.param(c,f.ajaxSettings.traditional),h="POST"));var i=this;f.ajax({url:a,type:h,dataType:"html",data:c,complete:function(a,b,c){c=a.responseText,a.isResolved()&&(a.done(function(a){c=a}),i.html(g?f("<div>").append(c.replace(bN,"")).find(g):c)),d&&i.each(d,[c,b,a])}});return this},serialize:function(){return f.param(this.serializeArray())},serializeArray:function(){return this.map(function(){return this.elements?f.makeArray(this.elements):this}).filter(function(){return this.name&&!this.disabled&&(this.checked||bO.test(this.nodeName)||bI.test(this.type))}).map(function(a,b){var c=f(this).val();return c==null?null:f.isArray(c)?f.map(c,function(a,c){return{name:b.name,value:a.replace(bF,"\r\n")}}):{name:b.name,value:c.replace(bF,"\r\n")}}).get()}}),f.each("ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split(" "),function(a,b){f.fn[b]=function(a){return this.on(b,a)}}),f.each(["get","post"],function(a,c){f[c]=function(a,d,e,g){f.isFunction(d)&&(g=g||e,e=d,d=b);return f.ajax({type:c,url:a,data:d,success:e,dataType:g})}}),f.extend({getScript:function(a,c){return f.get(a,b,c,"script")},getJSON:function(a,b,c){return f.get(a,b,c,"json")},ajaxSetup:function(a,b){b?b_(a,f.ajaxSettings):(b=a,a=f.ajaxSettings),b_(a,b);return a},ajaxSettings:{url:bV,isLocal:bJ.test(bW[1]),global:!0,type:"GET",contentType:"application/x-www-form-urlencoded",processData:!0,async:!0,accepts:{xml:"application/xml, text/xml",html:"text/html",text:"text/plain",json:"application/json, text/javascript","*":bX},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:"responseXML",text:"responseText"},converters:{"* text":a.String,"text html":!0,"text json":f.parseJSON,"text xml":f.parseXML},flatOptions:{context:!0,url:!0}},ajaxPrefilter:bZ(bT),ajaxTransport:bZ(bU),ajax:function(a,c){function w(a,c,l,m){if(s!==2){s=2,q&&clearTimeout(q),p=b,n=m||"",v.readyState=a>0?4:0;var o,r,u,w=c,x=l?cb(d,v,l):b,y,z;if(a>=200&&a<300||a===304){if(d.ifModified){if(y=v.getResponseHeader("Last-Modified"))f.lastModified[k]=y;if(z=v.getResponseHeader("Etag"))f.etag[k]=z}if(a===304)w="notmodified",o=!0;else try{r=cc(d,x),w="success",o=!0}catch(A){w="parsererror",u=A}}else{u=w;if(!w||a)w="error",a<0&&(a=0)}v.status=a,v.statusText=""+(c||w),o?h.resolveWith(e,[r,w,v]):h.rejectWith(e,[v,w,u]),v.statusCode(j),j=b,t&&g.trigger("ajax"+(o?"Success":"Error"),[v,d,o?r:u]),i.fireWith(e,[v,w]),t&&(g.trigger("ajaxComplete",[v,d]),--f.active||f.event.trigger("ajaxStop"))}}typeof a=="object"&&(c=a,a=b),c=c||{};var d=f.ajaxSetup({},c),e=d.context||d,g=e!==d&&(e.nodeType||e instanceof f)?f(e):f.event,h=f.Deferred(),i=f.Callbacks("once memory"),j=d.statusCode||{},k,l={},m={},n,o,p,q,r,s=0,t,u,v={readyState:0,setRequestHeader:function(a,b){if(!s){var c=a.toLowerCase();a=m[c]=m[c]||a,l[a]=b}return this},getAllResponseHeaders:function(){return s===2?n:null},getResponseHeader:function(a){var c;if(s===2){if(!o){o={};while(c=bH.exec(n))o[c[1].toLowerCase()]=c[2]}c=o[a.toLowerCase()]}return c===b?null:c},overrideMimeType:function(a){s||(d.mimeType=a);return this},abort:function(a){a=a||"abort",p&&p.abort(a),w(0,a);return this}};h.promise(v),v.success=v.done,v.error=v.fail,v.complete=i.add,v.statusCode=function(a){if(a){var b;if(s<2)for(b in a)j[b]=[j[b],a[b]];else b=a[v.status],v.then(b,b)}return this},d.url=((a||d.url)+"").replace(bG,"").replace(bL,bW[1]+"//"),d.dataTypes=f.trim(d.dataType||"*").toLowerCase().split(bP),d.crossDomain==null&&(r=bR.exec(d.url.toLowerCase()),d.crossDomain=!(!r||r[1]==bW[1]&&r[2]==bW[2]&&(r[3]||(r[1]==="http:"?80:443))==(bW[3]||(bW[1]==="http:"?80:443)))),d.data&&d.processData&&typeof d.data!="string"&&(d.data=f.param(d.data,d.traditional)),b$(bT,d,c,v);if(s===2)return!1;t=d.global,d.type=d.type.toUpperCase(),d.hasContent=!bK.test(d.type),t&&f.active++===0&&f.event.trigger("ajaxStart");if(!d.hasContent){d.data&&(d.url+=(bM.test(d.url)?"&":"?")+d.data,delete d.data),k=d.url;if(d.cache===!1){var x=f.now(),y=d.url.replace(bQ,"$1_="+x);d.url=y+(y===d.url?(bM.test(d.url)?"&":"?")+"_="+x:"")}}(d.data&&d.hasContent&&d.contentType!==!1||c.contentType)&&v.setRequestHeader("Content-Type",d.contentType),d.ifModified&&(k=k||d.url,f.lastModified[k]&&v.setRequestHeader("If-Modified-Since",f.lastModified[k]),f.etag[k]&&v.setRequestHeader("If-None-Match",f.etag[k])),v.setRequestHeader("Accept",d.dataTypes[0]&&d.accepts[d.dataTypes[0]]?d.accepts[d.dataTypes[0]]+(d.dataTypes[0]!=="*"?", "+bX+"; q=0.01":""):d.accepts["*"]);for(u in d.headers)v.setRequestHeader(u,d.headers[u]);if(d.beforeSend&&(d.beforeSend.call(e,v,d)===!1||s===2)){v.abort();return!1}for(u in{success:1,error:1,complete:1})v[u](d[u]);p=b$(bU,d,c,v);if(!p)w(-1,"No Transport");else{v.readyState=1,t&&g.trigger("ajaxSend",[v,d]),d.async&&d.timeout>0&&(q=setTimeout(function(){v.abort("timeout")},d.timeout));try{s=1,p.send(l,w)}catch(z){if(s<2)w(-1,z);else throw z}}return v},param:function(a,c){var d=[],e=function(a,b){b=f.isFunction(b)?b():b,d[d.length]=encodeURIComponent(a)+"="+encodeURIComponent(b)};c===b&&(c=f.ajaxSettings.traditional);if(f.isArray(a)||a.jquery&&!f.isPlainObject(a))f.each(a,function(){e(this.name,this.value)});else for(var g in a)ca(g,a[g],c,e);return d.join("&").replace(bD,"+")}}),f.extend({active:0,lastModified:{},etag:{}});var cd=f.now(),ce=/(\=)\?(&|$)|\?\?/i;f.ajaxSetup({jsonp:"callback",jsonpCallback:function(){return f.expando+"_"+cd++}}),f.ajaxPrefilter("json jsonp",function(b,c,d){var e=b.contentType==="application/x-www-form-urlencoded"&&typeof b.data=="string";if(b.dataTypes[0]==="jsonp"||b.jsonp!==!1&&(ce.test(b.url)||e&&ce.test(b.data))){var g,h=b.jsonpCallback=f.isFunction(b.jsonpCallback)?b.jsonpCallback():b.jsonpCallback,i=a[h],j=b.url,k=b.data,l="$1"+h+"$2";b.jsonp!==!1&&(j=j.replace(ce,l),b.url===j&&(e&&(k=k.replace(ce,l)),b.data===k&&(j+=(/\?/.test(j)?"&":"?")+b.jsonp+"="+h))),b.url=j,b.data=k,a[h]=function(a){g=[a]},d.always(function(){a[h]=i,g&&f.isFunction(i)&&a[h](g[0])}),b.converters["script json"]=function(){g||f.error(h+" was not called");return g[0]},b.dataTypes[0]="json";return"script"}}),f.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/javascript|ecmascript/},converters:{"text script":function(a){f.globalEval(a);return a}}}),f.ajaxPrefilter("script",function(a){a.cache===b&&(a.cache=!1),a.crossDomain&&(a.type="GET",a.global=!1)}),f.ajaxTransport("script",function(a){if(a.crossDomain){var d,e=c.head||c.getElementsByTagName("head")[0]||c.documentElement;return{send:function(f,g){d=c.createElement("script"),d.async="async",a.scriptCharset&&(d.charset=a.scriptCharset),d.src=a.url,d.onload=d.onreadystatechange=function(a,c){if(c||!d.readyState||/loaded|complete/.test(d.readyState))d.onload=d.onreadystatechange=null,e&&d.parentNode&&e.removeChild(d),d=b,c||g(200,"success")},e.insertBefore(d,e.firstChild)},abort:function(){d&&d.onload(0,1)}}}});var cf=a.ActiveXObject?function(){for(var a in ch)ch[a](0,1)}:!1,cg=0,ch;f.ajaxSettings.xhr=a.ActiveXObject?function(){return!this.isLocal&&ci()||cj()}:ci,function(a){f.extend(f.support,{ajax:!!a,cors:!!a&&"withCredentials"in a})}(f.ajaxSettings.xhr()),f.support.ajax&&f.ajaxTransport(function(c){if(!c.crossDomain||f.support.cors){var d;return{send:function(e,g){var h=c.xhr(),i,j;c.username?h.open(c.type,c.url,c.async,c.username,c.password):h.open(c.type,c.url,c.async);if(c.xhrFields)for(j in c.xhrFields)h[j]=c.xhrFields[j];c.mimeType&&h.overrideMimeType&&h.overrideMimeType(c.mimeType),!c.crossDomain&&!e["X-Requested-With"]&&(e["X-Requested-With"]="XMLHttpRequest");try{for(j in e)h.setRequestHeader(j,e[j])}catch(k){}h.send(c.hasContent&&c.data||null),d=function(a,e){var j,k,l,m,n;try{if(d&&(e||h.readyState===4)){d=b,i&&(h.onreadystatechange=f.noop,cf&&delete ch[i]);if(e)h.readyState!==4&&h.abort();else{j=h.status,l=h.getAllResponseHeaders(),m={},n=h.responseXML,n&&n.documentElement&&(m.xml=n),m.text=h.responseText;try{k=h.statusText}catch(o){k=""}!j&&c.isLocal&&!c.crossDomain?j=m.text?200:404:j===1223&&(j=204)}}}catch(p){e||g(-1,p)}m&&g(j,k,m,l)},!c.async||h.readyState===4?d():(i=++cg,cf&&(ch||(ch={},f(a).unload(cf)),ch[i]=d),h.onreadystatechange=d)},abort:function(){d&&d(0,1)}}}});var ck={},cl,cm,cn=/^(?:toggle|show|hide)$/,co=/^([+\-]=)?([\d+.\-]+)([a-z%]*)$/i,cp,cq=[["height","marginTop","marginBottom","paddingTop","paddingBottom"],["width","marginLeft","marginRight","paddingLeft","paddingRight"],["opacity"]],cr;f.fn.extend({show:function(a,b,c){var d,e;if(a||a===0)return this.animate(cu("show",3),a,b,c);for(var g=0,h=this.length;g<h;g++)d=this[g],d.style&&(e=d.style.display,!f._data(d,"olddisplay")&&e==="none"&&(e=d.style.display=""),e===""&&f.css(d,"display")==="none"&&f._data(d,"olddisplay",cv(d.nodeName)));for(g=0;g<h;g++){d=this[g];if(d.style){e=d.style.display;if(e===""||e==="none")d.style.display=f._data(d,"olddisplay")||""}}return this},hide:function(a,b,c){if(a||a===0)return this.animate(cu("hide",3),a,b,c);var d,e,g=0,h=this.length;for(;g<h;g++)d=this[g],d.style&&(e=f.css(d,"display"),e!=="none"&&!f._data(d,"olddisplay")&&f._data(d,"olddisplay",e));for(g=0;g<h;g++)this[g].style&&(this[g].style.display="none");return this},_toggle:f.fn.toggle,toggle:function(a,b,c){var d=typeof a=="boolean";f.isFunction(a)&&f.isFunction(b)?this._toggle.apply(this,arguments):a==null||d?this.each(function(){var b=d?a:f(this).is(":hidden");f(this)[b?"show":"hide"]()}):this.animate(cu("toggle",3),a,b,c);return this},fadeTo:function(a,b,c,d){return this.filter(":hidden").css("opacity",0).show().end().animate({opacity:b},a,c,d)},animate:function(a,b,c,d){function g(){e.queue===!1&&f._mark(this);var b=f.extend({},e),c=this.nodeType===1,d=c&&f(this).is(":hidden"),g,h,i,j,k,l,m,n,o;b.animatedProperties={};for(i in a){g=f.camelCase(i),i!==g&&(a[g]=a[i],delete a[i]),h=a[g],f.isArray(h)?(b.animatedProperties[g]=h[1],h=a[g]=h[0]):b.animatedProperties[g]=b.specialEasing&&b.specialEasing[g]||b.easing||"swing";if(h==="hide"&&d||h==="show"&&!d)return b.complete.call(this);c&&(g==="height"||g==="width")&&(b.overflow=[this.style.overflow,this.style.overflowX,this.style.overflowY],f.css(this,"display")==="inline"&&f.css(this,"float")==="none"&&(!f.support.inlineBlockNeedsLayout||cv(this.nodeName)==="inline"?this.style.display="inline-block":this.style.zoom=1))}b.overflow!=null&&(this.style.overflow="hidden");for(i in a)j=new f.fx(this,b,i),h=a[i],cn.test(h)?(o=f._data(this,"toggle"+i)||(h==="toggle"?d?"show":"hide":0),o?(f._data(this,"toggle"+i,o==="show"?"hide":"show"),j[o]()):j[h]()):(k=co.exec(h),l=j.cur(),k?(m=parseFloat(k[2]),n=k[3]||(f.cssNumber[i]?"":"px"),n!=="px"&&(f.style(this,i,(m||1)+n),l=(m||1)/j.cur()*l,f.style(this,i,l+n)),k[1]&&(m=(k[1]==="-="?-1:1)*m+l),j.custom(l,m,n)):j.custom(l,h,""));return!0}var e=f.speed(b,c,d);if(f.isEmptyObject(a))return this.each(e.complete,[!1]);a=f.extend({},a);return e.queue===!1?this.each(g):this.queue(e.queue,g)},stop:function(a,c,d){typeof a!="string"&&(d=c,c=a,a=b),c&&a!==!1&&this.queue(a||"fx",[]);return this.each(function(){function h(a,b,c){var e=b[c];f.removeData(a,c,!0),e.stop(d)}var b,c=!1,e=f.timers,g=f._data(this);d||f._unmark(!0,this);if(a==null)for(b in g)g[b]&&g[b].stop&&b.indexOf(".run")===b.length-4&&h(this,g,b);else g[b=a+".run"]&&g[b].stop&&h(this,g,b);for(b=e.length;b--;)e[b].elem===this&&(a==null||e[b].queue===a)&&(d?e[b](!0):e[b].saveState(),c=!0,e.splice(b,1));(!d||!c)&&f.dequeue(this,a)})}}),f.each({slideDown:cu("show",1),slideUp:cu("hide",1),slideToggle:cu("toggle",1),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(a,b){f.fn[a]=function(a,c,d){return this.animate(b,a,c,d)}}),f.extend({speed:function(a,b,c){var d=a&&typeof a=="object"?f.extend({},a):{complete:c||!c&&b||f.isFunction(a)&&a,duration:a,easing:c&&b||b&&!f.isFunction(b)&&b};d.duration=f.fx.off?0:typeof d.duration=="number"?d.duration:d.duration in f.fx.speeds?f.fx.speeds[d.duration]:f.fx.speeds._default;if(d.queue==null||d.queue===!0)d.queue="fx";d.old=d.complete,d.complete=function(a){f.isFunction(d.old)&&d.old.call(this),d.queue?f.dequeue(this,d.queue):a!==!1&&f._unmark(this)};return d},easing:{linear:function(a,b,c,d){return c+d*a},swing:function(a,b,c,d){return(-Math.cos(a*Math.PI)/2+.5)*d+c}},timers:[],fx:function(a,b,c){this.options=b,this.elem=a,this.prop=c,b.orig=b.orig||{}}}),f.fx.prototype={update:function(){this.options.step&&this.options.step.call(this.elem,this.now,this),(f.fx.step[this.prop]||f.fx.step._default)(this)},cur:function(){if(this.elem[this.prop]!=null&&(!this.elem.style||this.elem.style[this.prop]==null))return this.elem[this.prop];var a,b=f.css(this.elem,this.prop);return isNaN(a=parseFloat(b))?!b||b==="auto"?0:b:a},custom:function(a,c,d){function h(a){return e.step(a)}var e=this,g=f.fx;this.startTime=cr||cs(),this.end=c,this.now=this.start=a,this.pos=this.state=0,this.unit=d||this.unit||(f.cssNumber[this.prop]?"":"px"),h.queue=this.options.queue,h.elem=this.elem,h.saveState=function(){e.options.hide&&f._data(e.elem,"fxshow"+e.prop)===b&&f._data(e.elem,"fxshow"+e.prop,e.start)},h()&&f.timers.push(h)&&!cp&&(cp=setInterval(g.tick,g.interval))},show:function(){var a=f._data(this.elem,"fxshow"+this.prop);this.options.orig[this.prop]=a||f.style(this.elem,this.prop),this.options.show=!0,a!==b?this.custom(this.cur(),a):this.custom(this.prop==="width"||this.prop==="height"?1:0,this.cur()),f(this.elem).show()},hide:function(){this.options.orig[this.prop]=f._data(this.elem,"fxshow"+this.prop)||f.style(this.elem,this.prop),this.options.hide=!0,this.custom(this.cur(),0)},step:function(a){var b,c,d,e=cr||cs(),g=!0,h=this.elem,i=this.options;if(a||e>=i.duration+this.startTime){this.now=this.end,this.pos=this.state=1,this.update(),i.animatedProperties[this.prop]=!0;for(b in i.animatedProperties)i.animatedProperties[b]!==!0&&(g=!1);if(g){i.overflow!=null&&!f.support.shrinkWrapBlocks&&f.each(["","X","Y"],function(a,b){h.style["overflow"+b]=i.overflow[a]}),i.hide&&f(h).hide();if(i.hide||i.show)for(b in i.animatedProperties)f.style(h,b,i.orig[b]),f.removeData(h,"fxshow"+b,!0),f.removeData(h,"toggle"+b,!0);d=i.complete,d&&(i.complete=!1,d.call(h))}return!1}i.duration==Infinity?this.now=e:(c=e-this.startTime,this.state=c/i.duration,this.pos=f.easing[i.animatedProperties[this.prop]](this.state,c,0,1,i.duration),this.now=this.start+(this.end-this.start)*this.pos),this.update();return!0}},f.extend(f.fx,{tick:function(){var a,b=f.timers,c=0;for(;c<b.length;c++)a=b[c],!a()&&b[c]===a&&b.splice(c--,1);b.length||f.fx.stop()},interval:13,stop:function(){clearInterval(cp),cp=null},speeds:{slow:600,fast:200,_default:400},step:{opacity:function(a){f.style(a.elem,"opacity",a.now)},_default:function(a){a.elem.style&&a.elem.style[a.prop]!=null?a.elem.style[a.prop]=a.now+a.unit:a.elem[a.prop]=a.now}}}),f.each(["width","height"],function(a,b){f.fx.step[b]=function(a){f.style(a.elem,b,Math.max(0,a.now)+a.unit)}}),f.expr&&f.expr.filters&&(f.expr.filters.animated=function(a){return f.grep(f.timers,function(b){return a===b.elem}).length});var cw=/^t(?:able|d|h)$/i,cx=/^(?:body|html)$/i;"getBoundingClientRect"in c.documentElement?f.fn.offset=function(a){var b=this[0],c;if(a)return this.each(function(b){f.offset.setOffset(this,a,b)});if(!b||!b.ownerDocument)return null;if(b===b.ownerDocument.body)return f.offset.bodyOffset(b);try{c=b.getBoundingClientRect()}catch(d){}var e=b.ownerDocument,g=e.documentElement;if(!c||!f.contains(g,b))return c?{top:c.top,left:c.left}:{top:0,left:0};var h=e.body,i=cy(e),j=g.clientTop||h.clientTop||0,k=g.clientLeft||h.clientLeft||0,l=i.pageYOffset||f.support.boxModel&&g.scrollTop||h.scrollTop,m=i.pageXOffset||f.support.boxModel&&g.scrollLeft||h.scrollLeft,n=c.top+l-j,o=c.left+m-k;return{top:n,left:o}}:f.fn.offset=function(a){var b=this[0];if(a)return this.each(function(b){f.offset.setOffset(this,a,b)});if(!b||!b.ownerDocument)return null;if(b===b.ownerDocument.body)return f.offset.bodyOffset(b);var c,d=b.offsetParent,e=b,g=b.ownerDocument,h=g.documentElement,i=g.body,j=g.defaultView,k=j?j.getComputedStyle(b,null):b.currentStyle,l=b.offsetTop,m=b.offsetLeft;while((b=b.parentNode)&&b!==i&&b!==h){if(f.support.fixedPosition&&k.position==="fixed")break;c=j?j.getComputedStyle(b,null):b.currentStyle,l-=b.scrollTop,m-=b.scrollLeft,b===d&&(l+=b.offsetTop,m+=b.offsetLeft,f.support.doesNotAddBorder&&(!f.support.doesAddBorderForTableAndCells||!cw.test(b.nodeName))&&(l+=parseFloat(c.borderTopWidth)||0,m+=parseFloat(c.borderLeftWidth)||0),e=d,d=b.offsetParent),f.support.subtractsBorderForOverflowNotVisible&&c.overflow!=="visible"&&(l+=parseFloat(c.borderTopWidth)||0,m+=parseFloat(c.borderLeftWidth)||0),k=c}if(k.position==="relative"||k.position==="static")l+=i.offsetTop,m+=i.offsetLeft;f.support.fixedPosition&&k.position==="fixed"&&(l+=Math.max(h.scrollTop,i.scrollTop),m+=Math.max(h.scrollLeft,i.scrollLeft));return{top:l,left:m}},f.offset={bodyOffset:function(a){var b=a.offsetTop,c=a.offsetLeft;f.support.doesNotIncludeMarginInBodyOffset&&(b+=parseFloat(f.css(a,"marginTop"))||0,c+=parseFloat(f.css(a,"marginLeft"))||0);return{top:b,left:c}},setOffset:function(a,b,c){var d=f.css(a,"position");d==="static"&&(a.style.position="relative");var e=f(a),g=e.offset(),h=f.css(a,"top"),i=f.css(a,"left"),j=(d==="absolute"||d==="fixed")&&f.inArray("auto",[h,i])>-1,k={},l={},m,n;j?(l=e.position(),m=l.top,n=l.left):(m=parseFloat(h)||0,n=parseFloat(i)||0),f.isFunction(b)&&(b=b.call(a,c,g)),b.top!=null&&(k.top=b.top-g.top+m),b.left!=null&&(k.left=b.left-g.left+n),"using"in b?b.using.call(a,k):e.css(k)}},f.fn.extend({position:function(){if(!this[0])return null;var a=this[0],b=this.offsetParent(),c=this.offset(),d=cx.test(b[0].nodeName)?{top:0,left:0}:b.offset();c.top-=parseFloat(f.css(a,"marginTop"))||0,c.left-=parseFloat(f.css(a,"marginLeft"))||0,d.top+=parseFloat(f.css(b[0],"borderTopWidth"))||0,d.left+=parseFloat(f.css(b[0],"borderLeftWidth"))||0;return{top:c.top-d.top,left:c.left-d.left}},offsetParent:function(){return this.map(function(){var a=this.offsetParent||c.body;while(a&&!cx.test(a.nodeName)&&f.css(a,"position")==="static")a=a.offsetParent;return a})}}),f.each(["Left","Top"],function(a,c){var d="scroll"+c;f.fn[d]=function(c){var e,g;if(c===b){e=this[0];if(!e)return null;g=cy(e);return g?"pageXOffset"in g?g[a?"pageYOffset":"pageXOffset"]:f.support.boxModel&&g.document.documentElement[d]||g.document.body[d]:e[d]}return this.each(function(){g=cy(this),g?g.scrollTo(a?f(g).scrollLeft():c,a?c:f(g).scrollTop()):this[d]=c})}}),f.each(["Height","Width"],function(a,c){var d=c.toLowerCase();f.fn["inner"+c]=function(){var a=this[0];return a?a.style?parseFloat(f.css(a,d,"padding")):this[d]():null},f.fn["outer"+c]=function(a){var b=this[0];return b?b.style?parseFloat(f.css(b,d,a?"margin":"border")):this[d]():null},f.fn[d]=function(a){var e=this[0];if(!e)return a==null?null:this;if(f.isFunction(a))return this.each(function(b){var c=f(this);c[d](a.call(this,b,c[d]()))});if(f.isWindow(e)){var g=e.document.documentElement["client"+c],h=e.document.body;return e.document.compatMode==="CSS1Compat"&&g||h&&h["client"+c]||g}if(e.nodeType===9)return Math.max(e.documentElement["client"+c],e.body["scroll"+c],e.documentElement["scroll"+c],e.body["offset"+c],e.documentElement["offset"+c]);if(a===b){var i=f.css(e,d),j=parseFloat(i);return f.isNumeric(j)?j:i}return this.css(d,typeof a=="string"?a:a+"px")}}),a.jQuery=a.$=f,typeof define=="function"&&define.amd&&define.amd.jQuery&&define("jquery",[],function(){return f})})(window);
;

/* http://keith-wood.name/svg.html
SVG for jQuery v1.4.5.
Written by Keith Wood (kbwood{at}iinet.com.au) August 2007.
Dual licensed under the GPL (http://dev.jquery.com/browser/trunk/jquery/GPL-LICENSE.txt) and
MIT (http://dev.jquery.com/browser/trunk/jquery/MIT-LICENSE.txt) licenses.
Please attribute the author if you use it. */

(function($) { // Hide scope, no $ conflict
/* SVG manager.
Use the singleton instance of this class, $.svg,
to interact with the SVG functionality. */
function SVGManager() {
this._settings = []; // Settings to be remembered per SVG object
this._extensions = []; // List of SVG extensions added to SVGWrapper
// for each entry [0] is extension name, [1] is extension class (function)
// the function takes one parameter - the SVGWrapper instance
this.regional = []; // Localisations, indexed by language, '' for default (English)
this.regional[''] = {errorLoadingText: 'Error loading',
notSupportedText: 'This browser does not support SVG'};
this.local = this.regional['']; // Current localisation
this._uuid = new Date().getTime();
this._renesis = detectActiveX('RenesisX.RenesisCtrl');
}

/* Determine whether a given ActiveX control is available.
@param  classId  (string) the ID for the ActiveX control
@return  (boolean) true if found, false if not */
function detectActiveX(classId) {
try {
return !!(window.ActiveXObject && new ActiveXObject(classId));
}
catch (e) {
return false;
}
}

var PROP_NAME = 'svgwrapper';

$.extend(SVGManager.prototype, {
/* Class name added to elements to indicate already configured with SVG. */
markerClassName: 'hasSVG',

/* SVG namespace. */
svgNS: 'http://www.w3.org/2000/svg',
/* XLink namespace. */
xlinkNS: 'http://www.w3.org/1999/xlink',

/* SVG wrapper class. */
_wrapperClass: SVGWrapper,

/* Camel-case versions of attribute names containing dashes or are reserved words. */
_attrNames: {class_: 'class', in_: 'in',
alignmentBaseline: 'alignment-baseline', baselineShift: 'baseline-shift',
clipPath: 'clip-path', clipRule: 'clip-rule',
colorInterpolation: 'color-interpolation',
colorInterpolationFilters: 'color-interpolation-filters',
colorRendering: 'color-rendering', dominantBaseline: 'dominant-baseline',
enableBackground: 'enable-background', fillOpacity: 'fill-opacity',
fillRule: 'fill-rule', floodColor: 'flood-color',
floodOpacity: 'flood-opacity', fontFamily: 'font-family',
fontSize: 'font-size', fontSizeAdjust: 'font-size-adjust',
fontStretch: 'font-stretch', fontStyle: 'font-style',
fontVariant: 'font-variant', fontWeight: 'font-weight',
glyphOrientationHorizontal: 'glyph-orientation-horizontal',
glyphOrientationVertical: 'glyph-orientation-vertical',
horizAdvX: 'horiz-adv-x', horizOriginX: 'horiz-origin-x',
imageRendering: 'image-rendering', letterSpacing: 'letter-spacing',
lightingColor: 'lighting-color', markerEnd: 'marker-end',
markerMid: 'marker-mid', markerStart: 'marker-start',
stopColor: 'stop-color', stopOpacity: 'stop-opacity',
strikethroughPosition: 'strikethrough-position',
strikethroughThickness: 'strikethrough-thickness',
strokeDashArray: 'stroke-dasharray', strokeDashOffset: 'stroke-dashoffset',
strokeLineCap: 'stroke-linecap', strokeLineJoin: 'stroke-linejoin',
strokeMiterLimit: 'stroke-miterlimit', strokeOpacity: 'stroke-opacity',
strokeWidth: 'stroke-width', textAnchor: 'text-anchor',
textDecoration: 'text-decoration', textRendering: 'text-rendering',
underlinePosition: 'underline-position', underlineThickness: 'underline-thickness',
vertAdvY: 'vert-adv-y', vertOriginY: 'vert-origin-y',
wordSpacing: 'word-spacing', writingMode: 'writing-mode'},

/* Add the SVG object to its container. */
_attachSVG: function(container, settings) {
var svg = (container.namespaceURI == this.svgNS ? container : null);
var container = (svg ? null : container);
if ($(container || svg).hasClass(this.markerClassName)) {
return;
}
if (typeof settings == 'string') {
settings = {loadURL: settings};
}
else if (typeof settings == 'function') {
settings = {onLoad: settings};
}
$(container || svg).addClass(this.markerClassName);
try {
if (!svg) {
svg = document.createElementNS(this.svgNS, 'svg');
svg.setAttribute('version', '1.1');
if (container.clientWidth > 0) {
svg.setAttribute('width', container.clientWidth);
}
if (container.clientHeight > 0) {
svg.setAttribute('height', container.clientHeight);
}
container.appendChild(svg);
}
this._afterLoad(container, svg, settings || {});
}
catch (e) {
if ($.browser.msie) {
if (!container.id) {
container.id = 'svg' + (this._uuid++);
}
this._settings[container.id] = settings;
container.innerHTML = '<embed type="image/svg+xml" width="100%" ' +
'height="100%" src="' + (settings.initPath || '') + 'blank.svg" ' +
'pluginspage="http://www.adobe.com/svg/viewer/install/main.html"/>';
}
else {
container.innerHTML = '<p class="svg_error">' +
this.local.notSupportedText + '</p>';
}
}
},

/* SVG callback after loading - register SVG root. */
_registerSVG: function() {
for (var i = 0; i < document.embeds.length; i++) { // Check all
var container = document.embeds[i].parentNode;
if (!$(container).hasClass($.svg.markerClassName) || // Not SVG
$.data(container, PROP_NAME)) { // Already done
continue;
}
var svg = null;

try {
svg = document.embeds[i].getSVGDocument();
}
catch(e) {
setTimeout($.svg._registerSVG, 250); // Renesis takes longer to load
return;
}
svg = (svg ? svg.documentElement : null);
if (svg) {
$.svg._afterLoad(container, svg);
}
}
},

/* Post-processing once loaded. */
_afterLoad: function(container, svg, settings) {
var settings = settings || this._settings[container.id];
this._settings[container ? container.id : ''] = null;
var wrapper = new this._wrapperClass(svg, container);
$.data(container || svg, PROP_NAME, wrapper);
try {
if (settings.loadURL) { // Load URL
wrapper.load(settings.loadURL, settings);
}
if (settings.settings) { // Additional settings
wrapper.configure(settings.settings);
}
if (settings.onLoad && !settings.loadURL) { // Onload callback
settings.onLoad.apply(container || svg, [wrapper]);
}
}
catch (e) {
alert(e);
}
},

/* Return the SVG wrapper created for a given container.
@param  container  (string) selector for the container or
(element) the container for the SVG object or
jQuery collection - first entry is the container
@return  (SVGWrapper) the corresponding SVG wrapper element, or null if not attached */
_getSVG: function(container) {
container = (typeof container == 'string' ? $(container)[0] :
(container.jquery ? container[0] : container));
return $.data(container, PROP_NAME);
},

/* Remove the SVG functionality from a div.
@param  container  (element) the container for the SVG object */
_destroySVG: function(container) {
var $container = $(container);
if (!$container.hasClass(this.markerClassName)) {
return;
}
$container.removeClass(this.markerClassName);
if (container.namespaceURI != this.svgNS) {
$container.empty();
}
$.removeData(container, PROP_NAME);
},

/* Extend the SVGWrapper object with an embedded class.
The constructor function must take a single parameter that is
a reference to the owning SVG root object. This allows the
extension to access the basic SVG functionality.
@param  name      (string) the name of the SVGWrapper attribute to access the new class
@param  extClass  (function) the extension class constructor */
addExtension: function(name, extClass) {
this._extensions.push([name, extClass]);
},

/* Does this node belong to SVG?
@param  node  (element) the node to be tested
@return  (boolean) true if an SVG node, false if not */
isSVGElem: function(node) {
return (node.nodeType == 1 && node.namespaceURI == $.svg.svgNS);
}
});

/* The main SVG interface, which encapsulates the SVG element.
Obtain a reference from $().svg('get') */
function SVGWrapper(svg, container) {
this._svg = svg; // The SVG root node
this._container = container; // The containing div
for (var i = 0; i < $.svg._extensions.length; i++) {
var extension = $.svg._extensions[i];
this[extension[0]] = new extension[1](this);
}
}

$.extend(SVGWrapper.prototype, {

/* Retrieve the width of the SVG object. */
_width: function() {
return (this._container ? this._container.clientWidth : this._svg.width);
},

/* Retrieve the height of the SVG object. */
_height: function() {
return (this._container ? this._container.clientHeight : this._svg.height);
},

/* Retrieve the root SVG element.
@return  the top-level SVG element */
root: function() {
return this._svg;
},

/* Configure a SVG node.
@param  node      (element, optional) the node to configure
@param  settings  (object) additional settings for the root
@param  clear     (boolean) true to remove existing attributes first,
false to add to what is already there (optional)
@return  (SVGWrapper) this root */
configure: function(node, settings, clear) {
if (!node.nodeName) {
clear = settings;
settings = node;
node = this._svg;
}
if (clear) {
for (var i = node.attributes.length - 1; i >= 0; i--) {
var attr = node.attributes.item(i);
if (!(attr.nodeName == 'onload' || attr.nodeName == 'version' ||
attr.nodeName.substring(0, 5) == 'xmlns')) {
node.attributes.removeNamedItem(attr.nodeName);
}
}
}
for (var attrName in settings) {
node.setAttribute($.svg._attrNames[attrName] || attrName, settings[attrName]);
}
return this;
},

/* Locate a specific element in the SVG document.
@param  id  (string) the element's identifier
@return  (element) the element reference, or null if not found */
getElementById: function(id) {
return this._svg.ownerDocument.getElementById(id);
},

/* Change the attributes for a SVG node.
@param  element   (SVG element) the node to change
@param  settings  (object) the new settings
@return  (SVGWrapper) this root */
change: function(element, settings) {
if (element) {
for (var name in settings) {
if (settings[name] == null) {
element.removeAttribute($.svg._attrNames[name] || name);
}
else {
element.setAttribute($.svg._attrNames[name] || name, settings[name]);
}
}
}
return this;
},

/* Check for parent being absent and adjust arguments accordingly. */
_args: function(values, names, optSettings) {
names.splice(0, 0, 'parent');
names.splice(names.length, 0, 'settings');
var args = {};
var offset = 0;
if (values[0] != null && values[0].jquery) {
values[0] = values[0][0];
}
if (values[0] != null && !(typeof values[0] == 'object' && values[0].nodeName)) {
args['parent'] = null;
offset = 1;
}
for (var i = 0; i < values.length; i++) {
args[names[i + offset]] = values[i];
}
if (optSettings) {
$.each(optSettings, function(i, value) {
if (typeof args[value] == 'object') {
args.settings = args[value];
args[value] = null;
}
});
}
return args;
},

/* Add a title.
@param  parent    (element or jQuery) the parent node for the new title (optional)
@param  text      (string) the text of the title
@param  settings  (object) additional settings for the title (optional)
@return  (element) the new title node */
title: function(parent, text, settings) {
var args = this._args(arguments, ['text']);
var node = this._makeNode(args.parent, 'title', args.settings || {});
node.appendChild(this._svg.ownerDocument.createTextNode(args.text));
return node;
},

/* Add a description.
@param  parent    (element or jQuery) the parent node for the new description (optional)
@param  text      (string) the text of the description
@param  settings  (object) additional settings for the description (optional)
@return  (element) the new description node */
describe: function(parent, text, settings) {
var args = this._args(arguments, ['text']);
var node = this._makeNode(args.parent, 'desc', args.settings || {});
node.appendChild(this._svg.ownerDocument.createTextNode(args.text));
return node;
},

/* Add a definitions node.
@param  parent    (element or jQuery) the parent node for the new definitions (optional)
@param  id        (string) the ID of this definitions (optional)
@param  settings  (object) additional settings for the definitions (optional)
@return  (element) the new definitions node */
defs: function(parent, id, settings) {
var args = this._args(arguments, ['id'], ['id']);
return this._makeNode(args.parent, 'defs', $.extend(
(args.id ? {id: args.id} : {}), args.settings || {}));
},

/* Add a symbol definition.
@param  parent    (element or jQuery) the parent node for the new symbol (optional)
@param  id        (string) the ID of this symbol
@param  x1        (number) the left coordinate for this symbol
@param  y1        (number) the top coordinate for this symbol
@param  width     (number) the width of this symbol
@param  height    (number) the height of this symbol
@param  settings  (object) additional settings for the symbol (optional)
@return  (element) the new symbol node */
symbol: function(parent, id, x1, y1, width, height, settings) {
var args = this._args(arguments, ['id', 'x1', 'y1', 'width', 'height']);
return this._makeNode(args.parent, 'symbol', $.extend({id: args.id,
viewBox: args.x1 + ' ' + args.y1 + ' ' + args.width + ' ' + args.height},
args.settings || {}));
},

/* Add a marker definition.
@param  parent    (element or jQuery) the parent node for the new marker (optional)
@param  id        (string) the ID of this marker
@param  refX      (number) the x-coordinate for the reference point
@param  refY      (number) the y-coordinate for the reference point
@param  mWidth    (number) the marker viewport width
@param  mHeight   (number) the marker viewport height
@param  orient    (string or int) 'auto' or angle (degrees) (optional)
@param  settings  (object) additional settings for the marker (optional)
@return  (element) the new marker node */
marker: function(parent, id, refX, refY, mWidth, mHeight, orient, settings) {
var args = this._args(arguments, ['id', 'refX', 'refY',
'mWidth', 'mHeight', 'orient'], ['orient']);
return this._makeNode(args.parent, 'marker', $.extend(
{id: args.id, refX: args.refX, refY: args.refY, markerWidth: args.mWidth,
markerHeight: args.mHeight, orient: args.orient || 'auto'}, args.settings || {}));
},

/* Add a style node.
@param  parent    (element or jQuery) the parent node for the new node (optional)
@param  styles    (string) the CSS styles
@param  settings  (object) additional settings for the node (optional)
@return  (element) the new style node */
style: function(parent, styles, settings) {
var args = this._args(arguments, ['styles']);
var node = this._makeNode(args.parent, 'style', $.extend(
{type: 'text/css'}, args.settings || {}));
node.appendChild(this._svg.ownerDocument.createTextNode(args.styles));
if ($.browser.opera) {
$('head').append('<style type="text/css">' + args.styles + '</style>');
}
return node;
},

/* Add a script node.
@param  parent    (element or jQuery) the parent node for the new node (optional)
@param  script    (string) the JavaScript code
@param  type      (string) the MIME type for the code (optional, default 'text/javascript')
@param  settings  (object) additional settings for the node (optional)
@return  (element) the new script node */
script: function(parent, script, type, settings) {
var args = this._args(arguments, ['script', 'type'], ['type']);
var node = this._makeNode(args.parent, 'script', $.extend(
{type: args.type || 'text/javascript'}, args.settings || {}));
node.appendChild(this._svg.ownerDocument.createTextNode(args.script));
if (!$.browser.mozilla) {
$.globalEval(args.script);
}
return node;
},

/* Add a linear gradient definition.
Specify all of x1, y1, x2, y2 or none of them.
@param  parent    (element or jQuery) the parent node for the new gradient (optional)
@param  id        (string) the ID for this gradient
@param  stops     (string[][]) the gradient stops, each entry is
[0] is offset (0.0-1.0 or 0%-100%), [1] is colour,
[2] is opacity (optional)
@param  x1        (number) the x-coordinate of the gradient start (optional)
@param  y1        (number) the y-coordinate of the gradient start (optional)
@param  x2        (number) the x-coordinate of the gradient end (optional)
@param  y2        (number) the y-coordinate of the gradient end (optional)
@param  settings  (object) additional settings for the gradient (optional)
@return  (element) the new gradient node */
linearGradient: function(parent, id, stops, x1, y1, x2, y2, settings) {
var args = this._args(arguments,
['id', 'stops', 'x1', 'y1', 'x2', 'y2'], ['x1']);
var sets = $.extend({id: args.id},
(args.x1 != null ? {x1: args.x1, y1: args.y1, x2: args.x2, y2: args.y2} : {}));
return this._gradient(args.parent, 'linearGradient',
$.extend(sets, args.settings || {}), args.stops);
},

/* Add a radial gradient definition.
Specify all of cx, cy, r, fx, fy or none of them.
@param  parent    (element or jQuery) the parent node for the new gradient (optional)
@param  id        (string) the ID for this gradient
@param  stops     (string[][]) the gradient stops, each entry
[0] is offset, [1] is colour, [2] is opacity (optional)
@param  cx        (number) the x-coordinate of the largest circle centre (optional)
@param  cy        (number) the y-coordinate of the largest circle centre (optional)
@param  r         (number) the radius of the largest circle (optional)
@param  fx        (number) the x-coordinate of the gradient focus (optional)
@param  fy        (number) the y-coordinate of the gradient focus (optional)
@param  settings  (object) additional settings for the gradient (optional)
@return  (element) the new gradient node */
radialGradient: function(parent, id, stops, cx, cy, r, fx, fy, settings) {
var args = this._args(arguments,
['id', 'stops', 'cx', 'cy', 'r', 'fx', 'fy'], ['cx']);
var sets = $.extend({id: args.id}, (args.cx != null ?
{cx: args.cx, cy: args.cy, r: args.r, fx: args.fx, fy: args.fy} : {}));
return this._gradient(args.parent, 'radialGradient',
$.extend(sets, args.settings || {}), args.stops);
},

/* Add a gradient node. */
_gradient: function(parent, name, settings, stops) {
var node = this._makeNode(parent, name, settings);
for (var i = 0; i < stops.length; i++) {
var stop = stops[i];
this._makeNode(node, 'stop', $.extend(
{offset: stop[0], stopColor: stop[1]},
(stop[2] != null ? {stopOpacity: stop[2]} : {})));
}
return node;
},

/* Add a pattern definition.
Specify all of vx, vy, xwidth, vheight or none of them.
@param  parent    (element or jQuery) the parent node for the new pattern (optional)
@param  id        (string) the ID for this pattern
@param  x         (number) the x-coordinate for the left edge of the pattern
@param  y         (number) the y-coordinate for the top edge of the pattern
@param  width     (number) the width of the pattern
@param  height    (number) the height of the pattern
@param  vx        (number) the minimum x-coordinate for view box (optional)
@param  vy        (number) the minimum y-coordinate for the view box (optional)
@param  vwidth    (number) the width of the view box (optional)
@param  vheight   (number) the height of the view box (optional)
@param  settings  (object) additional settings for the pattern (optional)
@return  (element) the new pattern node */
pattern: function(parent, id, x, y, width, height, vx, vy, vwidth, vheight, settings) {
var args = this._args(arguments, ['id', 'x', 'y', 'width', 'height',
'vx', 'vy', 'vwidth', 'vheight'], ['vx']);
var sets = $.extend({id: args.id, x: args.x, y: args.y,
width: args.width, height: args.height}, (args.vx != null ?
{viewBox: args.vx + ' ' + args.vy + ' ' + args.vwidth + ' ' + args.vheight} : {}));
return this._makeNode(args.parent, 'pattern', $.extend(sets, args.settings || {}));
},

/* Add a clip path definition.
@param  parent  (element) the parent node for the new element (optional)
@param  id      (string) the ID for this path
@param  units   (string) either 'userSpaceOnUse' (default) or 'objectBoundingBox' (optional)
@return  (element) the new clipPath node */
clipPath: function(parent, id, units, settings) {
var args = this._args(arguments, ['id', 'units']);
args.units = args.units || 'userSpaceOnUse';
return this._makeNode(args.parent, 'clipPath', $.extend(
{id: args.id, clipPathUnits: args.units}, args.settings || {}));
},

/* Add a mask definition.
@param  parent    (element or jQuery) the parent node for the new mask (optional)
@param  id        (string) the ID for this mask
@param  x         (number) the x-coordinate for the left edge of the mask
@param  y         (number) the y-coordinate for the top edge of the mask
@param  width     (number) the width of the mask
@param  height    (number) the height of the mask
@param  settings  (object) additional settings for the mask (optional)
@return  (element) the new mask node */
mask: function(parent, id, x, y, width, height, settings) {
var args = this._args(arguments, ['id', 'x', 'y', 'width', 'height']);
return this._makeNode(args.parent, 'mask', $.extend(
{id: args.id, x: args.x, y: args.y, width: args.width, height: args.height},
args.settings || {}));
},

/* Create a new path object.
@return  (SVGPath) a new path object */
createPath: function() {
return new SVGPath();
},

/* Create a new text object.
@return  (SVGText) a new text object */
createText: function() {
return new SVGText();
},

/* Add an embedded SVG element.
Specify all of vx, vy, vwidth, vheight or none of them.
@param  parent    (element or jQuery) the parent node for the new node (optional)
@param  x         (number) the x-coordinate for the left edge of the node
@param  y         (number) the y-coordinate for the top edge of the node
@param  width     (number) the width of the node
@param  height    (number) the height of the node
@param  vx        (number) the minimum x-coordinate for view box (optional)
@param  vy        (number) the minimum y-coordinate for the view box (optional)
@param  vwidth    (number) the width of the view box (optional)
@param  vheight   (number) the height of the view box (optional)
@param  settings  (object) additional settings for the node (optional)
@return  (element) the new node */
svg: function(parent, x, y, width, height, vx, vy, vwidth, vheight, settings) {
var args = this._args(arguments, ['x', 'y', 'width', 'height',
'vx', 'vy', 'vwidth', 'vheight'], ['vx']);
var sets = $.extend({x: args.x, y: args.y, width: args.width, height: args.height},
(args.vx != null ? {viewBox: args.vx + ' ' + args.vy + ' ' +
args.vwidth + ' ' + args.vheight} : {}));
return this._makeNode(args.parent, 'svg', $.extend(sets, args.settings || {}));
},

/* Create a group.
@param  parent    (element or jQuery) the parent node for the new group (optional)
@param  id        (string) the ID of this group (optional)
@param  settings  (object) additional settings for the group (optional)
@return  (element) the new group node */
group: function(parent, id, settings) {
var args = this._args(arguments, ['id'], ['id']);
return this._makeNode(args.parent, 'g', $.extend({id: args.id}, args.settings || {}));
},

/* Add a usage reference.
Specify all of x, y, width, height or none of them.
@param  parent    (element or jQuery) the parent node for the new node (optional)
@param  x         (number) the x-coordinate for the left edge of the node (optional)
@param  y         (number) the y-coordinate for the top edge of the node (optional)
@param  width     (number) the width of the node (optional)
@param  height    (number) the height of the node (optional)
@param  ref       (string) the ID of the definition node
@param  settings  (object) additional settings for the node (optional)
@return  (element) the new node */
use: function(parent, x, y, width, height, ref, settings) {
var args = this._args(arguments, ['x', 'y', 'width', 'height', 'ref']);
if (typeof args.x == 'string') {
args.ref = args.x;
args.settings = args.y;
args.x = args.y = args.width = args.height = null;
}
var node = this._makeNode(args.parent, 'use', $.extend(
{x: args.x, y: args.y, width: args.width, height: args.height},
args.settings || {}));
node.setAttributeNS($.svg.xlinkNS, 'href', args.ref);
return node;
},

/* Add a link, which applies to all child elements.
@param  parent    (element or jQuery) the parent node for the new link (optional)
@param  ref       (string) the target URL
@param  settings  (object) additional settings for the link (optional)
@return  (element) the new link node */
link: function(parent, ref, settings) {
var args = this._args(arguments, ['ref']);
var node = this._makeNode(args.parent, 'a', args.settings);
node.setAttributeNS($.svg.xlinkNS, 'href', args.ref);
return node;
},

/* Add an image.
@param  parent    (element or jQuery) the parent node for the new image (optional)
@param  x         (number) the x-coordinate for the left edge of the image
@param  y         (number) the y-coordinate for the top edge of the image
@param  width     (number) the width of the image
@param  height    (number) the height of the image
@param  ref       (string) the path to the image
@param  settings  (object) additional settings for the image (optional)
@return  (element) the new image node */
image: function(parent, x, y, width, height, ref, settings) {
var args = this._args(arguments, ['x', 'y', 'width', 'height', 'ref']);
var node = this._makeNode(args.parent, 'image', $.extend(
{x: args.x, y: args.y, width: args.width, height: args.height},
args.settings || {}));
node.setAttributeNS($.svg.xlinkNS, 'href', args.ref);
return node;
},

/* Draw a path.
@param  parent    (element or jQuery) the parent node for the new shape (optional)
@param  path      (string or SVGPath) the path to draw
@param  settings  (object) additional settings for the shape (optional)
@return  (element) the new shape node */
path: function(parent, path, settings) {
var args = this._args(arguments, ['path']);
return this._makeNode(args.parent, 'path', $.extend(
{d: (args.path.path ? args.path.path() : args.path)}, args.settings || {}));
},

/* Draw a rectangle.
Specify both of rx and ry or neither.
@param  parent    (element or jQuery) the parent node for the new shape (optional)
@param  x         (number) the x-coordinate for the left edge of the rectangle
@param  y         (number) the y-coordinate for the top edge of the rectangle
@param  width     (number) the width of the rectangle
@param  height    (number) the height of the rectangle
@param  rx        (number) the x-radius of the ellipse for the rounded corners (optional)
@param  ry        (number) the y-radius of the ellipse for the rounded corners (optional)
@param  settings  (object) additional settings for the shape (optional)
@return  (element) the new shape node */
rect: function(parent, x, y, width, height, rx, ry, settings) {
var args = this._args(arguments, ['x', 'y', 'width', 'height', 'rx', 'ry'], ['rx']);
return this._makeNode(args.parent, 'rect', $.extend(
{x: args.x, y: args.y, width: args.width, height: args.height},
(args.rx ? {rx: args.rx, ry: args.ry} : {}), args.settings || {}));
},

/* Draw a circle.
@param  parent    (element or jQuery) the parent node for the new shape (optional)
@param  cx        (number) the x-coordinate for the centre of the circle
@param  cy        (number) the y-coordinate for the centre of the circle
@param  r         (number) the radius of the circle
@param  settings  (object) additional settings for the shape (optional)
@return  (element) the new shape node */
circle: function(parent, cx, cy, r, settings) {
var args = this._args(arguments, ['cx', 'cy', 'r']);
return this._makeNode(args.parent, 'circle', $.extend(
{cx: args.cx, cy: args.cy, r: args.r}, args.settings || {}));
},

/* Draw an ellipse.
@param  parent    (element or jQuery) the parent node for the new shape (optional)
@param  cx        (number) the x-coordinate for the centre of the ellipse
@param  cy        (number) the y-coordinate for the centre of the ellipse
@param  rx        (number) the x-radius of the ellipse
@param  ry        (number) the y-radius of the ellipse
@param  settings  (object) additional settings for the shape (optional)
@return  (element) the new shape node */
ellipse: function(parent, cx, cy, rx, ry, settings) {
var args = this._args(arguments, ['cx', 'cy', 'rx', 'ry']);
return this._makeNode(args.parent, 'ellipse', $.extend(
{cx: args.cx, cy: args.cy, rx: args.rx, ry: args.ry}, args.settings || {}));
},

/* Draw a line.
@param  parent    (element or jQuery) the parent node for the new shape (optional)
@param  x1        (number) the x-coordinate for the start of the line
@param  y1        (number) the y-coordinate for the start of the line
@param  x2        (number) the x-coordinate for the end of the line
@param  y2        (number) the y-coordinate for the end of the line
@param  settings  (object) additional settings for the shape (optional)
@return  (element) the new shape node */
line: function(parent, x1, y1, x2, y2, settings) {
var args = this._args(arguments, ['x1', 'y1', 'x2', 'y2']);
return this._makeNode(args.parent, 'line', $.extend(
{x1: args.x1, y1: args.y1, x2: args.x2, y2: args.y2}, args.settings || {}));
},

/* Draw a polygonal line.
@param  parent    (element or jQuery) the parent node for the new shape (optional)
@param  points    (number[][]) the x-/y-coordinates for the points on the line
@param  settings  (object) additional settings for the shape (optional)
@return  (element) the new shape node */
polyline: function(parent, points, settings) {
var args = this._args(arguments, ['points']);
return this._poly(args.parent, 'polyline', args.points, args.settings);
},

/* Draw a polygonal shape.
@param  parent    (element or jQuery) the parent node for the new shape (optional)
@param  points    (number[][]) the x-/y-coordinates for the points on the shape
@param  settings  (object) additional settings for the shape (optional)
@return  (element) the new shape node */
polygon: function(parent, points, settings) {
var args = this._args(arguments, ['points']);
return this._poly(args.parent, 'polygon', args.points, args.settings);
},

/* Draw a polygonal line or shape. */
_poly: function(parent, name, points, settings) {
var ps = '';
for (var i = 0; i < points.length; i++) {
ps += points[i].join() + ' ';
}
return this._makeNode(parent, name, $.extend(
{points: $.trim(ps)}, settings || {}));
},

/* Draw text.
Specify both of x and y or neither of them.
@param  parent    (element or jQuery) the parent node for the text (optional)
@param  x         (number or number[]) the x-coordinate(s) for the text (optional)
@param  y         (number or number[]) the y-coordinate(s) for the text (optional)
@param  value     (string) the text content or
(SVGText) text with spans and references
@param  settings  (object) additional settings for the text (optional)
@return  (element) the new text node */
text: function(parent, x, y, value, settings) {
var args = this._args(arguments, ['x', 'y', 'value']);
if (typeof args.x == 'string' && arguments.length < 4) {
args.value = args.x;
args.settings = args.y;
args.x = args.y = null;
}
return this._text(args.parent, 'text', args.value, $.extend(
{x: (args.x && isArray(args.x) ? args.x.join(' ') : args.x),
y: (args.y && isArray(args.y) ? args.y.join(' ') : args.y)},
args.settings || {}));
},

/* Draw text along a path.
@param  parent    (element or jQuery) the parent node for the text (optional)
@param  path      (string) the ID of the path
@param  value     (string) the text content or
(SVGText) text with spans and references
@param  settings  (object) additional settings for the text (optional)
@return  (element) the new text node */
textpath: function(parent, path, value, settings) {
var args = this._args(arguments, ['path', 'value']);
var node = this._text(args.parent, 'textPath', args.value, args.settings || {});
node.setAttributeNS($.svg.xlinkNS, 'href', args.path);
return node;
},

/* Draw text. */
_text: function(parent, name, value, settings) {
var node = this._makeNode(parent, name, settings);
if (typeof value == 'string') {
node.appendChild(node.ownerDocument.createTextNode(value));
}
else {
for (var i = 0; i < value._parts.length; i++) {
var part = value._parts[i];
if (part[0] == 'tspan') {
var child = this._makeNode(node, part[0], part[2]);
child.appendChild(node.ownerDocument.createTextNode(part[1]));
node.appendChild(child);
}
else if (part[0] == 'tref') {
var child = this._makeNode(node, part[0], part[2]);
child.setAttributeNS($.svg.xlinkNS, 'href', part[1]);
node.appendChild(child);
}
else if (part[0] == 'textpath') {
var set = $.extend({}, part[2]);
set.href = null;
var child = this._makeNode(node, part[0], set);
child.setAttributeNS($.svg.xlinkNS, 'href', part[2].href);
child.appendChild(node.ownerDocument.createTextNode(part[1]));
node.appendChild(child);
}
else { // straight text
node.appendChild(node.ownerDocument.createTextNode(part[1]));
}
}
}
return node;
},

/* Add a custom SVG element.
@param  parent    (element or jQuery) the parent node for the new element (optional)
@param  name      (string) the name of the element
@param  settings  (object) additional settings for the element (optional)
@return  (element) the new custom node */
other: function(parent, name, settings) {
var args = this._args(arguments, ['name']);
return this._makeNode(args.parent, args.name, args.settings || {});
},

/* Create a shape node with the given settings. */
_makeNode: function(parent, name, settings) {
parent = parent || this._svg;
var node = this._svg.ownerDocument.createElementNS($.svg.svgNS, name);
for (var name in settings) {
var value = settings[name];
if (value != null && value != null &&
(typeof value != 'string' || value != '')) {
node.setAttribute($.svg._attrNames[name] || name, value);
}
}
parent.appendChild(node);
return node;
},

/* Add an existing SVG node to the diagram.
@param  parent  (element or jQuery) the parent node for the new node (optional)
@param  node    (element) the new node to add or
(string) the jQuery selector for the node or
(jQuery collection) set of nodes to add
@return  (SVGWrapper) this wrapper */
add: function(parent, node) {
var args = this._args((arguments.length == 1 ? [null, parent] : arguments), ['node']);
var svg = this;
args.parent = args.parent || this._svg;
args.node = (args.node.jquery ? args.node : $(args.node));
try {
if ($.svg._renesis) {
throw 'Force traversal';
}
args.parent.appendChild(args.node.cloneNode(true));
}
catch (e) {
args.node.each(function() {
var child = svg._cloneAsSVG(this);
if (child) {
args.parent.appendChild(child);
}
});
}
return this;
},

/* Clone an existing SVG node and add it to the diagram.
@param  parent  (element or jQuery) the parent node for the new node (optional)
@param  node    (element) the new node to add or
(string) the jQuery selector for the node or
(jQuery collection) set of nodes to add
@return  (element[]) collection of new nodes */
clone: function(parent, node) {
var svg = this;
var args = this._args((arguments.length == 1 ? [null, parent] : arguments), ['node']);
args.parent = args.parent || this._svg;
args.node = (args.node.jquery ? args.node : $(args.node));
var newNodes = [];
args.node.each(function() {
var child = svg._cloneAsSVG(this);
if (child) {
child.id = '';
args.parent.appendChild(child);
newNodes.push(child);
}
});
return newNodes;
},

/* SVG nodes must belong to the SVG namespace, so clone and ensure this is so.
@param  node  (element) the SVG node to clone
@return  (element) the cloned node */
_cloneAsSVG: function(node) {
var newNode = null;
if (node.nodeType == 1) { // element
newNode = this._svg.ownerDocument.createElementNS(
$.svg.svgNS, this._checkName(node.nodeName));
for (var i = 0; i < node.attributes.length; i++) {
var attr = node.attributes.item(i);
if (attr.nodeName != 'xmlns' && attr.nodeValue) {
if (attr.prefix == 'xlink') {
newNode.setAttributeNS($.svg.xlinkNS,
attr.localName || attr.baseName, attr.nodeValue);
}
else {
newNode.setAttribute(this._checkName(attr.nodeName), attr.nodeValue);
}
}
}
for (var i = 0; i < node.childNodes.length; i++) {
var child = this._cloneAsSVG(node.childNodes[i]);
if (child) {
newNode.appendChild(child);
}
}
}
else if (node.nodeType == 3) { // text
if ($.trim(node.nodeValue)) {
newNode = this._svg.ownerDocument.createTextNode(node.nodeValue);
}
}
else if (node.nodeType == 4) { // CDATA
if ($.trim(node.nodeValue)) {
try {
newNode = this._svg.ownerDocument.createCDATASection(node.nodeValue);
}
catch (e) {
newNode = this._svg.ownerDocument.createTextNode(
node.nodeValue.replace(/&/g, '&amp;').
replace(/</g, '&lt;').replace(/>/g, '&gt;'));
}
}
}
return newNode;
},

/* Node names must be lower case and without SVG namespace prefix. */
_checkName: function(name) {
name = (name.substring(0, 1) >= 'A' && name.substring(0, 1) <= 'Z' ?
name.toLowerCase() : name);
return (name.substring(0, 4) == 'svg:' ? name.substring(4) : name);
},

/* Load an external SVG document.
@param  url       (string) the location of the SVG document or
the actual SVG content
@param  settings  (boolean) see addTo below or
(function) see onLoad below or
(object) additional settings for the load with attributes below:
addTo       (boolean) true to add to what's already there,
or false to clear the canvas first
changeSize  (boolean) true to allow the canvas size to change,
or false to retain the original
onLoad      (function) callback after the document has loaded,
'this' is the container, receives SVG object and
optional error message as a parameter
parent      (string or element or jQuery) the parent to load
into, defaults to top-level svg element
@return  (SVGWrapper) this root */
load: function(url, settings) {
settings = (typeof settings == 'boolean' ? {addTo: settings} :
(typeof settings == 'function' ? {onLoad: settings} :
(typeof settings == 'string' ? {parent: settings} :
(typeof settings == 'object' && settings.nodeName ? {parent: settings} :
(typeof settings == 'object' && settings.jquery ? {parent: settings} :
settings || {})))));
if (!settings.parent && !settings.addTo) {
this.clear(false);
}
var size = [this._svg.getAttribute('width'), this._svg.getAttribute('height')];
var wrapper = this;
// Report a problem with the load
var reportError = function(message) {
message = $.svg.local.errorLoadingText + ': ' + message;
if (settings.onLoad) {
settings.onLoad.apply(wrapper._container || wrapper._svg, [wrapper, message]);
}
else {
wrapper.text(null, 10, 20, message);
}
};
// Create a DOM from SVG content
var loadXML4IE = function(data) {
var xml = new ActiveXObject('Microsoft.XMLDOM');
xml.validateOnParse = false;
xml.resolveExternals = false;
xml.async = false;
xml.loadXML(data);
if (xml.parseError.errorCode != 0) {
reportError(xml.parseError.reason);
return null;
}
return xml;
};
// Load the SVG DOM
var loadSVG = function(data) {
if (!data) {
return;
}
if (data.documentElement.nodeName != 'svg') {
var errors = data.getElementsByTagName('parsererror');
var messages = (errors.length ? errors[0].getElementsByTagName('div') : []); // Safari
reportError(!errors.length ? '???' :
(messages.length ? messages[0] : errors[0]).firstChild.nodeValue);
return;
}
var parent = (settings.parent ? $(settings.parent)[0] : wrapper._svg);
var attrs = {};
for (var i = 0; i < data.documentElement.attributes.length; i++) {
var attr = data.documentElement.attributes.item(i);
if (!(attr.nodeName == 'version' || attr.nodeName.substring(0, 5) == 'xmlns')) {
attrs[attr.nodeName] = attr.nodeValue;
}
}
wrapper.configure(parent, attrs, !settings.parent);
var nodes = data.documentElement.childNodes;
for (var i = 0; i < nodes.length; i++) {
try {
if ($.svg._renesis) {
throw 'Force traversal';
}
parent.appendChild(wrapper._svg.ownerDocument.importNode(nodes[i], true));
if (nodes[i].nodeName == 'script') {
$.globalEval(nodes[i].textContent);
}
}
catch (e) {
wrapper.add(parent, nodes[i]);
}
}
if (!settings.changeSize) {
wrapper.configure(parent, {width: size[0], height: size[1]});
}
if (settings.onLoad) {
settings.onLoad.apply(wrapper._container || wrapper._svg, [wrapper]);
}
};
if (url.match('<svg')) { // Inline SVG
loadSVG($.browser.msie ? loadXML4IE(url) :
new DOMParser().parseFromString(url, 'text/xml'));
}
else { // Remote SVG
$.ajax({url: url, dataType: ($.browser.msie ? 'text' : 'xml'),
success: function(xml) {
loadSVG($.browser.msie ? loadXML4IE(xml) : xml);
}, error: function(http, message, exc) {
reportError(message + (exc ? ' ' + exc.message : ''));
}});
}
return this;
},

/* Delete a specified node.
@param  node  (element or jQuery) the drawing node to remove
@return  (SVGWrapper) this root */
remove: function(node) {
node = (node.jquery ? node[0] : node);
node.parentNode.removeChild(node);
return this;
},

/* Delete everything in the current document.
@param  attrsToo  (boolean) true to clear any root attributes as well,
false to leave them (optional)
@return  (SVGWrapper) this root */
clear: function(attrsToo) {
if (attrsToo) {
this.configure({}, true);
}
while (this._svg.firstChild) {
this._svg.removeChild(this._svg.firstChild);
}
return this;
},

/* Serialise the current diagram into an SVG text document.
@param  node  (SVG element) the starting node (optional)
@return  (string) the SVG as text */
toSVG: function(node) {
node = node || this._svg;
return (typeof XMLSerializer == 'undefined' ? this._toSVG(node) :
new XMLSerializer().serializeToString(node));
},

/* Serialise one node in the SVG hierarchy. */
_toSVG: function(node) {
var svgDoc = '';
if (!node) {
return svgDoc;
}
if (node.nodeType == 3) { // Text
svgDoc = node.nodeValue;
}
else if (node.nodeType == 4) { // CDATA
svgDoc = '<![CDATA[' + node.nodeValue + ']]>';
}
else { // Element
svgDoc = '<' + node.nodeName;
if (node.attributes) {
for (var i = 0; i < node.attributes.length; i++) {
var attr = node.attributes.item(i);
if (!($.trim(attr.nodeValue) == '' || attr.nodeValue.match(/^\[object/) ||
attr.nodeValue.match(/^function/))) {
svgDoc += ' ' + (attr.namespaceURI == $.svg.xlinkNS ? 'xlink:' : '') +
attr.nodeName + '="' + attr.nodeValue + '"';
}
}
}
if (node.firstChild) {
svgDoc += '>';
var child = node.firstChild;
while (child) {
svgDoc += this._toSVG(child);
child = child.nextSibling;
}
svgDoc += '</' + node.nodeName + '>';
}
else {
svgDoc += '/>';
}
}
return svgDoc;
}
});

/* Helper to generate an SVG path.
Obtain an instance from the SVGWrapper object.
String calls together to generate the path and use its value:
var path = root.createPath();
root.path(null, path.move(100, 100).line(300, 100).line(200, 300).close(), {fill: 'red'});
or
root.path(null, path.move(100, 100).line([[300, 100], [200, 300]]).close(), {fill: 'red'}); */
function SVGPath() {
this._path = '';
}

$.extend(SVGPath.prototype, {
/* Prepare to create a new path.
@return  (SVGPath) this path */
reset: function() {
this._path = '';
return this;
},

/* Move the pointer to a position.
@param  x         (number) x-coordinate to move to or
(number[][]) x-/y-coordinates to move to
@param  y         (number) y-coordinate to move to (omitted if x is array)
@param  relative  (boolean) true for coordinates relative to the current point,
false for coordinates being absolute
@return  (SVGPath) this path */
move: function(x, y, relative) {
relative = (isArray(x) ? y : relative);
return this._coords((relative ? 'm' : 'M'), x, y);
},

/* Draw a line to a position.
@param  x         (number) x-coordinate to move to or
(number[][]) x-/y-coordinates to move to
@param  y         (number) y-coordinate to move to (omitted if x is array)
@param  relative  (boolean) true for coordinates relative to the current point,
false for coordinates being absolute
@return  (SVGPath) this path */
line: function(x, y, relative) {
relative = (isArray(x) ? y : relative);
return this._coords((relative ? 'l' : 'L'), x, y);
},

/* Draw a horizontal line to a position.
@param  x         (number) x-coordinate to draw to or
(number[]) x-coordinates to draw to
@param  relative  (boolean) true for coordinates relative to the current point,
false for coordinates being absolute
@return  (SVGPath) this path */
horiz: function(x, relative) {
this._path += (relative ? 'h' : 'H') + (isArray(x) ? x.join(' ') : x);
return this;
},

/* Draw a vertical line to a position.
@param  y         (number) y-coordinate to draw to or
(number[]) y-coordinates to draw to
@param  relative  (boolean) true for coordinates relative to the current point,
false for coordinates being absolute
@return  (SVGPath) this path */
vert: function(y, relative) {
this._path += (relative ? 'v' : 'V') + (isArray(y) ? y.join(' ') : y);
return this;
},

/* Draw a cubic Bézier curve.
@param  x1        (number) x-coordinate of beginning control point or
(number[][]) x-/y-coordinates of control and end points to draw to
@param  y1        (number) y-coordinate of beginning control point (omitted if x1 is array)
@param  x2        (number) x-coordinate of ending control point (omitted if x1 is array)
@param  y2        (number) y-coordinate of ending control point (omitted if x1 is array)
@param  x         (number) x-coordinate of curve end (omitted if x1 is array)
@param  y         (number) y-coordinate of curve end (omitted if x1 is array)
@param  relative  (boolean) true for coordinates relative to the current point,
false for coordinates being absolute
@return  (SVGPath) this path */
curveC: function(x1, y1, x2, y2, x, y, relative) {
relative = (isArray(x1) ? y1 : relative);
return this._coords((relative ? 'c' : 'C'), x1, y1, x2, y2, x, y);
},

/* Continue a cubic Bézier curve.
Starting control point is the reflection of the previous end control point.
@param  x2        (number) x-coordinate of ending control point or
(number[][]) x-/y-coordinates of control and end points to draw to
@param  y2        (number) y-coordinate of ending control point (omitted if x2 is array)
@param  x         (number) x-coordinate of curve end (omitted if x2 is array)
@param  y         (number) y-coordinate of curve end (omitted if x2 is array)
@param  relative  (boolean) true for coordinates relative to the current point,
false for coordinates being absolute
@return  (SVGPath) this path */
smoothC: function(x2, y2, x, y, relative) {
relative = (isArray(x2) ? y2 : relative);
return this._coords((relative ? 's' : 'S'), x2, y2, x, y);
},

/* Draw a quadratic Bézier curve.
@param  x1        (number) x-coordinate of control point or
(number[][]) x-/y-coordinates of control and end points to draw to
@param  y1        (number) y-coordinate of control point (omitted if x1 is array)
@param  x         (number) x-coordinate of curve end (omitted if x1 is array)
@param  y         (number) y-coordinate of curve end (omitted if x1 is array)
@param  relative  (boolean) true for coordinates relative to the current point,
false for coordinates being absolute
@return  (SVGPath) this path */
curveQ: function(x1, y1, x, y, relative) {
relative = (isArray(x1) ? y1 : relative);
return this._coords((relative ? 'q' : 'Q'), x1, y1, x, y);
},

/* Continue a quadratic Bézier curve.
Control point is the reflection of the previous control point.
@param  x         (number) x-coordinate of curve end or
(number[][]) x-/y-coordinates of points to draw to
@param  y         (number) y-coordinate of curve end (omitted if x is array)
@param  relative  (boolean) true for coordinates relative to the current point,
false for coordinates being absolute
@return  (SVGPath) this path */
smoothQ: function(x, y, relative) {
relative = (isArray(x) ? y : relative);
return this._coords((relative ? 't' : 'T'), x, y);
},

/* Generate a path command with (a list of) coordinates. */
_coords: function(cmd, x1, y1, x2, y2, x3, y3) {
if (isArray(x1)) {
for (var i = 0; i < x1.length; i++) {
var cs = x1[i];
this._path += (i == 0 ? cmd : ' ') + cs[0] + ',' + cs[1] +
(cs.length < 4 ? '' : ' ' + cs[2] + ',' + cs[3] +
(cs.length < 6 ? '': ' ' + cs[4] + ',' + cs[5]));
}
}
else {
this._path += cmd + x1 + ',' + y1 +
(x2 == null ? '' : ' ' + x2 + ',' + y2 +
(x3 == null ? '' : ' ' + x3 + ',' + y3));
}
return this;
},

/* Draw an arc to a position.
@param  rx         (number) x-radius of arc or
(number/boolean[][]) x-/y-coordinates and flags for points to draw to
@param  ry         (number) y-radius of arc (omitted if rx is array)
@param  xRotate    (number) x-axis rotation (degrees, clockwise) (omitted if rx is array)
@param  large      (boolean) true to draw the large part of the arc,
false to draw the small part (omitted if rx is array)
@param  clockwise  (boolean) true to draw the clockwise arc,
false to draw the anti-clockwise arc (omitted if rx is array)
@param  x          (number) x-coordinate of arc end (omitted if rx is array)
@param  y          (number) y-coordinate of arc end (omitted if rx is array)
@param  relative   (boolean) true for coordinates relative to the current point,
false for coordinates being absolute
@return  (SVGPath) this path */
arc: function(rx, ry, xRotate, large, clockwise, x, y, relative) {
relative = (isArray(rx) ? ry : relative);
this._path += (relative ? 'a' : 'A');
if (isArray(rx)) {
for (var i = 0; i < rx.length; i++) {
var cs = rx[i];
this._path += (i == 0 ? '' : ' ') + cs[0] + ',' + cs[1] + ' ' +
cs[2] + ' ' + (cs[3] ? '1' : '0') + ',' +
(cs[4] ? '1' : '0') + ' ' + cs[5] + ',' + cs[6];
}
}
else {
this._path += rx + ',' + ry + ' ' + xRotate + ' ' +
(large ? '1' : '0') + ',' + (clockwise ? '1' : '0') + ' ' + x + ',' + y;
}
return this;
},

/* Close the current path.
@return  (SVGPath) this path */
close: function() {
this._path += 'z';
return this;
},

/* Return the string rendering of the specified path.
@return  (string) stringified path */
path: function() {
return this._path;
}
});

SVGPath.prototype.moveTo = SVGPath.prototype.move;
SVGPath.prototype.lineTo = SVGPath.prototype.line;
SVGPath.prototype.horizTo = SVGPath.prototype.horiz;
SVGPath.prototype.vertTo = SVGPath.prototype.vert;
SVGPath.prototype.curveCTo = SVGPath.prototype.curveC;
SVGPath.prototype.smoothCTo = SVGPath.prototype.smoothC;
SVGPath.prototype.curveQTo = SVGPath.prototype.curveQ;
SVGPath.prototype.smoothQTo = SVGPath.prototype.smoothQ;
SVGPath.prototype.arcTo = SVGPath.prototype.arc;

/* Helper to generate an SVG text object.
Obtain an instance from the SVGWrapper object.
String calls together to generate the text and use its value:
var text = root.createText();
root.text(null, x, y, text.string('This is ').
span('red', {fill: 'red'}).string('!'), {fill: 'blue'}); */
function SVGText() {
this._parts = []; // The components of the text object
}

$.extend(SVGText.prototype, {
/* Prepare to create a new text object.
@return  (SVGText) this text */
reset: function() {
this._parts = [];
return this;
},

/* Add a straight string value.
@param  value  (string) the actual text
@return  (SVGText) this text object */
string: function(value) {
this._parts[this._parts.length] = ['text', value];
return this;
},

/* Add a separate text span that has its own settings.
@param  value     (string) the actual text
@param  settings  (object) the settings for this text
@return  (SVGText) this text object */
span: function(value, settings) {
this._parts[this._parts.length] = ['tspan', value, settings];
return this;
},

/* Add a reference to a previously defined text string.
@param  id        (string) the ID of the actual text
@param  settings  (object) the settings for this text
@return  (SVGText) this text object */
ref: function(id, settings) {
this._parts[this._parts.length] = ['tref', id, settings];
return this;
},

/* Add text drawn along a path.
@param  id        (string) the ID of the path
@param  value     (string) the actual text
@param  settings  (object) the settings for this text
@return  (SVGText) this text object */
path: function(id, value, settings) {
this._parts[this._parts.length] = ['textpath', value,
$.extend({href: id}, settings || {})];
return this;
}
});

/* Attach the SVG functionality to a jQuery selection.
@param  command  (string) the command to run (optional, default 'attach')
@param  options  (object) the new settings to use for these SVG instances
@return jQuery (object) for chaining further calls */
$.fn.svg = function(options) {
var otherArgs = Array.prototype.slice.call(arguments, 1);
if (typeof options == 'string' && options == 'get') {
return $.svg['_' + options + 'SVG'].apply($.svg, [this[0]].concat(otherArgs));
}
return this.each(function() {
if (typeof options == 'string') {
$.svg['_' + options + 'SVG'].apply($.svg, [this].concat(otherArgs));
}
else {
$.svg._attachSVG(this, options || {});
}
});
};

/* Determine whether an object is an array. */
function isArray(a) {
return (a && a.constructor == Array);
}

// Singleton primary SVG interface
$.svg = new SVGManager();

})(jQuery);
;

/* http://keith-wood.name/svg.html
jQuery DOM compatibility for jQuery SVG v1.4.5.
Written by Keith Wood (kbwood{at}iinet.com.au) April 2009.
Dual licensed under the GPL (http://dev.jquery.com/browser/trunk/jquery/GPL-LICENSE.txt) and
MIT (http://dev.jquery.com/browser/trunk/jquery/MIT-LICENSE.txt) licenses.
Please attribute the author if you use it. */

(function($) { // Hide scope, no $ conflict

/* Support adding class names to SVG nodes. */
$.fn.addClass = function(origAddClass) {
return function(classNames) {
classNames = classNames || '';
return this.each(function() {
if ($.svg.isSVGElem(this)) {
var node = this;
$.each(classNames.split(/\s+/), function(i, className) {
var classes = (node.className ? node.className.baseVal : node.getAttribute('class'));
if ($.inArray(className, classes.split(/\s+/)) == -1) {
classes += (classes ? ' ' : '') + className;
(node.className ? node.className.baseVal = classes :
node.setAttribute('class',  classes));
}
});
}
else {
origAddClass.apply($(this), [classNames]);
}
});
};
}($.fn.addClass);

/* Support removing class names from SVG nodes. */
$.fn.removeClass = function(origRemoveClass) {
return function(classNames) {
classNames = classNames || '';
return this.each(function() {
if ($.svg.isSVGElem(this)) {
var node = this;
$.each(classNames.split(/\s+/), function(i, className) {
var classes = (node.className ? node.className.baseVal : node.getAttribute('class'));
classes = $.grep(classes.split(/\s+/), function(n, i) { return n != className; }).
join(' ');
(node.className ? node.className.baseVal = classes :
node.setAttribute('class', classes));
});
}
else {
origRemoveClass.apply($(this), [classNames]);
}
});
};
}($.fn.removeClass);

/* Support toggling class names on SVG nodes. */
$.fn.toggleClass = function(origToggleClass) {
return function(className, state) {
return this.each(function() {
if ($.svg.isSVGElem(this)) {
if (typeof state !== 'boolean') {
state = !$(this).hasClass(className);
}
$(this)[(state ? 'add' : 'remove') + 'Class'](className);
}
else {
origToggleClass.apply($(this), [className, state]);
}
});
};
}($.fn.toggleClass);

/* Support checking class names on SVG nodes. */
$.fn.hasClass = function(origHasClass) {
return function(className) {
className = className || '';
var found = false;
this.each(function() {
if ($.svg.isSVGElem(this)) {
var classes = (this.className ? this.className.baseVal :
this.getAttribute('class')).split(/\s+/);
found = ($.inArray(className, classes) > -1);
}
else {
found = (origHasClass.apply($(this), [className]));
}
return !found;
});
return found;
};
}($.fn.hasClass);

/* Support attributes on SVG nodes. */
$.fn.attr = function(origAttr) {
return function(name, value, type) {
if (typeof name === 'string' && value === undefined) {
var val = origAttr.apply(this, [name]);
if (val && val.baseVal && val.baseVal.numberOfItems != null) { // Multiple values
value = '';
val = val.baseVal;
if (name == 'transform') {
for (var i = 0; i < val.numberOfItems; i++) {
var item = val.getItem(i);
switch (item.type) {
case 1: value += ' matrix(' + item.matrix.a + ',' + item.matrix.b + ',' +
item.matrix.c + ',' + item.matrix.d + ',' +
item.matrix.e + ',' + item.matrix.f + ')';
break;
case 2: value += ' translate(' + item.matrix.e + ',' + item.matrix.f + ')'; break;
case 3: value += ' scale(' + item.matrix.a + ',' + item.matrix.d + ')'; break;
case 4: value += ' rotate(' + item.angle + ')'; break; // Doesn't handle new origin
case 5: value += ' skewX(' + item.angle + ')'; break;
case 6: value += ' skewY(' + item.angle + ')'; break;
}
}
val = value.substring(1);
}
else {
val = val.getItem(0).valueAsString;
}
}
return (val && val.baseVal ? val.baseVal.valueAsString : val);
}

var options = name;
if (typeof name === 'string') {
options = {};
options[name] = value;
}
return this.each(function() {
if ($.svg.isSVGElem(this)) {
for (var n in options) {
var val = ($.isFunction(options[n]) ? options[n]() : options[n]);
(type ? this.style[n] = val : this.setAttribute(n, val));
}
}
else {
origAttr.apply($(this), [name, value, type]);
}
});
};
}($.fn.attr);

/* Support removing attributes on SVG nodes. */
$.fn.removeAttr = function(origRemoveAttr) {
return function(name) {
return this.each(function() {
if ($.svg.isSVGElem(this)) {
(this[name] && this[name].baseVal ? this[name].baseVal.value = '' :
this.setAttribute(name, ''));
}
else {
origRemoveAttr.apply($(this), [name]);
}
});
};
}($.fn.removeAttr);

/* Add numeric only properties. */
$.extend($.cssNumber, {
'stopOpacity': true,
'strokeMitrelimit': true,
'strokeOpacity': true
});

/* Support retrieving CSS/attribute values on SVG nodes. */
if ($.cssProps) {
$.css = function(origCSS) {
return function(elem, name, extra) {
var value = (name.match(/^svg.*/) ? $(elem).attr($.cssProps[name] || name) : '');
return value || origCSS(elem, name, extra);
};
}($.css);
}

/* Determine if any nodes are SVG nodes. */
function anySVG(checkSet) {
for (var i = 0; i < checkSet.length; i++) {
if (checkSet[i].nodeType == 1 && checkSet[i].namespaceURI == $.svg.svgNS) {
return true;
}
}
return false;
}

/* Update Sizzle selectors. */

$.expr.relative['+'] = function(origRelativeNext) {
return function(checkSet, part, isXML) {
origRelativeNext(checkSet, part, isXML || anySVG(checkSet));
};
}($.expr.relative['+']);

$.expr.relative['>'] = function(origRelativeChild) {
return function(checkSet, part, isXML) {
origRelativeChild(checkSet, part, isXML || anySVG(checkSet));
};
}($.expr.relative['>']);

$.expr.relative[''] = function(origRelativeDescendant) {
return function(checkSet, part, isXML) {
origRelativeDescendant(checkSet, part, isXML || anySVG(checkSet));
};
}($.expr.relative['']);

$.expr.relative['~'] = function(origRelativeSiblings) {
return function(checkSet, part, isXML) {
origRelativeSiblings(checkSet, part, isXML || anySVG(checkSet));
};
}($.expr.relative['~']);

$.expr.find.ID = function(origFindId) {
return function(match, context, isXML) {
return ($.svg.isSVGElem(context) ?
[context.ownerDocument.getElementById(match[1])] :
origFindId(match, context, isXML));
};
}($.expr.find.ID);

var div = document.createElement('div');
div.appendChild(document.createComment(''));
if (div.getElementsByTagName('*').length > 0) { // Make sure no comments are found
$.expr.find.TAG = function(match, context) {
var results = context.getElementsByTagName(match[1]);
if (match[1] === '*') { // Filter out possible comments
var tmp = [];
for (var i = 0; results[i] || results.item(i); i++) {
if ((results[i] || results.item(i)).nodeType === 1) {
tmp.push(results[i] || results.item(i));
}
}
results = tmp;
}
return results;
};
}

$.expr.preFilter.CLASS = function(match, curLoop, inplace, result, not, isXML) {
match = ' ' + match[1].replace(/\\/g, '') + ' ';
if (isXML) {
return match;
}
for (var i = 0, elem = {}; elem != null; i++) {
elem = curLoop[i];
if (!elem) {
try {
elem = curLoop.item(i);
}
catch (e) {
// Ignore
}
}
if (elem) {
var className = (!$.svg.isSVGElem(elem) ? elem.className :
(elem.className ? elem.className.baseVal : '') || elem.getAttribute('class'));
if (not ^ (className && (' ' + className + ' ').indexOf(match) > -1)) {
if (!inplace)
result.push(elem);
}
else if (inplace) {
curLoop[i] = false;
}
}
}
return false;
};

$.expr.filter.CLASS = function(elem, match) {
var className = (!$.svg.isSVGElem(elem) ? elem.className :
(elem.className ? elem.className.baseVal : elem.getAttribute('class')));
return (' ' + className + ' ').indexOf(match) > -1;
};

$.expr.filter.ATTR = function(origFilterAttr) {
return function(elem, match) {
var handler = null;
if ($.svg.isSVGElem(elem)) {
handler = match[1];
$.expr.attrHandle[handler] = function(elem){
var attr = elem.getAttribute(handler);
return attr && attr.baseVal || attr;
};
}
var filter = origFilterAttr(elem, match);
if (handler) {
$.expr.attrHandle[handler] = null;
}
return filter;
};
}($.expr.filter.ATTR);

/*
In the removeData function (line 1881, v1.7.2):

if ( jQuery.support.deleteExpando ) {
delete elem[ internalKey ];
} else {
try { // SVG
elem.removeAttribute( internalKey );
} catch (e) {
elem[ internalKey ] = null;
}
}

In the event.add function (line 2985, v1.7.2):

if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
// Bind the global event handler to the element
try { // SVG
elem.addEventListener( type, eventHandle, false );
} catch(e) {
if ( elem.attachEvent ) {
elem.attachEvent( "on" + type, eventHandle );
}
}
}

In the event.remove function (line 3074, v1.7.2):

if ( !special.teardown || special.teardown.call( elem, namespaces ) === false ) {
try { // SVG
elem.removeEventListener(type, elemData.handle, false);
}
catch (e) {
if (elem.detachEvent) {
elem.detachEvent("on" + type, elemData.handle);
}
}
}

In the event.fix function (line 3394, v1.7.2):

if (event.target.namespaceURI == 'http://www.w3.org/2000/svg') { // SVG
event.button = [1, 4, 2][event.button];
}

// Add which for click: 1 === left; 2 === middle; 3 === right
// Note: button is not normalized, so don't use it
if ( !event.which && button !== undefined ) {
event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
}

In the Sizzle function (line 4083, v1.7.2):

if ( toString.call(checkSet) === "[object Array]" ) {
if ( !prune ) {
results.push.apply( results, checkSet );

} else if ( context && context.nodeType === 1 ) {
for ( i = 0; checkSet[i] != null; i++ ) {
if ( checkSet[i] && (checkSet[i] === true || checkSet[i].nodeType === 1 && Sizzle.contains(context, checkSet[i])) ) {
results.push( set[i] || set.item(i) ); // SVG
}
}

} else {
for ( i = 0; checkSet[i] != null; i++ ) {
if ( checkSet[i] && checkSet[i].nodeType === 1 ) {
results.push( set[i] || set.item(i) ); // SVG
}
}
}
} else {...

In the fallback for the Sizzle makeArray function (line 4877, v1.7.2):

if ( toString.call(array) === "[object Array]" ) {
Array.prototype.push.apply( ret, array );

} else {
if ( typeof array.length === "number" ) {
for ( var l = array.length; i &lt; l; i++ ) {
ret.push( array[i] || array.item(i) ); // SVG
}

} else {
for ( ; array[i]; i++ ) {
ret.push( array[i] );
}
}
}

In the jQuery.cleandata function (line 6538, v1.7.2):

if ( deleteExpando ) {
delete elem[ jQuery.expando ];

} else {
try { // SVG
elem.removeAttribute( jQuery.expando );
} catch (e) {
// Ignore
}
}

In the fallback getComputedStyle function (line 6727, v1.7.2):

defaultView = (elem.ownerDocument ? elem.ownerDocument.defaultView : elem.defaultView); // SVG
if ( defaultView &&
(computedStyle = defaultView.getComputedStyle( elem, null )) ) {

ret = computedStyle.getPropertyValue( name );
...

*/

})(jQuery);
;

var Configuration = (function(window, undefined) {
var abbrevsOn = true;
var textBackgrounds = "striped";
var svgWidth = '100%';
var rapidModeOn = false;
var confirmModeOn = true;
var autorefreshOn = false;

var visual = {
margin: { x: 2, y: 1 },
arcTextMargin: 1,
boxSpacing: 1,
curlyHeight: 4,
arcSpacing: 9, //10;
arcStartHeight: 19 //23; //25;
}

return {
abbrevsOn: abbrevsOn,
textBackgrounds: textBackgrounds,
visual: visual,
svgWidth: svgWidth,
rapidModeOn: rapidModeOn,
confirmModeOn: confirmModeOn,
autorefreshOn: autorefreshOn
}
})(window);
;

// -*- Mode: JavaScript; tab-width: 2; indent-tabs-mode: nil; -*-
// vim:set ft=javascript ts=2 sw=2 sts=2 cindent:
var Util = (function(window, undefined) {

var monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

var cmp = function(a,b) {
return a < b ? -1 : a > b ? 1 : 0;
}

var cmpArrayOnFirstElement = function(a,b) {
a = a[0];
b = b[0];
return a < b ? -1 : a > b ? 1 : 0;
}

var unitAgo = function(n, unit) {
if (n == 1) return "" + n + " " + unit + " ago";
return "" + n + " " + unit + "s ago";
};

var formatTimeAgo = function(time) {
if (time == -1000) {
return "never"; // FIXME make the server return the server time!
}

var nowDate = new Date();
var now = nowDate.getTime();
var diff = Math.floor((now - time) / 1000);
if (!diff) return "just now";
if (diff < 60) return unitAgo(diff, "second");
diff = Math.floor(diff / 60);
if (diff < 60) return unitAgo(diff, "minute");
diff = Math.floor(diff / 60);
if (diff < 24) return unitAgo(diff, "hour");
diff = Math.floor(diff / 24);
if (diff < 7) return unitAgo(diff, "day");
if (diff < 28) return unitAgo(Math.floor(diff / 7), "week");
var thenDate = new Date(time);
var result = thenDate.getDate() + ' ' + monthNames[thenDate.getMonth()];
if (thenDate.getYear() != nowDate.getYear()) {
result += ' ' + thenDate.getFullYear();
}
return result;
}

var realBBox = function(span) {
var box = span.rect.getBBox();
var chunkTranslation = span.chunk.translation;
var rowTranslation = span.chunk.row.translation;
box.x += chunkTranslation.x + rowTranslation.x;
box.y += chunkTranslation.y + rowTranslation.y;
return box;
}

var escapeHTML = function(str) {
return str.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
}

var escapeHTMLandQuotes = function(str) {
return str.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/\"/g,'&quot;');
}

var escapeHTMLwithNewlines = function(str) {
return str.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/\n/g,'<br/>');
}

var escapeQuotes = function(str) {
// we only use double quotes for HTML attributes
return str.replace(/\"/g,'&quot;');
}

var getSpanLabels = function(spanTypes, spanType) {
var type = spanTypes[spanType];
return type && type.labels || [];
}

var spanDisplayForm = function(spanTypes, spanType) {
var labels = getSpanLabels(spanTypes, spanType);
return labels[0] || spanType;
}

var getArcLabels = function(spanTypes, spanType, arcType, relationTypesHash) {
var type = spanTypes[spanType];
var arcTypes = type && type.arcs || [];
var arcDesc = null;
// also consider matches without suffix number, if any
var noNumArcType;
if (arcType) {
var splitType = arcType.match(/^(.*?)(\d*)$/);
noNumArcType = splitType[1];
}
$.each(arcTypes, function(arcno, arcDescI) {
if (arcDescI.type == arcType || arcDescI.type == noNumArcType) {
arcDesc = arcDescI;
return false;
}
});
// fall back to relation types for unconfigured or missing def
if (!arcDesc) {
arcDesc = $.extend({}, relationTypesHash[arcType] || relationTypesHash[noNumArcType]);
}
return arcDesc && arcDesc.labels || [];
}

var arcDisplayForm = function(spanTypes, spanType, arcType, relationTypesHash) {
var labels = getArcLabels(spanTypes, spanType, arcType, relationTypesHash);
return labels[0] || arcType;
}

// TODO: switching to use of $.param(), this function should
// be deprecated and removed.
var objectToUrlStr = function(o) {
a = [];
$.each(o, function(key,value) {
a.push(key+"="+encodeURIComponent(value));
});
return a.join("&");
}

// color name RGB list, converted from
// http://www.w3schools.com/html/html_colornames.asp
// with perl as
//     perl -e 'print "var colors = {\n"; while(<>) { /(\S+)\s+\#([0-9a-z]{2})([0-9a-z]{2})([0-9a-z]{2})\s*/i or die "Failed to parse $_"; ($r,$g,$b)=(hex($2),hex($3),hex($4)); print "    '\''",lc($1),"'\'':\[$r,$g,$b\],\n" } print "};\n" '
var colors = {
'aliceblue':[240,248,255],
'antiquewhite':[250,235,215],
'aqua':[0,255,255],
'aquamarine':[127,255,212],
'azure':[240,255,255],
'beige':[245,245,220],
'bisque':[255,228,196],
'black':[0,0,0],
'blanchedalmond':[255,235,205],
'blue':[0,0,255],
'blueviolet':[138,43,226],
'brown':[165,42,42],
'burlywood':[222,184,135],
'cadetblue':[95,158,160],
'chartreuse':[127,255,0],
'chocolate':[210,105,30],
'coral':[255,127,80],
'cornflowerblue':[100,149,237],
'cornsilk':[255,248,220],
'crimson':[220,20,60],
'cyan':[0,255,255],
'darkblue':[0,0,139],
'darkcyan':[0,139,139],
'darkgoldenrod':[184,134,11],
'darkgray':[169,169,169],
'darkgrey':[169,169,169],
'darkgreen':[0,100,0],
'darkkhaki':[189,183,107],
'darkmagenta':[139,0,139],
'darkolivegreen':[85,107,47],
'darkorange':[255,140,0],
'darkorchid':[153,50,204],
'darkred':[139,0,0],
'darksalmon':[233,150,122],
'darkseagreen':[143,188,143],
'darkslateblue':[72,61,139],
'darkslategray':[47,79,79],
'darkslategrey':[47,79,79],
'darkturquoise':[0,206,209],
'darkviolet':[148,0,211],
'deeppink':[255,20,147],
'deepskyblue':[0,191,255],
'dimgray':[105,105,105],
'dimgrey':[105,105,105],
'dodgerblue':[30,144,255],
'firebrick':[178,34,34],
'floralwhite':[255,250,240],
'forestgreen':[34,139,34],
'fuchsia':[255,0,255],
'gainsboro':[220,220,220],
'ghostwhite':[248,248,255],
'gold':[255,215,0],
'goldenrod':[218,165,32],
'gray':[128,128,128],
'grey':[128,128,128],
'green':[0,128,0],
'greenyellow':[173,255,47],
'honeydew':[240,255,240],
'hotpink':[255,105,180],
'indianred':[205,92,92],
'indigo':[75,0,130],
'ivory':[255,255,240],
'khaki':[240,230,140],
'lavender':[230,230,250],
'lavenderblush':[255,240,245],
'lawngreen':[124,252,0],
'lemonchiffon':[255,250,205],
'lightblue':[173,216,230],
'lightcoral':[240,128,128],
'lightcyan':[224,255,255],
'lightgoldenrodyellow':[250,250,210],
'lightgray':[211,211,211],
'lightgrey':[211,211,211],
'lightgreen':[144,238,144],
'lightpink':[255,182,193],
'lightsalmon':[255,160,122],
'lightseagreen':[32,178,170],
'lightskyblue':[135,206,250],
'lightslategray':[119,136,153],
'lightslategrey':[119,136,153],
'lightsteelblue':[176,196,222],
'lightyellow':[255,255,224],
'lime':[0,255,0],
'limegreen':[50,205,50],
'linen':[250,240,230],
'magenta':[255,0,255],
'maroon':[128,0,0],
'mediumaquamarine':[102,205,170],
'mediumblue':[0,0,205],
'mediumorchid':[186,85,211],
'mediumpurple':[147,112,216],
'mediumseagreen':[60,179,113],
'mediumslateblue':[123,104,238],
'mediumspringgreen':[0,250,154],
'mediumturquoise':[72,209,204],
'mediumvioletred':[199,21,133],
'midnightblue':[25,25,112],
'mintcream':[245,255,250],
'mistyrose':[255,228,225],
'moccasin':[255,228,181],
'navajowhite':[255,222,173],
'navy':[0,0,128],
'oldlace':[253,245,230],
'olive':[128,128,0],
'olivedrab':[107,142,35],
'orange':[255,165,0],
'orangered':[255,69,0],
'orchid':[218,112,214],
'palegoldenrod':[238,232,170],
'palegreen':[152,251,152],
'paleturquoise':[175,238,238],
'palevioletred':[216,112,147],
'papayawhip':[255,239,213],
'peachpuff':[255,218,185],
'peru':[205,133,63],
'pink':[255,192,203],
'plum':[221,160,221],
'powderblue':[176,224,230],
'purple':[128,0,128],
'red':[255,0,0],
'rosybrown':[188,143,143],
'royalblue':[65,105,225],
'saddlebrown':[139,69,19],
'salmon':[250,128,114],
'sandybrown':[244,164,96],
'seagreen':[46,139,87],
'seashell':[255,245,238],
'sienna':[160,82,45],
'silver':[192,192,192],
'skyblue':[135,206,235],
'slateblue':[106,90,205],
'slategray':[112,128,144],
'slategrey':[112,128,144],
'snow':[255,250,250],
'springgreen':[0,255,127],
'steelblue':[70,130,180],
'tan':[210,180,140],
'teal':[0,128,128],
'thistle':[216,191,216],
'tomato':[255,99,71],
'turquoise':[64,224,208],
'violet':[238,130,238],
'wheat':[245,222,179],
'white':[255,255,255],
'whitesmoke':[245,245,245],
'yellow':[255,255,0],
'yellowgreen':[154,205,50]
};

// color parsing function originally from
// http://plugins.jquery.com/files/jquery.color.js.txt
// (with slight modifications)

// Parse strings looking for color tuples [255,255,255]
var rgbNumRE = /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/;
var rgbPercRE = /rgb\(\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*\)/;
var rgbHash6RE = /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/;
var rgbHash3RE = /#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])/;

var strToRgb = function(color) {
var result;

// Check if we're already dealing with an array of colors
//         if ( color && color.constructor == Array && color.length == 3 )
//             return color;

// Look for rgb(num,num,num)
if (result = rgbNumRE.exec(color))
return [parseInt(result[1]), parseInt(result[2]), parseInt(result[3])];

// Look for rgb(num%,num%,num%)
if (result = rgbPercRE.exec(color))
return [parseFloat(result[1])*2.55, parseFloat(result[2])*2.55, parseFloat(result[3])*2.55];

// Look for #a0b1c2
if (result = rgbHash6RE.exec(color))
return [parseInt(result[1],16), parseInt(result[2],16), parseInt(result[3],16)];

// Look for #fff
if (result = rgbHash3RE.exec(color))
return [parseInt(result[1]+result[1],16), parseInt(result[2]+result[2],16), parseInt(result[3]+result[3],16)];

// Otherwise, we're most likely dealing with a named color
return colors[$.trim(color).toLowerCase()];
}

var rgbToStr = function(rgb) {
// TODO: there has to be a better way, even in JS
var r = Math.floor(rgb[0]).toString(16);
var g = Math.floor(rgb[1]).toString(16);
var b = Math.floor(rgb[2]).toString(16);
// pad
r = r.length < 2 ? '0' + r : r;
g = g.length < 2 ? '0' + g : g;
b = b.length < 2 ? '0' + b : b;
return ('#'+r+g+b);
}

// Functions rgbToHsl and hslToRgb originally from
// http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript
// implementation of functions in Wikipedia
// (with slight modifications)

// RGB to HSL color conversion
var rgbToHsl = function(rgb) {
var r = rgb[0]/255, g = rgb[1]/255, b = rgb[2]/255;
var max = Math.max(r, g, b), min = Math.min(r, g, b);
var h, s, l = (max + min) / 2;

if (max == min) {
h = s = 0; // achromatic
} else {
var d = max - min;
s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
switch (max) {
case r: h = (g - b) / d + (g < b ? 6 : 0); break;
case g: h = (b - r) / d + 2; break;
case b: h = (r - g) / d + 4; break;
}
h /= 6;
}

return [h, s, l];
}

var hue2rgb = function(p, q, t) {
if (t < 0) t += 1;
if (t > 1) t -= 1;
if (t < 1/6) return p + (q - p) * 6 * t;
if (t < 1/2) return q;
if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
return p;
}

var hslToRgb = function(hsl) {
var h = hsl[0], s = hsl[1], l = hsl[2];

var r, g, b;

if (s == 0) {
r = g = b = l; // achromatic
} else {
var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
var p = 2 * l - q;
r = hue2rgb(p, q, h + 1/3);
g = hue2rgb(p, q, h);
b = hue2rgb(p, q, h - 1/3);
}

return [r * 255, g * 255, b * 255];
}

var adjustLightnessCache = {};

// given color string and -1<=adjust<=1, returns color string
// where lightness (in the HSL sense) is adjusted by the given
// amount, the larger the lighter: -1 gives black, 1 white, and 0
// the given color.
var adjustColorLightness = function(colorstr, adjust) {
if (!(colorstr in adjustLightnessCache)) {
adjustLightnessCache[colorstr] = {}
}
if (!(adjust in adjustLightnessCache[colorstr])) {
var rgb = strToRgb(colorstr);
if (rgb === undefined) {
// failed color string conversion; just return the input
adjustLightnessCache[colorstr][adjust] = colorstr;
} else {
var hsl = rgbToHsl(rgb);
if (adjust > 0.0) {
hsl[2] = 1.0 - ((1.0-hsl[2])*(1.0-adjust));
} else {
hsl[2] = (1.0+adjust)*hsl[2];
}
var lightRgb = hslToRgb(hsl);
adjustLightnessCache[colorstr][adjust] = rgbToStr(lightRgb);
}
}
return adjustLightnessCache[colorstr][adjust];
}

// Partially stolen from: http://documentcloud.github.com/underscore/
// MIT-License
// TODO: Mention in LICENSE.md
var isEqual = function(a, b) {
// Check object identity.
if (a === b) return true;
// Different types?
var atype = typeof(a), btype = typeof(b);
if (atype != btype) return false;
// Basic equality test (watch out for coercions).
if (a == b) return true;
// One is falsy and the other truthy.
if ((!a && b) || (a && !b)) return false;
// If a is not an object by this point, we can't handle it.
if (atype !== 'object') return false;
// Check for different array lengths before comparing contents.
if (a.length && (a.length !== b.length)) return false;
// Nothing else worked, deep compare the contents.
for (var key in b) if (!(key in a)) return false;
// Recursive comparison of contents.
for (var key in a) if (!(key in b) || !isEqual(a[key], b[key])) return false;
return true;
};

var keyValRE = /^([^=]+)=(.*)$/; // key=value
var isDigitsRE = /^[0-9]+$/;

var deparam = function(str) {
var args = str.split('&');
var len = args.length;
if (!len) return null;
var result = {};
for (var i = 0; i < len; i++) {
var parts = args[i].match(keyValRE);
if (!parts || parts.length != 3) break;
var val = [];
var arr = parts[2].split(',');
var sublen = arr.length;
for (var j = 0; j < sublen; j++) {
var innermost = [];
// map empty arguments ("" in URL) to empty arrays
// (innermost remains [])
if (arr[j].length) {
var arrsplit = arr[j].split('~');
var subsublen = arrsplit.length;
for (var k = 0; k < subsublen; k++) {
if(arrsplit[k].match(isDigitsRE)) {
// convert digits into ints ...
innermost.push(parseInt(arrsplit[k], 10));
}
else {
// ... anything else remains a string.
innermost.push(arrsplit[k]);
}
}
}
val.push(innermost);
}
result[parts[1]] = val;
}
return result;
};

var paramArray = function(val) {
val = val || [];
var len = val.length;
var arr = [];
for (var i = 0; i < len; i++) {
if ($.isArray(val[i])) {
arr.push(val[i].join('~'));
} else {
// non-array argument; this is an error from the caller
console.error('param: Error: received non-array-in-array argument [', i, ']', ':', val[i], '(fix caller)');
}
}
return arr;
};

var param = function(args) {
if (!args) return '';
var vals = [];
for (var key in args) {
if (args.hasOwnProperty(key)) {
var val = args[key];
if (val == undefined) {
console.error('Error: received argument', key, 'with value', val);
continue;
}
// values normally expected to be arrays, but some callers screw
// up, so check
if ($.isArray(val)) {
var arr = paramArray(val);
vals.push(key + '=' + arr.join(','));
} else {
// non-array argument; this is an error from the caller
console.error('param: Error: received non-array argument', key, ':', val, '(fix caller)');
}
}
}
return vals.join('&');
};

var profiles = {};
var profileStarts = {};
var profileOn = false;
var profileEnable = function(on) {
if (on === undefined) on = true;
profileOn = on;
}; // profileEnable
var profileClear = function() {
if (!profileOn) return;
profiles = {};
profileStarts = {};
}; // profileClear
var profileStart = function(label) {
if (!profileOn) return;
profileStarts[label] = new Date();
}; // profileStart
var profileEnd = function(label) {
if (!profileOn) return;
var profileElapsed = new Date() - profileStarts[label]
if (!profiles[label]) profiles[label] = 0;
profiles[label] += profileElapsed;
}; // profileEnd
var profileReport = function() {
if (!profileOn) return;
if (window.console) {
$.each(profiles, function(label, time) {
console.log("profile " + label, time);
});
console.log("-------");
}
}; // profileReport

// container: ID or jQuery element
// collData: the collection data (in the format of the result of
//   http://.../brat/ajax.cgi?action=getCollectionInformation&collection=...
// docData: the document data (in the format of the result of
//   http://.../brat/ajax.cgi?action=getDocument&collection=...&document=...
// returns the embedded visualizer's dispatcher object
var dispatcher = null;
var embed = function(container, collData, docData, webFontURLs) {
dispatcher = new Dispatcher();
var visualizer = new Visualizer(dispatcher, container, webFontURLs);
docData.collection = null;
dispatcher.post('collectionLoaded', [collData]);
dispatcher.post('requestRenderData', [docData]);
};

var updateData = function( container, collData, docData, webFontURLs ) {
docData.collection = null;
dispatcher.post('collectionLoaded', [collData]);
dispatcher.post('requestRenderData', [docData]);
return dispatcher;
};


// container: ID or jQuery element
// collDataURL: the URL of the collection data, or collection data
//   object (if pre-fetched)
// docDataURL: the url of the document data (if pre-fetched, use
//   simple `embed` instead)
// callback: optional; the callback to call afterwards; it will be
//   passed the embedded visualizer's dispatcher object
var embedByURL = function(container, collDataURL, docDataURL, callback) {
var collData, docData;
var handler = function() {
if (collData && docData) {
var dispatcher = embed(container, collData, docData);
if (callback) callback(dispatcher);
}
};
if (typeof(container) == 'string') {
$.getJSON(collDataURL, function(data) { collData = data; handler(); });
} else {
collData = collDataURL;
}
$.getJSON(docDataURL, function(data) { docData = data; handler(); });
};


return {
profileEnable: profileEnable,
profileClear: profileClear,
profileStart: profileStart,
profileEnd: profileEnd,
profileReport: profileReport,
formatTimeAgo: formatTimeAgo,
realBBox: realBBox,
getSpanLabels: getSpanLabels,
spanDisplayForm: spanDisplayForm,
getArcLabels: getArcLabels,
arcDisplayForm: arcDisplayForm,
escapeQuotes: escapeQuotes,
escapeHTML: escapeHTML,
escapeHTMLandQuotes: escapeHTMLandQuotes,
escapeHTMLwithNewlines: escapeHTMLwithNewlines,
cmp: cmp,
rgbToHsl: rgbToHsl,
hslToRgb: hslToRgb,
adjustColorLightness: adjustColorLightness,
objectToUrlStr: objectToUrlStr,
isEqual: isEqual,
paramArray: paramArray,
param: param,
deparam: deparam,
embed: embed,
updateData: updateData,
embedByURL: embedByURL
};

})(window);
;

// -*- Mode: JavaScript; tab-width: 2; indent-tabs-mode: nil; -*-
// vim:set ft=javascript ts=2 sw=2 sts=2 cindent:

var AnnotationLog = (function(window, undefined) {
var AnnotationLog = function(dispatcher) {
var annotationLoggingOn = false;
var currentCollection = null;
var currentDocument = null;
var currentArguments = null;

var rememberLoggingState = function(response) {
annotationLoggingOn = response.annotation_logging;
};

var rememberCurrent = function(_collection, _document, _arguments) {
currentCollection = _collection;
currentDocument = _document;
currentArguments = _arguments;
};

var logAction = function(_action) {
if (!annotationLoggingOn) {
// logging not requested for current collection
return false;
} else {
dispatcher.post('ajax', [ {
action: 'logAnnotatorAction',
collection: currentCollection,
'document': currentDocument,
log: _action
}, null]);
}
}

dispatcher.
on('collectionLoaded', rememberLoggingState).
on('current', rememberCurrent).
on('logAction', logAction);
}

return AnnotationLog;
})(window);
;

/*
* Copyright 2012 Small Batch, Inc.
*
* Licensed under the Apache License, Version 2.0 (the "License"); you may not
* use this file except in compliance with the License. You may obtain a copy of
* the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
* WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
* License for the specific language governing permissions and limitations under
* the License.
*/
;(function(window,document,undefined){
function i(a){return function(){return this[a]}}var j;function n(a,b){var c=arguments.length>2?Array.prototype.slice.call(arguments,2):[];return function(){c.push.apply(c,arguments);return b.apply(a,c)}};function o(a,b){this.K=a;this.c=b}o.prototype.createElement=function(a,b,c){a=this.K.createElement(a);if(b)for(var d in b)if(b.hasOwnProperty(d))d=="style"?q(this,a,b[d]):a.setAttribute(d,b[d]);c&&a.appendChild(this.K.createTextNode(c));return a};function r(a,b,c){a=a.K.getElementsByTagName(b)[0];if(!a)a=document.documentElement;if(a&&a.lastChild){a.insertBefore(c,a.lastChild);return true}return false}function aa(a,b){function c(){document.body?b():setTimeout(c,0)}c()}
function s(a,b){if(b.parentNode){b.parentNode.removeChild(b);return true}return false}function t(a,b){return a.createElement("link",{rel:"stylesheet",href:b})}function u(a,b){return a.createElement("script",{src:b})}function v(a,b,c){a=b.className.split(/\s+/);for(var d=0,e=a.length;d<e;d++)if(a[d]==c)return;a.push(c);b.className=a.join(" ").replace(/^\s+/,"")}
function w(a,b,c){a=b.className.split(/\s+/);for(var d=[],e=0,f=a.length;e<f;e++)a[e]!=c&&d.push(a[e]);b.className=d.join(" ").replace(/^\s+/,"").replace(/\s+$/,"")}function x(a,b,c){a=b.className.split(/\s+/);b=0;for(var d=a.length;b<d;b++)if(a[b]==c)return true;return false}function q(a,b,c){if(a.c.getName()=="MSIE")b.style.cssText=c;else b.setAttribute("style",c)};function y(a,b,c,d,e,f,g,h){this.Ba=a;this.Ha=b;this.oa=c;this.na=d;this.Ea=e;this.Da=f;this.ma=g;this.Ia=h}j=y.prototype;j.getName=i("Ba");j.xa=i("Ha");j.Y=i("oa");j.ua=i("na");j.va=i("Ea");j.wa=i("Da");j.ta=i("ma");j.w=i("Ia");function z(a,b){this.c=a;this.k=b}var ba=new y("Unknown","Unknown","Unknown","Unknown","Unknown","Unknown",undefined,false);z.prototype.parse=function(){return this.c.indexOf("MSIE")!=-1?ca(this):this.c.indexOf("Opera")!=-1?da(this):this.c.indexOf("AppleWebKit")!=-1?ea(this):this.c.indexOf("Gecko")!=-1?fa(this):ba};
function A(a){var b=C(a,a.c,/(iPod|iPad|iPhone|Android)/,1);if(b!="")return b;a=C(a,a.c,/(Linux|Mac_PowerPC|Macintosh|Windows)/,1);if(a!=""){if(a=="Mac_PowerPC")a="Macintosh";return a}return"Unknown"}function D(a){var b=C(a,a.c,/(OS X|Windows NT|Android) ([^;)]+)/,2);if(b)return b;if(b=C(a,a.c,/(iPhone )?OS ([\d_]+)/,2))return b;if(a=C(a,a.c,/Linux ([i\d]+)/,1))return a;return"Unknown"}
function ca(a){var b=C(a,a.c,/(MSIE [\d\w\.]+)/,1);if(b!=""){var c=b.split(" ");b=c[0];c=c[1];return new y(b,c,b,c,A(a),D(a),E(a,a.k),F(a,c)>=6)}return new y("MSIE","Unknown","MSIE","Unknown",A(a),D(a),E(a,a.k),false)}
function da(a){var b="Unknown",c="Unknown",d=C(a,a.c,/(Presto\/[\d\w\.]+)/,1);if(d!=""){c=d.split("/");b=c[0];c=c[1]}else{if(a.c.indexOf("Gecko")!=-1)b="Gecko";d=C(a,a.c,/rv:([^\)]+)/,1);if(d!="")c=d}if(a.c.indexOf("Version/")!=-1){d=C(a,a.c,/Version\/([\d\.]+)/,1);if(d!="")return new y("Opera",d,b,c,A(a),D(a),E(a,a.k),F(a,d)>=10)}d=C(a,a.c,/Opera[\/ ]([\d\.]+)/,1);if(d!="")return new y("Opera",d,b,c,A(a),D(a),E(a,a.k),F(a,d)>=10);return new y("Opera","Unknown",b,c,A(a),D(a),E(a,a.k),false)}
function ea(a){var b=A(a),c=D(a),d=C(a,a.c,/AppleWebKit\/([\d\.\+]+)/,1);if(d=="")d="Unknown";var e="Unknown";if(a.c.indexOf("Chrome")!=-1)e="Chrome";else if(a.c.indexOf("Safari")!=-1)e="Safari";else if(a.c.indexOf("AdobeAIR")!=-1)e="AdobeAIR";var f="Unknown";if(a.c.indexOf("Version/")!=-1)f=C(a,a.c,/Version\/([\d\.\w]+)/,1);else if(e=="Chrome")f=C(a,a.c,/Chrome\/([\d\.]+)/,1);else if(e=="AdobeAIR")f=C(a,a.c,/AdobeAIR\/([\d\.]+)/,1);var g=false;if(e=="AdobeAIR"){g=C(a,f,/\d+\.(\d+)/,1);g=F(a,f)>2||
F(a,f)==2&&parseInt(g,10)>=5}else{g=C(a,d,/\d+\.(\d+)/,1);g=F(a,d)>=526||F(a,d)>=525&&parseInt(g,10)>=13}return new y(e,f,"AppleWebKit",d,b,c,E(a,a.k),g)}
function fa(a){var b="Unknown",c="Unknown",d=false;if(a.c.indexOf("Firefox")!=-1){b="Firefox";var e=C(a,a.c,/Firefox\/([\d\w\.]+)/,1);if(e!=""){d=C(a,e,/\d+\.(\d+)/,1);c=e;d=e!=""&&F(a,e)>=3&&parseInt(d,10)>=5}}else if(a.c.indexOf("Mozilla")!=-1)b="Mozilla";e=C(a,a.c,/rv:([^\)]+)/,1);if(e=="")e="Unknown";else if(!d){d=F(a,e);var f=parseInt(C(a,e,/\d+\.(\d+)/,1),10),g=parseInt(C(a,e,/\d+\.\d+\.(\d+)/,1),10);d=d>1||d==1&&f>9||d==1&&f==9&&g>=2||e.match(/1\.9\.1b[123]/)!=null||e.match(/1\.9\.1\.[\d\.]+/)!=
null}return new y(b,c,"Gecko",e,A(a),D(a),E(a,a.k),d)}function F(a,b){a=C(a,b,/(\d+)/,1);if(a!="")return parseInt(a,10);return-1}function C(a,b,c,d){if((a=b.match(c))&&a[d])return a[d];return""}function E(a,b){if(b.documentMode)return b.documentMode};function ga(a,b,c,d){this.a=a;this.g=b;this.U=c;this.j=d||ha;this.h=new G("-")}var ha="wf";function H(a){v(a.a,a.g,a.h.e(a.j,"loading"));I(a,"loading")}function J(a){w(a.a,a.g,a.h.e(a.j,"loading"));x(a.a,a.g,a.h.e(a.j,"active"))||v(a.a,a.g,a.h.e(a.j,"inactive"));I(a,"inactive")}function ia(a){w(a.a,a.g,a.h.e(a.j,"loading"));w(a.a,a.g,a.h.e(a.j,"inactive"));v(a.a,a.g,a.h.e(a.j,"active"));I(a,"active")}function I(a,b,c,d){a.U[b]&&a.U[b](c,d)};function ja(){this.fa={}}function ka(a,b){var c=[];for(var d in b)if(b.hasOwnProperty(d)){var e=a.fa[d];e&&c.push(e(b[d]))}return c};function L(a,b,c,d,e){this.a=a;this.A=b;this.n=c;this.u=d;this.D=e;this.V=0;this.ja=this.ea=false}L.prototype.watch=function(a,b,c,d,e){for(var f=a.length,g=0;g<f;g++){var h=a[g];b[h]||(b[h]=["n4"]);this.V+=b[h].length}if(e)this.ea=e;for(g=0;g<f;g++){h=a[g];e=b[h];for(var l=c[h],k=0,m=e.length;k<m;k++){var B=e[k],p=this.A,K=h;v(p.a,p.g,p.h.e(p.j,K,B,"loading"));I(p,"fontloading",K,B);p=n(this,this.qa);K=n(this,this.ra);(new d(p,K,this.a,this.n,this.u,this.D,h,B,l)).start()}}};
L.prototype.qa=function(a,b){var c=this.A;w(c.a,c.g,c.h.e(c.j,a,b,"loading"));w(c.a,c.g,c.h.e(c.j,a,b,"inactive"));v(c.a,c.g,c.h.e(c.j,a,b,"active"));I(c,"fontactive",a,b);this.ja=true;M(this)};L.prototype.ra=function(a,b){var c=this.A;w(c.a,c.g,c.h.e(c.j,a,b,"loading"));x(c.a,c.g,c.h.e(c.j,a,b,"active"))||v(c.a,c.g,c.h.e(c.j,a,b,"inactive"));I(c,"fontinactive",a,b);M(this)};function M(a){if(--a.V==0&&a.ea)a.ja?ia(a.A):J(a.A)};function N(a,b,c,d,e,f,g,h,l){this.H=a;this.$=b;this.a=c;this.n=d;this.u=e;this.D=f;this.Aa=new la;this.v=new O;this.L=g;this.B=h;this.sa=l||ma;this.O=na(this,oa);this.P=na(this,pa);this.ca=this.O;this.da=this.P;this.Q=P(this,oa);this.R=P(this,pa)}var oa="arial,'URW Gothic L',sans-serif",pa="Georgia,'Century Schoolbook L',serif",ma="BESbswy";N.prototype.start=function(){this.ia=this.D();this.J()};
N.prototype.J=function(){var a=this.n.p(this.Q),b=this.n.p(this.R);if((this.O!=a||this.P!=b)&&this.ca==a&&this.da==b)Q(this,this.H);else if(this.D()-this.ia>=5E3)Q(this,this.$);else{this.ca=a;this.da=b;qa(this)}};function qa(a){a.u(function(b,c){return function(){c.call(b)}}(a,a.J),25)}function Q(a,b){s(a.a,a.Q);s(a.a,a.R);b(a.L,a.B)}function na(a,b){b=P(a,b,true);var c=a.n.p(b);s(a.a,b);return c}function P(a,b,c){b=a.a.createElement("span",{style:R(a,b,a.B,c)},a.sa);r(a.a,"body",b);return b}
function R(a,b,c,d){c=a.v.expand(c);return"position:absolute;top:-999px;left:-999px;font-size:300px;width:auto;height:auto;line-height:normal;margin:0;padding:0;font-variant:normal;font-family:"+(d?"":a.Aa.quote(a.L)+",")+b+";"+c};function S(a,b,c,d,e){this.a=a;this.X=b;this.g=c;this.u=d;this.c=e;this.M=this.N=0}S.prototype.q=function(a,b){this.X.fa[a]=b};S.prototype.load=function(a){var b=new ga(this.a,this.g,a);this.c.w()?ra(this,b,a):J(b)};S.prototype.ya=function(a,b,c,d){var e=a.Z?a.Z():N;if(d)a.load(n(this,this.Ca,b,c,e));else{a=--this.N==0;this.M--;if(a)this.M==0?J(b):H(b);c.watch([],{},{},e,a)}};
S.prototype.Ca=function(a,b,c,d,e,f){var g=--this.N==0;g&&H(a);this.u(n(this,function(h,l,k,m,B,p){h.watch(l,k||{},m||{},B,p)},b,d,e,f,c,g))};function ra(a,b,c){c=ka(a.X,c);a.M=a.N=c.length;for(var d=new L(a.a,b,{p:function(h){return h.offsetWidth}},a.u,function(){return(new Date).getTime()}),e=0,f=c.length;e<f;e++){var g=c[e];g.z(a.c,n(a,a.ya,g,b,d))}};function G(a){this.za=a||sa}var sa="-";G.prototype.e=function(){for(var a=[],b=0;b<arguments.length;b++)a.push(arguments[b].replace(/[\W_]+/g,"").toLowerCase());return a.join(this.za)};function la(){this.ha="'"}la.prototype.quote=function(a){var b=[];a=a.split(/,\s*/);for(var c=0;c<a.length;c++){var d=a[c].replace(/['"]/g,"");d.indexOf(" ")==-1?b.push(d):b.push(this.ha+d+this.ha)}return b.join(",")};function O(){this.G=ta;this.o=ua}var ta=["font-style","font-weight"],ua={"font-style":[["n","normal"],["i","italic"],["o","oblique"]],"font-weight":[["1","100"],["2","200"],["3","300"],["4","400"],["5","500"],["6","600"],["7","700"],["8","800"],["9","900"],["4","normal"],["7","bold"]]};function T(a,b,c){this.aa=a;this.Fa=b;this.o=c}T.prototype.compact=function(a,b){for(var c=0;c<this.o.length;c++)if(b==this.o[c][1]){a[this.aa]=this.o[c][0];return}};
T.prototype.expand=function(a,b){for(var c=0;c<this.o.length;c++)if(b==this.o[c][0]){a[this.aa]=this.Fa+":"+this.o[c][1];return}};O.prototype.compact=function(a){var b=["n","4"];a=a.split(";");for(var c=0,d=a.length;c<d;c++){var e=a[c].replace(/\s+/g,"").split(":");if(e.length==2){var f=e[1];a:{e=e[0];for(var g=0;g<this.G.length;g++)if(e==this.G[g]){e=new T(g,e,this.o[e]);break a}e=null}e&&e.compact(b,f)}}return b.join("")};
O.prototype.expand=function(a){if(a.length!=2)return null;for(var b=[null,null],c=0,d=this.G.length;c<d;c++){var e=this.G[c],f=a.substr(c,1);(new T(c,e,this.o[e])).expand(b,f)}return b[0]&&b[1]?b.join(";")+";":null};window.WebFont=function(){var a=(new z(navigator.userAgent,document)).parse();return new S(new o(document,a),new ja,document.documentElement,function(b,c){setTimeout(b,c)},a)}();window.WebFont.load=window.WebFont.load;window.WebFont.addModule=window.WebFont.q;y.prototype.getName=y.prototype.getName;y.prototype.getVersion=y.prototype.xa;y.prototype.getEngine=y.prototype.Y;y.prototype.getEngineVersion=y.prototype.ua;y.prototype.getPlatform=y.prototype.va;y.prototype.getPlatformVersion=y.prototype.wa;
y.prototype.getDocumentMode=y.prototype.ta;y.prototype.isSupportingWebFont=y.prototype.w;function U(a,b){this.a=a;this.d=b}var va={regular:"n4",bold:"n7",italic:"i4",bolditalic:"i7",r:"n4",b:"n7",i:"i4",bi:"i7"};U.prototype.z=function(a,b){return b(a.w())};
U.prototype.load=function(a){r(this.a,"head",t(this.a,("https:"==document.location.protocol?"https:":"http:")+"//webfonts.fontslive.com/css/"+this.d.key+".css"));var b;b=this.d.families;var c,d,e;c=[];d={};for(var f=0,g=b.length;f<g;f++){e=void 0;var h=void 0;h=void 0;h=b[f].split(":");e=h[0];h=h[1]?wa(this,h[1]):["n4"];e={W:e,T:h};c.push(e.W);d[e.W]=e.T}b={pa:c,T:d};a(b.pa,b.T)};
function wa(a,b){a=b.split(",");b=[];for(var c=0,d=a.length;c<d;c++){var e=a[c];if(e){var f=va[e];b.push(f?f:e)}}return b}window.WebFont.q("ascender",function(a){var b=(new z(navigator.userAgent,document)).parse();return new U(new o(document,b),a)});function V(a,b,c,d,e,f,g,h,l){V.Ga.call(this,a,b,c,d,e,f,g,h,l);a=["Times New Roman","Lucida Sans Unicode","Courier New","Tahoma","Arial","Microsoft Sans Serif","Times","Lucida Console","Sans","Serif","Monospace"];b=a.length;c={};d=P(this,a[0],true);c[this.n.p(d)]=true;for(e=1;e<b;e++){f=a[e];q(this.a,d,R(this,f,this.B,true));c[this.n.p(d)]=true;if(this.B[1]!="4"){q(this.a,d,R(this,f,this.B[0]+"4",true));c[this.n.p(d)]=true}}s(this.a,d);this.t=c;this.la=false}
(function(a,b){function c(){}c.prototype=a.prototype;b.prototype=new c;b.Ga=a;b.Ja=a.prototype})(N,V);var xa={Arimo:true,Cousine:true,Tinos:true};V.prototype.J=function(){var a=this.n.p(this.Q),b=this.n.p(this.R);if(!this.la&&a==b&&this.t[a]){this.t={};this.la=this.t[a]=true}if((this.O!=a||this.P!=b)&&!this.t[a]&&!this.t[b])Q(this,this.H);else if(this.D()-this.ia>=5E3)this.t[a]&&this.t[b]&&xa[this.L]?Q(this,this.H):Q(this,this.$);else qa(this)};function ya(a){this.I=a?a:("https:"==window.location.protocol?"https:":"http:")+za;this.f=[];this.S=[]}var za="//fonts.googleapis.com/css";ya.prototype.e=function(){if(this.f.length==0)throw new Error("No fonts to load !");if(this.I.indexOf("kit=")!=-1)return this.I;for(var a=this.f.length,b=[],c=0;c<a;c++)b.push(this.f[c].replace(/ /g,"+"));a=this.I+"?family="+b.join("%7C");if(this.S.length>0)a+="&subset="+this.S.join(",");return a};function Aa(a){this.f=a;this.ga=[];this.ka={};this.F={};this.v=new O}var Ba={ultralight:"n2",light:"n3",regular:"n4",bold:"n7",italic:"i4",bolditalic:"i7",ul:"n2",l:"n3",r:"n4",b:"n7",i:"i4",bi:"i7"},Ca={latin:ma,cyrillic:"&#1081;&#1103;&#1046;",greek:"&#945;&#946;&#931;",khmer:"&#x1780;&#x1781;&#x1782;",Hanuman:"&#x1780;&#x1781;&#x1782;"};
Aa.prototype.parse=function(){for(var a=this.f.length,b=0;b<a;b++){var c=this.f[b].split(":"),d=c[0],e=["n4"];if(c.length>=2){var f=c[1],g=[];if(f){f=f.split(",");for(var h=f.length,l=0;l<h;l++){var k;k=f[l];if(k.match(/^[\w ]+$/)){var m=Ba[k];if(m)k=m;else{m=k.match(/^(\d*)(\w*)$/);k=m[1];m=m[2];k=(k=this.v.expand([m?m:"n",k?k.substr(0,1):"4"].join("")))?this.v.compact(k):null}}else k="";k&&g.push(k)}}if(g.length>0)e=g;if(c.length==3){c=c[2];g=[];c=c?c.split(","):g;if(c.length>0)if(c=Ca[c[0]])this.F[d]=
c}}if(!this.F[d])if(c=Ca[d])this.F[d]=c;this.ga.push(d);this.ka[d]=e}};function W(a,b,c){this.c=a;this.a=b;this.d=c}W.prototype.z=function(a,b){b(a.w())};W.prototype.Z=function(){if(this.c.Y()=="AppleWebKit")return V;return N};W.prototype.load=function(a){var b=this.a;this.c.getName()=="MSIE"&&this.d.blocking!=true?aa(b,n(this,this.ba,a)):this.ba(a)};
W.prototype.ba=function(a){for(var b=this.a,c=new ya(this.d.api),d=this.d.families,e=d.length,f=0;f<e;f++){var g=d[f].split(":");g.length==3&&c.S.push(g.pop());c.f.push(g.join(":"))}d=new Aa(d);d.parse();r(b,"head",t(b,c.e()));a(d.ga,d.ka,d.F)};window.WebFont.q("google",function(a){var b=(new z(navigator.userAgent,document)).parse();return new W(b,new o(document,b),a)});function X(a,b){this.a=a;this.d=b}X.prototype.load=function(a){for(var b=this.d.urls||[],c=this.d.families||[],d=0,e=b.length;d<e;d++)r(this.a,"head",t(this.a,b[d]));a(c)};X.prototype.z=function(a,b){return b(a.w())};window.WebFont.q("custom",function(a){var b=(new z(navigator.userAgent,document)).parse();return new X(new o(document,b),a)});function Y(a,b,c){this.m=a;this.a=b;this.d=c;this.f=[];this.s={};this.v=new O}Y.prototype.C=function(a){return("https:"==this.m.location.protocol?"https:":"http:")+(this.d.api||"//f.fontdeck.com/s/css/js/")+this.m.document.location.hostname+"/"+a+".js"};
Y.prototype.z=function(a,b){a=this.d.id;var c=this;if(a){this.m.__webfontfontdeckmodule__||(this.m.__webfontfontdeckmodule__={});this.m.__webfontfontdeckmodule__[a]=function(d,e){for(var f=0,g=e.fonts.length;f<g;++f){var h=e.fonts[f];c.f.push(h.name);c.s[h.name]=[c.v.compact("font-weight:"+h.weight+";font-style:"+h.style)]}b(d)};r(this.a,"head",u(this.a,this.C(a)))}else b(true)};Y.prototype.load=function(a){a(this.f,this.s)};
window.WebFont.q("fontdeck",function(a){var b=(new z(navigator.userAgent,document)).parse();return new Y(window,new o(document,b),a)});function Z(a,b,c,d,e){this.m=a;this.c=b;this.a=c;this.k=d;this.d=e;this.f=[];this.s={}}
Z.prototype.z=function(a,b){var c=this,d=c.d.projectId;if(d){var e=u(c.a,c.C(d));e.id="__MonotypeAPIScript__"+d;e.onreadystatechange=function(f){if(e.readyState==="loaded"||e.readyState==="complete"){e.onreadystatechange=null;e.onload(f)}};e.onload=function(){if(c.m["__mti_fntLst"+d]){var f=c.m["__mti_fntLst"+d]();if(f&&f.length){var g;for(g=0;g<f.length;g++)c.f.push(f[g].fontfamily)}}b(a.w())};r(this.a,"head",e)}else b(true)};
Z.prototype.C=function(a){var b=this.protocol(),c=(this.d.api||"fast.fonts.com/jsapi").replace(/^.*http(s?):(\/\/)?/,"");return b+"//"+c+"/"+a+".js"};Z.prototype.load=function(a){a(this.f,this.s)};Z.prototype.protocol=function(){var a=["http:","https:"],b=a[0];if(this.k&&this.k.location&&this.k.location.protocol){var c=0;for(c=0;c<a.length;c++)if(this.k.location.protocol===a[c])return this.k.location.protocol}return b};
window.WebFont.q("monotype",function(a){var b=(new z(navigator.userAgent,document)).parse();return new Z(window,b,new o(document,b),document,a)});function $(a,b,c){this.m=a;this.a=b;this.d=c;this.f=[];this.s={}}$.prototype.C=function(a){var b="https:"==window.location.protocol?"https:":"http:";return(this.d.api||b+"//use.typekit.com")+"/"+a+".js"};$.prototype.z=function(a,b){var c=this.d.id,d=this.d,e=this;if(c){this.m.__webfonttypekitmodule__||(this.m.__webfonttypekitmodule__={});this.m.__webfonttypekitmodule__[c]=function(f){f(a,d,function(g,h,l){e.f=h;e.s=l;b(g)})};r(this.a,"head",u(this.a,this.C(c)))}else b(true)};
$.prototype.load=function(a){a(this.f,this.s)};window.WebFont.q("typekit",function(a){var b=(new z(navigator.userAgent,document)).parse();return new $(window,new o(document,b),a)});window.WebFontConfig&&window.WebFont.load(window.WebFontConfig);
})(this,document);
;

// -*- Mode: JavaScript; tab-width: 2; indent-tabs-mode: nil; -*-
// vim:set ft=javascript ts=2 sw=2 sts=2 cindent:
// TODO: does 'arguments.callee.caller' work?

var Dispatcher = (function($, window, undefined) {
var Dispatcher = function() {
var that = this;

var table = {};

var on = function(message, host, handler) {
if (handler === undefined) {
handler = host;
host = arguments.callee.caller;
}
if (table[message] === undefined) {
table[message] = [];
}
table[message].push([host, handler]);
return this;
};

// Notify listeners that we encountered an error in an asynch call
var inAsynchError = false; // To avoid error avalanches
var handleAsynchError = function(e) {
if (!inAsynchError) {
inAsynchError = true;
// TODO: Hook printout into dispatch elsewhere?
console.warn('Handled async error:', e);
that.post('dispatchAsynchError', [e]);
inAsynchError = false;
} else {
console.warn('Dropped asynch error:', e);
}
};

var post = function(asynch, message, args, returnType) {
if (typeof(asynch) !== 'number') {
// no asynch parameter
returnType = args;
args = message;
message = asynch;
asynch = null;
}
if (args === undefined) {
args = [];
}
var results = [];
// DEBUG: if (typeof(message) != "string" || !(message.match(/mouse/) || message == "hideComment")) console.log(message, args);

if (typeof(message) === 'function') {
// someone was lazy and sent a simple function
var host = arguments.callee.caller;
if (asynch !== null) {
result = setTimeout(function() {
try {
message.apply(host, args);
} catch(e) {
that.handleAsynchError(e);
}
}, asynch);
} else {
result = message.apply(host, args);
}
results.push(result);
} else {
// a proper message, propagate to all interested parties
var todo = table[message];
if (todo !== undefined) {
$.each(todo, function(itemNo, item) {
var result;
if (asynch !== null) {
result = setTimeout(function() {
try {
item[1].apply(item[0], args);
} catch (e) {
that.handleAsynchError(e);
}
}, asynch);
} else {
result = item[1].apply(item[0], args);
}
results.push(result);
});
/* DEBUG
} else {
console.warn('Message ' + message + ' has no subscribers.'); // DEBUG
*/
}
}
if (returnType == 'any') {
var i = results.length;
while (i--) {
if (results[i] !== false) return results[i];
}
return false;
}
if (returnType == 'all') {
var i = results.length;
while (i--) {
if (results[i] === false) return results[i];
}
}
return results;
};

var proxy = function(destination, message) {
this.on(message, function() {
destination.post(message, Array.prototype.slice.call(arguments));
});
};

var dispatcher = {
on: on,
post: post,
proxy: proxy
};
Dispatcher.dispatchers.push(dispatcher);
return dispatcher;
};

Dispatcher.dispatchers = [];
Dispatcher.post = function(asynch, message, args, returnType) {
$.each(Dispatcher.dispatchers, function(dispatcherNo, dispatcher) {
dispatcher.post(asynch, message, args, returnType);
});
};

return Dispatcher;
})(jQuery, window);
;

// -*- Mode: JavaScript; tab-width: 2; indent-tabs-mode: nil; -*-
// vim:set ft=javascript ts=2 sw=2 sts=2 cindent:
var URLMonitor = (function($, window, undefined) {
var URLMonitor = function(dispatcher) {
var that = this;

var reloadData = true;
var changed = false;
var newIntArgs = {};

that.url_hash = new URLHash();

// Thanks to:
// http://kilianvalkhof.com/2010/javascript/the-case-of-the-disappearing-favicon/
var setFavicon = function() {
var link = $('link[type="image/x-icon"]').remove().attr("href");
$('<link href="'+ link +'" rel="shortcut icon" type="image/x-icon" />').appendTo('head');
}

var updateURL = function() {
var new_hash = that.url_hash.getHash();
changed = false;
window.location.hash = new_hash;
setFavicon();
dispatcher.post('hideForm');
};

var setArguments = function(args, force) {
var oldArgs = that.url_hash.arguments;
var argSplit = URLHash.splitArgs(args);

if (!Util.isEqual(that.url_hash.extArguments, argSplit[1])) {
changed = true;
that.url_hash.setArguments(args);
dispatcher.post('argsChanged', [args, oldArgs]);
}
if (changed) {
// hashchange event will trigger
newIntArgs = argSplit[0];
updateURL();
} else if (force || !Util.isEqual(that.url_hash.intArguments, argSplit[0])) {
// hash is same, but internal arguments differ
that.url_hash.setArguments(args);
// hashchange event won't trigger, but internal args have
// changed, so we have to do updateState's job
dispatcher.post('hideForm');
dispatcher.post('argsChanged', [args, oldArgs]);
dispatcher.post('current', [that.url_hash.collection,
that.url_hash.document, that.url_hash.arguments, reloadData]);
reloadData = true;
}
};

var setDocument = function(doc, args) {
var oldDoc = that.url_hash.document;
if (oldDoc !== doc) {
changed = true;
that.url_hash.setDocument(doc);
dispatcher.post('docChanged', [doc, oldDoc]);
}
setArguments(args || null);
};

var setCollection = function(coll, doc, args) {
var oldColl = that.url_hash.collection;
if (oldColl !== coll) {
changed = true;
that.url_hash.setCollection(coll);

// keep "blind" down while loading new collection
$('#waiter').dialog('open');

dispatcher.post('ajax', [{
action: 'getCollectionInformation',
collection: coll
}, 'collectionLoaded', {
collection: coll,
keep: true
}]);
dispatcher.post('collectionChanged', [coll, oldColl]);
}
setDocument(doc || '', args);
}

var updateState = function() {
dispatcher.post('makeAjaxObsolete');
if (!changed) {
var new_url_hash = URLHash.parse(window.location.hash);
setCollection(new_url_hash.collection, new_url_hash.document,
$.extend(new_url_hash.arguments, newIntArgs));
that.url_hash = new_url_hash;
newIntArgs = {};
}

dispatcher.post('current', [that.url_hash.collection,
that.url_hash.document, that.url_hash.arguments, reloadData]);
reloadData = true;
};

var forceUpdate = function() {
$(window).trigger('hashchange');
};

var preventReloadByURL = function() {
reloadData = false;
}
var allowReloadByURL = function() {
reloadData = true;
}

var init = function() {
$(window).bind('hashchange', updateState);
forceUpdate();
}

dispatcher.
on('forceUpdate', forceUpdate).
on('setArguments', setArguments).
on('setDocument', setDocument).
on('setCollection', setCollection).
on('preventReloadByURL', preventReloadByURL).
on('allowReloadByURL', allowReloadByURL).
on('init', init);
};

return URLMonitor;
})(jQuery, window);

var URLHash = (function($, window, undefined) {
var URLHash = function(collection, _document, _arguments) {
var that = this;
that.collection = collection;
that.document = _document || '';
that.arguments = _arguments || {};
that.calcArgs();
}

URLHash.prototype = {
calcArgs: function() {
var args = URLHash.splitArgs(this.arguments);
this.intArguments = args[0];
this.extArguments = args[1];
},

setArgument: function(argument, value) {
if (!this.arguments) {
this.arguments = {};
}
this.arguments[argument] = value;
this.calcArgs();
return this;
},

setArguments: function(_arguments) {
// the $.extend here basically takes a copy; raw assignment
// would allow changes of the args to alter original, which
// could be e.g. the "args" of search results
this.arguments = $.extend({}, _arguments || {});
this.calcArgs();
return this;
},

setDocument: function(_document) {
this.document = _document;
return this;
},

setCollection: function(collection) {
this.collection = collection;
return this;
},

getHash: function() {
var url_hash = this.collection + this.document;

var url_args = Util.param(this.extArguments);

if (url_args.length) {
url_hash += '?' + url_args;
}

if (url_hash.length) {
url_hash = '#' + url_hash;
}

return url_hash;
}
};

// arguments that do not appear in the URL
var INT_ARGS = ['match', 'matchfocus', 'edited'];

URLHash.splitArgs = function(args) {
var intArgs = {};
var extArgs = $.extend({}, args);
var intArgNameLen = INT_ARGS.length;
for (var i = 0; i < intArgNameLen; i++) {
intArgs[INT_ARGS[i]] = extArgs[INT_ARGS[i]];
delete extArgs[INT_ARGS[i]];
}
return [intArgs, extArgs];
};

// TODO: Document and conform variables to the rest of the object
URLHash.parse = function(hash) {
if (hash.length) {
// Remove the leading hash (#)
hash = hash.substr(1);
}

var pathAndArgs = hash.split('?');
var path = pathAndArgs[0] || '';
var argsStr = pathAndArgs[1] || '';
var coll;
var slashPos = path.lastIndexOf('/');
if (slashPos === -1) {
coll = '/';
} else {
coll = path.substr(0, slashPos + 1);
if (coll[coll.length - 1] !== '/') {
coll += '/';
}
if (coll[0] !== '/') {
coll = '/' + coll;
}
}
var doc = path.substr(slashPos + 1);
var args = Util.deparam(argsStr);
return new URLHash(coll, doc, args);
};

return URLHash;
})(jQuery, window)
;

// -*- Mode: JavaScript; tab-width: 2; indent-tabs-mode: nil; -*-
// vim:set ft=javascript ts=2 sw=2 sts=2 cindent:

var Visualizer = (function($, window, undefined) {
var fontLoadTimeout = 5000; // 5 seconds

var DocumentData = function(text) {
this.text = text;
this.chunks = [];
this.spans = {};
this.eventDescs = {};
this.sentComment = {};
this.arcs = [];
this.arcById = {};
this.markedSent = {};
this.spanAnnTexts = {};
this.towers = {};
// this.sizes = {};
};

var Fragment = function(id, span, from, to) {
this.id = id;
this.span = span;
this.from = from;
this.to = to;
// this.towerId = undefined;
// this.drawOrder = undefined;
};

var Span = function(id, type, offsets, generalType) {
this.id = id;
this.type = type;
this.totalDist = 0;
this.numArcs = 0;
this.generalType = generalType;
this.offsets = offsets;
this.headFragment = null;
// this.from = undefined;
// this.to = undefined;
// this.wholeFrom = undefined;
// this.wholeTo = undefined;
// this.headFragment = undefined;
// this.chunk = undefined;
// this.marked = undefined;
// this.avgDist = undefined;
// this.curly = undefined;
// this.comment = undefined; // { type: undefined, text: undefined };
// this.annotatorNotes = undefined;
// this.drawCurly = undefined;
// this.glyphedLabelText = undefined;
// this.group = undefined;
// this.height = undefined;
// this.highlightPos = undefined;
// this.indexNumber = undefined;
// this.labelText = undefined;
// this.nestingDepth = undefined;
// this.nestingDepthLR = undefined;
// this.nestingDepthRL = undefined;
// this.nestingHeight = undefined;
// this.nestingHeightLR = undefined;
// this.nestingHeightRL = undefined;
// this.rect = undefined;
// this.rectBox = undefined;
// this.refedIndexSum = undefined;
// this.right = undefined;
// this.totaldist = undefined;
// this.width = undefined;
this.initContainers(offsets);
};

Span.prototype.initContainers = function() {
this.incoming = [];
this.outgoing = [];
this.attributes = {};
this.attributeText = [];
this.attributeCues = {};
this.attributeCueFor = {};
this.attributeMerge = {}; // for box, cross, etc. that are span-global
this.fragments = [];
this.normalizations = [];
};

Span.prototype.copy = function(id) {
var span = $.extend(new Span(), this); // clone
span.id = id;
span.initContainers(); // protect from shallow copy
return span;
};

var EventDesc = function(id, triggerId, roles, klass) {
this.id = id;
this.triggerId = triggerId;
var roleList = this.roles = [];
$.each(roles, function(roleNo, role) {
roleList.push({ type: role[0], targetId: role[1] });
});
if (klass == "equiv") {
this.equiv = true;
} else if (klass == "relation") {
this.relation = true;
}
// this.leftSpans = undefined;
// this.rightSpans = undefined;
// this.annotatorNotes = undefined;
};

var Chunk = function(index, text, from, to, space, spans) {
this.index = index;
this.text = text;
this.from = from;
this.to = to;
this.space = space;
this.fragments = [];
// this.sentence = undefined;
// this.group = undefined;
// this.highlightGroup = undefined;
// this.markedTextStart = undefined;
// this.markedTextEnd = undefined;
// this.nextSpace = undefined;
// this.right = undefined;
// this.row = undefined;
// this.textX = undefined;
// this.translation = undefined;
}

var Arc = function(eventDesc, role, dist, eventNo) {
this.origin = eventDesc.id;
this.target = role.targetId;
this.dist = dist;
this.type = role.type;
this.shadowClass = eventDesc.shadowClass;
this.jumpHeight = 0;
if (eventDesc.equiv) {
this.equiv = true;
this.eventDescId = eventNo;
eventDesc.equivArc = this;
} else if (eventDesc.relation) {
this.relation = true;
this.eventDescId = eventNo;
}
// this.marked = undefined;
};

var Row = function(svg) {
this.group = svg.group();
this.background = svg.group(this.group);
this.chunks = [];
this.hasAnnotations = false;
this.maxArcHeight = 0;
this.maxSpanHeight = 0;
};

var Measurements = function(widths, height, y) {
this.widths = widths;
this.height = height;
this.y = y;
};

// A naive whitespace tokeniser
var tokenise = function(text) {
var tokenOffsets = [];
var tokenStart = null;
var lastCharPos = null;

for (var i = 0; i < text.length; i++) {
var c = text[i];
// Have we found the start of a token?
if (tokenStart == null && !/\s/.test(c)) {
tokenStart = i;
lastCharPos = i;
// Have we found the end of a token?
} else if (/\s/.test(c) && tokenStart != null) {
tokenOffsets.push([tokenStart, i]);
tokenStart = null;
// Is it a non-whitespace character?
} else if (!/\s/.test(c)) {
lastCharPos = i;
}
}
// Do we have a trailing token?
if (tokenStart != null) {
tokenOffsets.push([tokenStart, lastCharPos + 1]);
}

return tokenOffsets;
};

// A naive newline sentence splitter
var sentenceSplit = function(text) {
var sentenceOffsets = [];
var sentStart = null;
var lastCharPos = null;

for (var i = 0; i < text.length; i++) {
var c = text[i];
// Have we found the start of a sentence?
if (sentStart == null && !/\s/.test(c)) {
sentStart = i;
lastCharPos = i;
// Have we found the end of a sentence?
} else if (c == '\n' && sentStart != null) {
sentenceOffsets.push([sentStart, i]);
sentStart = null;
// Is it a non-whitespace character?
} else if (!/\s/.test(c)) {
lastCharPos = i;
}
}
// Do we have a trailing sentence without a closing newline?
if (sentStart != null) {
sentenceOffsets.push([sentStart, lastCharPos + 1]);
}

return sentenceOffsets;
};

// Sets default values for a wide range of optional attributes
var setSourceDataDefaults = function(sourceData) {
// The following are empty lists if not set
$.each([
'attributes',
'comments',
'entities',
'equivs',
'events',
'modifications',
'normalizations',
'relations',
'triggers'
], function(attrNo, attr) {
if (sourceData[attr] === undefined) {
sourceData[attr] = [];
}
});

// If we lack sentence offsets we fall back on naive sentence splitting
if (sourceData.sentence_offsets === undefined) {
sourceData.sentence_offsets = sentenceSplit(sourceData.text);
}
// Similarily we fall back on whitespace tokenisation
if (sourceData.token_offsets === undefined) {
sourceData.token_offsets = tokenise(sourceData.text);
}
};

// Set default values for a variety of collection attributes
var setCollectionDefaults = function(collectionData) {
// The following are empty lists if not set
$.each([
'entity_attribute_types',
'entity_types',
'event_attribute_types',
'event_types',
'relation_attribute_types',
'relation_types',
'unconfigured_types'
], function(attrNo, attr) {
if (collectionData[attr] === undefined) {
collectionData[attr] = [];
}
});
};

var Visualizer = function(dispatcher, svgId, webFontURLs) {
var $svgDiv = $('#' + svgId);
if (!$svgDiv.length) {
throw Error('Could not find container with id="' + svgId + '"');
}
var that = this;

// OPTIONS
var roundCoordinates = true; // try to have exact pixel offsets
var boxTextMargin = { x: 0, y: 1.5 }; // effect is inverse of "margin" for some reason
var highlightRounding = { x: 3, y:3 }; // rx, ry for highlight boxes
var spaceWidths = {
' ': 4,
'\u00a0': 4,
'\u200b': 0,
'\u3000': 8,
'\n': 4
};
var coloredCurlies = true; // color curlies by box BG
var arcSlant = 15; //10;
var minArcSlant = 8;
var arcHorizontalSpacing = 10; // min space boxes with connecting arc
var rowSpacing = -5;          // for some funny reason approx. -10 gives "tight" packing.
var sentNumMargin = 20;
var smoothArcCurves = true;   // whether to use curves (vs lines) in arcs
var smoothArcSteepness = 0.5; // steepness of smooth curves (control point)
var reverseArcControlx = 5;   // control point distance for "UFO catchers"

// "shadow" effect settings (note, error, incompelete)
var rectShadowSize = 3;
var rectShadowRounding = 2.5;
var arcLabelShadowSize = 1;
var arcLabelShadowRounding = 5;
var shadowStroke = 2.5; // TODO XXX: this doesn't affect anything..?

// "marked" effect settings (edited, focus, match)
var markedSpanSize = 6;
var markedArcSize = 2;
var markedArcStroke = 7; // TODO XXX: this doesn't seem to do anything..?

var rowPadding = 2;
var nestingAdjustYStepSize = 2; // size of height adjust for nested/nesting spans
var nestingAdjustXStepSize = 1; // size of height adjust for nested/nesting spans

var highlightSequence = '#FF9632;#FFCC00;#FF9632'; // yellow - deep orange
//var highlightSequence = '#FFFC69;#FFCC00;#FFFC69'; // a bit toned town
var highlightSpanSequence = highlightSequence;
var highlightArcSequence =  highlightSequence;
var highlightTextSequence = highlightSequence;
var highlightDuration = '2s';
// different sequence for "mere" matches (as opposed to "focus" and
// "edited" highlights)
var highlightMatchSequence = '#FFFF00'; // plain yellow

var fragmentConnectorDashArray = '1,3,3,3';
var fragmentConnectorColor = '#000000';

// END OPTIONS


var svg;
var $svg;
var data = null;
var sourceData = null;
var requestedData = null;
var coll, doc, args;
var relationTypesHash;
var isRenderRequested;
var isCollectionLoaded = false;
var entityAttributeTypes = null;
var eventAttributeTypes = null;
var spanTypes = null;
var highlightGroup;

// var commentPrioLevels = ['Unconfirmed', 'Incomplete', 'Warning', 'Error', 'AnnotatorNotes'];
// XXX Might need to be tweaked - inserted diff levels
var commentPrioLevels = [
'Unconfirmed', 'Incomplete', 'Warning', 'Error', 'AnnotatorNotes',
'AddedAnnotation', 'MissingAnnotation', 'ChangedAnnotation'];

this.arcDragOrigin = null; // TODO

// due to silly Chrome bug, I have to make it pay attention
var forceRedraw = function() {
if (!$.browser.chrome) return; // not needed
$svg.css('margin-bottom', 1);
setTimeout(function() { $svg.css('margin-bottom', 0); }, 0);
}

var rowBBox = function(span) {
var box = $.extend({}, span.rectBox); // clone
var chunkTranslation = span.chunk.translation;
box.x += chunkTranslation.x;
box.y += chunkTranslation.y;
return box;
};

var commentPriority = function(commentClass) {
if (commentClass === undefined) return -1;
var len = commentPrioLevels.length;
for (var i = 0; i < len; i++) {
if (commentClass.indexOf(commentPrioLevels[i]) != -1) return i;
}
return 0;
};

var clearSVG = function() {
data = null;
sourceData = null;
svg.clear();
$svgDiv.hide();
};

var setMarked = function(markedType) {
$.each(args[markedType] || [], function(markedNo, marked) {
if (marked[0] == 'sent') {
data.markedSent[marked[1]] = true;
} else if (marked[0] == 'equiv') { // [equiv, Equiv, T1]
$.each(sourceData.equivs, function(equivNo, equiv) {
if (equiv[1] == marked[1]) {
var len = equiv.length;
for (var i = 2; i < len; i++) {
if (equiv[i] == marked[2]) {
// found it
len -= 3;
for (var i = 1; i <= len; i++) {
var arc = data.eventDescs[equiv[0] + "*" + i].equivArc;
arc.marked = markedType;
}
return; // next equiv
}
}
}
});
} else if (marked.length == 2) {
markedText.push([parseInt(marked[0], 10), parseInt(marked[1], 10), markedType]);
} else {
var span = data.spans[marked[0]];
if (span) {
if (marked.length == 3) { // arc
$.each(span.outgoing, function(arcNo, arc) {
if (arc.target == marked[2] && arc.type == marked[1]) {
arc.marked = markedType;
}
});
} else { // span
span.marked = markedType;
}
} else {
var eventDesc = data.eventDescs[marked[0]];
if (eventDesc) { // relation
var relArc = eventDesc.roles[0];
$.each(data.spans[eventDesc.triggerId].outgoing, function(arcNo, arc) {
if (arc.target == relArc.targetId && arc.type == relArc.type) {
arc.marked = markedType;
}
});
} else { // try for trigger
$.each(data.eventDescs, function(eventDescNo, eventDesc) {
if (eventDesc.triggerId == marked[0]) {
data.spans[eventDesc.id].marked = markedType;
}
});
}
}
}
});
};

var fragmentComparator = function(a, b) {
var tmp;
var aSpan = a.span;
var bSpan = b.span;

// spans with more fragments go first
tmp = aSpan.fragments.length - bSpan.fragments.length;
if (tmp) {
return tmp < 0 ? 1 : -1;
}

// longer arc distances go last
tmp = aSpan.avgDist - bSpan.avgDist;
if (tmp) {
return tmp < 0 ? -1 : 1;
}
// spans with more arcs go last
tmp = aSpan.numArcs - bSpan.numArcs;
if (tmp) {
return tmp < 0 ? -1 : 1;
}
// compare the span widths,
// put wider on bottom so they don't mess with arcs, or shorter
// on bottom if there are no arcs.
var ad = a.to - a.from;
var bd = b.to - b.from;
tmp = ad - bd;
if (aSpan.numArcs == 0 && bSpan.numArcs == 0) {
tmp = -tmp;
}
if (tmp) {
return tmp < 0 ? 1 : -1;
}
tmp = aSpan.refedIndexSum - bSpan.refedIndexSum;
if (tmp) {
return tmp < 0 ? -1 : 1;
}
// if no other criterion is found, sort by type to maintain
// consistency
// TODO: isn't there a cmp() in JS?
if (aSpan.type < bSpan.type) {
return -1;
} else if (aSpan.type > bSpan.type) {
return 1;
}

return 0;
};

var setData = function(_sourceData) {
if (!args) args = {};
sourceData = _sourceData;
dispatcher.post('newSourceData', [sourceData]);
data = new DocumentData(sourceData.text);

// collect annotation data
$.each(sourceData.entities, function(entityNo, entity) {
// offsets given as array of (start, end) pairs
var span =
//      (id,        type,      offsets,   generalType)
new Span(entity[0], entity[1], entity[2], 'entity');
data.spans[entity[0]] = span;
});
var triggerHash = {};
$.each(sourceData.triggers, function(triggerNo, trigger) {
triggerHash[trigger[0]] =
//       (id,         type,       offsets,    generalType), eventList
[new Span(trigger[0], trigger[1], trigger[2], 'trigger'), []];
});
$.each(sourceData.events, function(eventNo, eventRow) {
var eventDesc = data.eventDescs[eventRow[0]] =
//           (id,          triggerId,   roles,        klass)
new EventDesc(eventRow[0], eventRow[1], eventRow[2]);
var trigger = triggerHash[eventDesc.triggerId];
var span = trigger[0].copy(eventDesc.id);
trigger[1].push(span);
data.spans[eventDesc.id] = span;
});

// XXX modifications: delete later
$.each(sourceData.modifications, function(modNo, mod) {
// mod: [id, spanId, modification]
if (!data.spans[mod[2]]) {
dispatcher.post('messages', [[['<strong>ERROR</strong><br/>Event ' + mod[2] + ' (referenced from modification ' + mod[0] + ') does not occur in document ' + data.document + '<br/>(please correct the source data)', 'error', 5]]]);
return;
}
data.spans[mod[2]][mod[1]] = true;
});

var midpointComparator = function(a, b) {
var tmp = a.from + a.to - b.from - b.to;
if (!tmp) return 0;
return tmp < 0 ? -1 : 1;
};
// split spans into span fragments (for discontinuous spans)
$.each(data.spans, function(spanNo, span) {
$.each(span.offsets, function(offsetsNo, offsets) {
var from = parseInt(offsets[0], 10);
var to = parseInt(offsets[1], 10);
var fragment = new Fragment(offsetsNo, span, from, to);
span.fragments.push(fragment);
});
// ensure ascending order
span.fragments.sort(midpointComparator);
span.wholeFrom = span.fragments[0].from;
span.wholeTo = span.fragments[span.fragments.length - 1].to;
span.headFragment = span.fragments[(true) ? span.fragments.length - 1 : 0]; // TODO configurable!
});

var spanComparator = function(a, b) {
var aSpan = data.spans[a];
var bSpan = data.spans[b];
var tmp = aSpan.headFragment.from + aSpan.headFragment.to - bSpan.headFragment.from - bSpan.headFragment.to;
if (tmp) {
return tmp < 0 ? -1 : 1;
}
return 0;
};

$.each(sourceData.equivs, function(equivNo, equiv) {
// equiv: ['*', 'Equiv', spanId...]
equiv[0] = "*" + equivNo;
var equivSpans = equiv.slice(2);
var okEquivSpans = [];
// collect the equiv spans in an array
$.each(equivSpans, function(equivSpanNo, equivSpan) {
if (data.spans[equivSpan]) okEquivSpans.push(equivSpan);
// TODO: #404, inform the user with a message?
});
// sort spans in the equiv by their midpoint
okEquivSpans.sort(spanComparator);
// generate the arcs
var len = okEquivSpans.length;
for (var i = 1; i < len; i++) {
var eventDesc = data.eventDescs[equiv[0] + '*' + i] =
//           (id,                  triggerId,           roles,                         klass)
new EventDesc(okEquivSpans[i - 1], okEquivSpans[i - 1], [[equiv[1], okEquivSpans[i]]], 'equiv');
eventDesc.leftSpans = okEquivSpans.slice(0, i);
eventDesc.rightSpans = okEquivSpans.slice(i);
}
});
$.each(sourceData.relations, function(relNo, rel) {
// rel[2] is args, rel[2][a][0] is role and rel[2][a][1] is value for a in (0,1)
var argsDesc = relationTypesHash[rel[1]];
argsDesc = argsDesc && argsDesc.args;
var t1, t2;
if (argsDesc) {
// sort the arguments according to the config
var args = {}
args[rel[2][0][0]] = rel[2][0][1];
args[rel[2][1][0]] = rel[2][1][1];
t1 = args[argsDesc[0].role];
t2 = args[argsDesc[1].role];
} else {
// (or leave as-is in its absence)
t1 = rel[2][0][1];
t2 = rel[2][1][1];
}
data.eventDescs[rel[0]] =
//           (id, triggerId, roles,          klass)
new EventDesc(t1, t1,        [[rel[1], t2]], 'relation');
});

// attributes
$.each(sourceData.attributes, function(attrNo, attr) {
// attr: [id, name, spanId, value, cueSpanId

// TODO: might wish to check what's appropriate for the type
// instead of using the first attribute def found
var attrType = (eventAttributeTypes[attr[1]] ||
entityAttributeTypes[attr[1]]);
var attrValue = attrType && attrType.values[attrType.bool || attr[3]];
var span = data.spans[attr[2]];
if (!span) {
dispatcher.post('messages', [[['Annotation ' + attr[2] + ', referenced from attribute ' + attr[0] + ', does not exist.', 'error']]]);
return;
}
var valText = (attrValue && attrValue.name) || attr[3];
var attrText = attrType
? (attrType.bool ? attrType.name : (attrType.name + ': ' + valText))
: (attr[3] == true ? attr[1] : attr[1] + ': ' + attr[3]);
span.attributeText.push(attrText);
span.attributes[attr[1]] = attr[3];
if (attr[4]) { // cue
span.attributeCues[attr[1]] = attr[4];
var cueSpan = data.spans[attr[4]];
cueSpan.attributeCueFor[data.spans[1]] = attr[2];
cueSpan.cue = 'CUE'; // special css type
}
$.extend(span.attributeMerge, attrValue);
});

// comments
$.each(sourceData.comments, function(commentNo, comment) {
// comment: [entityId, type, text]

// TODO error handling

// sentence id: ['sent', sentId]
if (comment[0] instanceof Array && comment[0][0] == 'sent') {
// sentence comment
var sent = comment[0][1];
var text = comment[2];
if (data.sentComment[sent]) {
text = data.sentComment[sent].text + '<br/>' + text;
}
data.sentComment[sent] = { type: comment[1], text: text };
} else {
var id = comment[0];
var trigger = triggerHash[id];
var eventDesc = data.eventDescs[id];
var commentEntities =
trigger
? trigger[1] // trigger: [span, ...]
: id in data.spans
? [data.spans[id]] // span: [span]
: id in data.eventDescs
? [data.eventDescs[id]] // arc: [eventDesc]
: [];
$.each(commentEntities, function(entityId, entity) {
// if duplicate comment for entity:
// overwrite type, concatenate comment with a newline
if (!entity.comment) {
entity.comment = { type: comment[1], text: comment[2] };
} else {
entity.comment.type = comment[1];
entity.comment.text += "\n" + comment[2];
}
// partially duplicate marking of annotator note comments
if (comment[1] == "AnnotatorNotes") {
entity.annotatorNotes = comment[2];
}
// prioritize type setting when multiple comments are present
if (commentPriority(comment[1]) > commentPriority(entity.shadowClass)) {
entity.shadowClass = comment[1];
}
});
}
});

// normalizations
$.each(sourceData.normalizations, function(normNo, norm) {
var id = norm[0];
var normType = norm[1];
var target = norm[2];
var refdb = norm[3];
var refid = norm[4];
var reftext = norm[5];

// grab entity / event the normalization applies to
var span = data.spans[target];
if (!span) {
dispatcher.post('messages', [[['Annotation ' + target + ', referenced from normalization ' + id + ', does not exist.', 'error']]]);
return;
}

// TODO: do we have any possible use for the normType?
span.normalizations.push([refdb, refid, reftext]);

// quick hack for span box visual style
span.normalized = 'Normalized';
});

// prepare span boundaries for token containment testing
var sortedFragments = [];
$.each(data.spans, function(spanNo, span) {
$.each(span.fragments, function(fragmentNo, fragment) {
sortedFragments.push(fragment);
});
});
// sort fragments by beginning, then by end
sortedFragments.sort(function(a, b) {
var x = a.from;
var y = b.from;
if (x == y) {
x = a.to;
y = b.to;
}
return ((x < y) ? -1 : ((x > y) ? 1 : 0));
});
var currentFragmentId = 0;
var startFragmentId = 0;
var numFragments = sortedFragments.length;
var lastTo = 0;
var firstFrom = null;
var chunkNo = 0;
var space;
var chunk = null;
// token containment testing (chunk recognition)
$.each(sourceData.token_offsets, function() {
var from = this[0];
var to = this[1];
if (firstFrom === null) firstFrom = from;

// Replaced for speedup; TODO check correctness
// inSpan = false;
// $.each(data.spans, function(spanNo, span) {
//   if (span.from < to && to < span.to) {
//     // it does; no word break
//     inSpan = true;
//     return false;
//   }
// });

// Is the token end inside a span?
if (startFragmentId && to > sortedFragments[startFragmentId - 1].to) {
while (startFragmentId < numFragments && to > sortedFragments[startFragmentId].from) {
startFragmentId++;
}
}
currentFragmentId = startFragmentId;
while (currentFragmentId < numFragments && to >= sortedFragments[currentFragmentId].to) {
currentFragmentId++;
}
// if yes, the next token is in the same chunk
if (currentFragmentId < numFragments && to > sortedFragments[currentFragmentId].from) {
return;
}

// otherwise, create the chunk found so far
space = data.text.substring(lastTo, firstFrom);
var text = data.text.substring(firstFrom, to);
if (chunk) chunk.nextSpace = space;
//               (index,     text, from,      to, space) {
chunk = new Chunk(chunkNo++, text, firstFrom, to, space);
data.chunks.push(chunk);
lastTo = to;
firstFrom = null;
});
var numChunks = chunkNo;

// find sentence boundaries in relation to chunks
chunkNo = 0;
var sentenceNo = 0;
var pastFirst = false;
$.each(sourceData.sentence_offsets, function() {
var from = this[0];
if (chunkNo >= numChunks) return false;
if (data.chunks[chunkNo].from > from) return;
var chunk;
while (chunkNo < numChunks && (chunk = data.chunks[chunkNo]).from < from) {
chunkNo++;
}
chunkNo++;
if (pastFirst && from <= chunk.from) {
var numNL = chunk.space.split("\n").length - 1;
if (!numNL) numNL = 1;
sentenceNo += numNL;
chunk.sentence = sentenceNo;
} else {
pastFirst = true;
}
});

// assign fragments to appropriate chunks
var currentChunkId = 0;
var chunk;
$.each(sortedFragments, function(fragmentId, fragment) {
while (fragment.to > (chunk = data.chunks[currentChunkId]).to) currentChunkId++;
chunk.fragments.push(fragment);
fragment.text = chunk.text.substring(fragment.from - chunk.from, fragment.to - chunk.from);
fragment.chunk = chunk;
});

// assign arcs to spans; calculate arc distances
$.each(data.eventDescs, function(eventNo, eventDesc) {
var dist = 0;
var origin = data.spans[eventDesc.id];
if (!origin) {
// TODO: include missing trigger ID in error message
dispatcher.post('messages', [[['<strong>ERROR</strong><br/>Trigger for event "' + eventDesc.id + '" not found in ' + data.document + '<br/>(please correct the source data)', 'error', 5]]]);
return;
}
var here = origin.headFragment.from + origin.headFragment.to;
$.each(eventDesc.roles, function(roleNo, role) {
var target = data.spans[role.targetId];
if (!target) {
dispatcher.post('messages', [[['<strong>ERROR</strong><br/>"' + role.targetId + '" (referenced from "' + eventDesc.id + '") not found in ' + data.document + '<br/>(please correct the source data)', 'error', 5]]]);
return;
}
var there = target.headFragment.from + target.headFragment.to;
var dist = Math.abs(here - there);
var arc = new Arc(eventDesc, role, dist, eventNo);
origin.totalDist += dist;
origin.numArcs++;
target.totalDist += dist;
target.numArcs++;
data.arcs.push(arc);
target.incoming.push(arc);
origin.outgoing.push(arc);
// ID dict for easy access. TODO: have a function defining the
// (origin,type,target)->id mapping (see also annotator_ui.js)
var arcId = origin.id + '--' + role.type + '--' + target.id;
data.arcById[arcId] = arc;
}); // roles
}); // eventDescs

// highlighting
markedText = [];
setMarked('edited'); // set by editing process
setMarked('focus'); // set by URL
setMarked('matchfocus'); // set by search process, focused match
setMarked('match'); // set by search process, other (non-focused) match

$.each(data.spans, function(spanId, span) {
// calculate average arc distances
// average distance of arcs (0 for no arcs)
span.avgDist = span.numArcs ? span.totalDist / span.numArcs : 0;
lastSpan = span;

// collect fragment texts into span texts
var fragmentTexts = [];
$.each(span.fragments, function(fragmentNo, fragment) {
// TODO heuristics
fragmentTexts.push(fragment.text);
});
span.text = fragmentTexts.join('');
}); // data.spans

for (var i = 0; i < 2; i++) {
// preliminary sort to assign heights for basic cases
// (first round) and cases resolved in the previous
// round(s).
$.each(data.chunks, function(chunkNo, chunk) {
// sort
chunk.fragments.sort(fragmentComparator);
// renumber
$.each(chunk.fragments, function(fragmentNo, fragment) {
fragment.indexNumber = fragmentNo;
});
});
// nix the sums, so we can sum again
$.each(data.spans, function(spanNo, span) {
span.refedIndexSum = 0;
});
// resolved cases will now have indexNumber set
// to indicate their relative order. Sum those for referencing cases
// for use in iterative resorting
$.each(data.arcs, function(arcNo, arc) {
data.spans[arc.origin].refedIndexSum += data.spans[arc.target].headFragment.indexNumber;
});
}

// Final sort of fragments in chunks for drawing purposes
// Also identify the marked text boundaries regarding chunks
$.each(data.chunks, function(chunkNo, chunk) {
// and make the next sort take this into account. Note that this will
// now resolve first-order dependencies between sort orders but not
// second-order or higher.
chunk.fragments.sort(fragmentComparator);
$.each(chunk.fragments, function(fragmentNo, fragment) {
fragment.drawOrder = fragmentNo;
});
});

data.spanDrawOrderPermutation = Object.keys(data.spans);
data.spanDrawOrderPermutation.sort(function(a, b) {
var spanA = data.spans[a];
var spanB = data.spans[b];

// We're jumping all over the chunks, but it's enough that
// we're doing everything inside each chunk in the right
// order. should it become necessary to actually do these in
// linear order, put in a similar condition for
// spanX.headFragment.chunk.index; but it should not be
// needed.

var tmp = spanA.headFragment.drawOrder - spanB.headFragment.drawOrder;
if (tmp) return tmp < 0 ? -1 : 1;

return 0;
});

// resort the spans for linear order by center
sortedFragments.sort(midpointComparator);

// sort fragments into towers, calculate average arc distances
var lastFragment = null;
var towerId = -1;
$.each(sortedFragments, function(i, fragment) {
if (!lastFragment || (lastFragment.from != fragment.from || lastFragment.to != fragment.to)) {
towerId++;
}
fragment.towerId = towerId;
lastFragment = fragment;
}); // sortedFragments

// find curlies (only the first fragment drawn in a tower)
$.each(data.spanDrawOrderPermutation, function(spanIdNo, spanId) {
var span = data.spans[spanId];

$.each(span.fragments, function(fragmentNo, fragment) {
if (!data.towers[fragment.towerId]) {
data.towers[fragment.towerId] = [];
fragment.drawCurly = true;
fragment.span.drawCurly = true;
}
data.towers[fragment.towerId].push(fragment);
});
});

var spanAnnTexts = {};

$.each(data.chunks, function(chunkNo, chunk) {
chunk.markedTextStart = [];
chunk.markedTextEnd = [];

$.each(chunk.fragments, function(fragmentNo, fragment) {
if (chunk.firstFragmentIndex == undefined) {
chunk.firstFragmentIndex = fragment.towerId;
}
chunk.lastFragmentIndex = fragment.towerId;

var spanLabels = Util.getSpanLabels(spanTypes, fragment.span.type);
fragment.labelText = Util.spanDisplayForm(spanTypes, fragment.span.type);
// Find the most appropriate label according to text width
if (Configuration.abbrevsOn && spanLabels) {
var labelIdx = 1; // first abbrev
var maxLength = (fragment.to - fragment.from) / 0.8;
while (fragment.labelText.length > maxLength &&
spanLabels[labelIdx]) {
fragment.labelText = spanLabels[labelIdx];
labelIdx++;
}
}

var svgtext = svg.createText(); // one "text" element per row
var postfixArray = [];
var prefix = '';
var postfix = '';
var warning = false;
$.each(fragment.span.attributes, function(attrType, valType) {
// TODO: might wish to check what's appropriate for the type
// instead of using the first attribute def found
var attr = (eventAttributeTypes[attrType] ||
entityAttributeTypes[attrType]);
if (!attr) {
// non-existent type
warning = true;
return;
}
var val = attr.values[attr.bool || valType];
if (!val) {
// non-existent value
warning = true;
return;
}
if ($.isEmptyObject(val)) {
// defined, but lacks any visual presentation
warning = true;
return;
}
if (val.glyph) {
if (val.position == "left") {
prefix = val.glyph + prefix;
var css = 'glyph';
if (attr.css) css += ' glyph_' + Util.escapeQuotes(attr.css);
svgtext.span(val.glyph, { 'class': css });
} else { // XXX right is implied - maybe change
postfixArray.push([attr, val]);
postfix += val.glyph;
}
}
});
var text = fragment.labelText;
if (prefix !== '') {
text = prefix + ' ' + text;
svgtext.string(' ');
}
svgtext.string(fragment.labelText);
if (postfixArray.length) {
text += ' ' + postfix;
svgtext.string(' ');
$.each(postfixArray, function(elNo, el) {
var css = 'glyph';
if (el[0].css) css += ' glyph_' + Util.escapeQuotes(el[0].css);
svgtext.span(el[1].glyph, { 'class': css });
});
}
if (warning) {
svgtext.span("#", { 'class': 'glyph attribute_warning' });
text += ' #';
}
fragment.glyphedLabelText = text;

if (!spanAnnTexts[text]) {
spanAnnTexts[text] = true;
data.spanAnnTexts[text] = svgtext;
}
}); // chunk.fragments
}); // chunks

var numChunks = data.chunks.length;
// note the location of marked text with respect to chunks
var startChunk = 0;
var currentChunk;
// sort by "from"; we don't need to sort by "to" as well,
// because unlike spans, chunks are disjunct
markedText.sort(function(a, b) {
return Util.cmp(a[0], b[0]);
});
$.each(markedText, function(textNo, textPos) {
var from = textPos[0];
var to = textPos[1];
var markedType = textPos[2];
if (from < 0) from = 0;
if (to < 0) to = 0;
if (to >= data.text.length) to = data.text.length - 1;
if (from > to) from = to;
while (startChunk < numChunks) {
var chunk = data.chunks[startChunk];
if (from <= chunk.to) {
chunk.markedTextStart.push([textNo, true, from - chunk.from, null, markedType]);
break;
}
startChunk++;
}
if (startChunk == numChunks) {
dispatcher.post('messages', [[['Wrong text offset', 'error']]]);
return;
}
currentChunk = startChunk;
while (currentChunk < numChunks) {
var chunk = data.chunks[currentChunk];
if (to <= chunk.to) {
chunk.markedTextEnd.push([textNo, false, to - chunk.from]);
break
}
currentChunk++;
}
if (currentChunk == numChunks) {
dispatcher.post('messages', [[['Wrong text offset', 'error']]]);
var chunk = data.chunks[data.chunks.length - 1];
chunk.markedTextEnd.push([textNo, false, chunk.text.length]);
return;
}
}); // markedText

dispatcher.post('dataReady', [data]);
};

var resetData = function() {
setData(sourceData);
renderData();
}

var translate = function(element, x, y) {
$(element.group).attr('transform', 'translate(' + x + ', ' + y + ')');
element.translation = { x: x, y: y };
};

var showMtime = function() {
if (data.mtime) {
// we're getting seconds and need milliseconds
//$('#document_ctime').text("Created: " + Annotator.formatTime(1000 * data.ctime)).css("display", "inline");
$('#document_mtime').text("Last modified: " + Util.formatTimeAgo(1000 * data.mtime)).css("display", "inline");
} else {
//$('#document_ctime').css("display", "none");
$('#document_mtime').css("display", "none");
}
};

var addHeaderAndDefs = function() {
var commentName = (coll + '/' + doc).replace('--', '-\\-');
$svg.append('<!-- document: ' + commentName + ' -->');
var defs = svg.defs();
var $blurFilter = $('<filter id="Gaussian_Blur"><feGaussianBlur in="SourceGraphic" stdDeviation="2" /></filter>');
svg.add(defs, $blurFilter);
return defs;
}

var getTextMeasurements = function(textsHash, options, callback) {
// make some text elements, find out the dimensions
var textMeasureGroup = svg.group(options);

// changed from $.each because of #264 ('length' can appear)
for (var text in textsHash) {
if (textsHash.hasOwnProperty(text)) {
svg.text(textMeasureGroup, 0, 0, text);
}
}

// measuring goes on here
var widths = {};
$(textMeasureGroup).find('text').each(function(svgTextNo, svgText) {
var text = $(svgText).text();
widths[text] = this.getComputedTextLength();

if (callback) {
$.each(textsHash[text], function(text, object) {
callback(object, svgText);
});
}
});
var bbox = textMeasureGroup.getBBox();
svg.remove(textMeasureGroup);

return new Measurements(widths, bbox.height, bbox.y);
};

var getTextAndSpanTextMeasurements = function() {
// get the span text sizes
var chunkTexts = {}; // set of span texts
$.each(data.chunks, function(chunkNo, chunk) {
chunk.row = undefined; // reset
if (!(chunk.text in chunkTexts)) chunkTexts[chunk.text] = []
var chunkText = chunkTexts[chunk.text];

// here we also need all the spans that are contained in
// chunks with this text, because we need to know the position
// of the span text within the respective chunk text
chunkText.push.apply(chunkText, chunk.fragments);
// and also the markedText boundaries
chunkText.push.apply(chunkText, chunk.markedTextStart);
chunkText.push.apply(chunkText, chunk.markedTextEnd);
});
var textSizes = getTextMeasurements(
chunkTexts,
undefined,
function(fragment, text) {
if (fragment instanceof Fragment) { // it's a fragment!
// measure the fragment text position in pixels
var firstChar = fragment.from - fragment.chunk.from;
if (firstChar < 0) {
firstChar = 0;
dispatcher.post('messages', [[['<strong>WARNING</strong>' +
'<br/> ' +
'The fragment [' + fragment.from + ', ' + fragment.to + '] (' + fragment.text + ') is not ' +
'contained in its designated chunk [' +
fragment.chunk.from + ', ' + fragment.chunk.to + '] most likely ' +
'due to the fragment starting or ending with a space, please ' +
'verify the sanity of your data since we are unable to ' +
'visualise this fragment correctly and will drop leading ' +
'space characters'
, 'warning', 15]]]);
}
var startPos = text.getStartPositionOfChar(firstChar).x;
var lastChar = fragment.to - fragment.chunk.from - 1;
var endPos = (lastChar < 0)
? startPos
: text.getEndPositionOfChar(lastChar).x;
fragment.curly = {
from: startPos,
to: endPos
};
} else { // it's markedText [id, start?, char#, offset]
if (fragment[2] < 0) fragment[2] = 0;
if (!fragment[2]) { // start
fragment[3] = text.getStartPositionOfChar(fragment[2]).x;
} else {
fragment[3] = text.getEndPositionOfChar(fragment[2] - 1).x + 1;
}
}
});

// get the fragment annotation text sizes
var fragmentTexts = {};
var noSpans = true;
$.each(data.spans, function(spanNo, span) {
$.each(span.fragments, function(fragmentNo, fragment) {
fragmentTexts[fragment.glyphedLabelText] = true;
noSpans = false;
});
});
if (noSpans) fragmentTexts.$ = true; // dummy so we can at least get the height
var fragmentSizes = getTextMeasurements(fragmentTexts, {'class': 'span'});

return {
texts: textSizes,
fragments: fragmentSizes
};
};

var addArcTextMeasurements = function(sizes) {
// get the arc annotation text sizes (for all labels)
var arcTexts = {};
$.each(data.arcs, function(arcNo, arc) {
var labels = Util.getArcLabels(spanTypes, data.spans[arc.origin].type, arc.type, relationTypesHash);
if (!labels.length) labels = [arc.type];
$.each(labels, function(labelNo, label) {
arcTexts[label] = true;
});
});
var arcSizes = getTextMeasurements(arcTexts, {'class': 'arcs'});
sizes.arcs = arcSizes;
};

var adjustTowerAnnotationSizes = function() {
// find biggest annotation in each tower
$.each(data.towers, function(towerNo, tower) {
var maxWidth = 0;
$.each(tower, function(fragmentNo, fragment) {
var width = data.sizes.fragments.widths[fragment.glyphedLabelText];
if (width > maxWidth) maxWidth = width;
}); // tower
$.each(tower, function(fragmentNo, fragment) {
fragment.width = maxWidth;
}); // tower
}); // data.towers
};

var makeArrow = function(defs, spec) {
var parsedSpec = spec.split(',');
var type = parsedSpec[0];
if (type == 'none') return;

var width = 5;
var height = 5;
var color = "black";
if ($.isNumeric(parsedSpec[1]) && parsedSpec[2]) {
if ($.isNumeric(parsedSpec[2]) && parsedSpec[3]) {
// 3 args, 2 numeric: assume width, height, color
width = parsedSpec[1];
height = parsedSpec[2];
color = parsedSpec[3] || 'black';
} else {
// 2 args, 1 numeric: assume width/height, color
width = height = parsedSpec[1];
color = parsedSpec[2] || 'black';
}
} else {
// other: assume color only
width = height = 5;
color = parsedSpec[1] || 'black';
}
// hash needs to be replaced as IDs don't permit it.
var arrowId = 'arrow_' + spec.replace(/#/g, '').replace(/,/g, '_');

var arrow;
if (type == 'triangle') {
arrow = svg.marker(defs, arrowId,
width, height / 2, width, height, 'auto',
{
markerUnits: 'strokeWidth',
'fill': color
});
svg.polyline(arrow, [[0, 0], [width, height / 2], [0, height], [width / 12, height / 2]]);
}
return arrowId;
}


var drawing = false;
var redraw = false;

var renderDataReal = function(sourceData) {
Util.profileEnd('before render');
Util.profileStart('render');
Util.profileStart('init');

if (!sourceData && !data) {
dispatcher.post('doneRendering', [coll, doc, args]);
return;
}
$svgDiv.show();
if ((sourceData && sourceData.collection && (sourceData.document !== doc || sourceData.collection !== coll)) || drawing) {
redraw = true;
dispatcher.post('doneRendering', [coll, doc, args]);
return;
}
redraw = false;
drawing = true;

if (sourceData) setData(sourceData);
showMtime();

// clear the SVG
svg.clear(true);
if (!data || data.length == 0) return;

// establish the width according to the enclosing element
canvasWidth = that.forceWidth || $svgDiv.width();

var defs = addHeaderAndDefs();

var backgroundGroup = svg.group({ 'class': 'background' });
var glowGroup = svg.group({ 'class': 'glow' });
highlightGroup = svg.group({ 'class': 'highlight' });
var textGroup = svg.group({ 'class': 'text' });

Util.profileEnd('init');
Util.profileStart('measures');

var sizes = getTextAndSpanTextMeasurements();
data.sizes = sizes;

adjustTowerAnnotationSizes();
var maxTextWidth = 0;
for (var text in sizes.texts.widths) {
if (sizes.texts.widths.hasOwnProperty(text)) {
var width = sizes.texts.widths[text]
if (width > maxTextWidth) maxTextWidth = width;
}
}

Util.profileEnd('measures');
Util.profileStart('chunks');

var currentX = Configuration.visual.margin.x + sentNumMargin + rowPadding;
var rows = [];
var fragmentHeights = [];
var sentenceToggle = 0;
var sentenceNumber = 0;
var row = new Row(svg);
row.sentence = ++sentenceNumber;
row.backgroundIndex = sentenceToggle;
row.index = 0;
var rowIndex = 0;
var twoBarWidths; // HACK to avoid measuring space's width
var openTextHighlights = {};
var textMarkedRows = [];

addArcTextMeasurements(sizes);

// reserve places for spans
var floors = [];
var reservations = []; // reservations[chunk][floor] = [[from, to, headroom]...]
for (var i = 0; i <= data.lastFragmentIndex; i++) {
reservation[i] = {};
}
var inf = 1.0/0.0;

$.each(data.spanDrawOrderPermutation, function(spanIdNo, spanId) {
var span = data.spans[spanId];

var f1 = span.fragments[0];
var f2 = span.fragments[span.fragments.length - 1];

var x1 = (f1.curly.from + f1.curly.to - f1.width) / 2 -
Configuration.visual.margin.x;
var i1 = f1.chunk.index;

var x2 = (f2.curly.from + f2.curly.to + f2.width) / 2 +
Configuration.visual.margin.x;
var i2 = f2.chunk.index;

// Start from the ground level, going up floor by floor.
// If no more floors, make a new available one.
// If a floor is available and there is no carpet, mark it as carpet.
// If a floor is available and there is carpet and height
//   difference is at least fragment height + curly, OK.
// If a floor is not available, forget about carpet.
// --
// When OK, calculate exact ceiling.
// If there isn't one, make a new floor, copy reservations
//   from floor below (with decreased ceiling)
// Make the reservation from the carpet to just below the
//   current floor.
//
// TODO drawCurly and height could be prettified to only check
// actual positions of curlies
var carpet = 0;
var outside = true;
var thisCurlyHeight = span.drawCurly ? Configuration.visual.curlyHeight : 0;
var height = sizes.fragments.height + thisCurlyHeight + Configuration.visual.boxSpacing +
2 * Configuration.visual.margin.y - 3;
$.each(floors, function(floorNo, floor) {
var floorAvailable = true;
for (var i = i1; i <= i2; i++) {
if (!(reservations[i] && reservations[i][floor])) continue;
var from = (i == i1) ? x1 : -inf;
var to = (i == i2) ? x2 : inf;
$.each(reservations[i][floor], function(resNo, res) {
if (res[0] < to && from < res[1]) {
floorAvailable = false;
return false;
}
});
}
if (floorAvailable) {
if (carpet === null) {
carpet = floor;
} else if (height + carpet <= floor) {
// found our floor!
outside = false;
return false;
}
} else {
carpet = null;
}
});
var reslen = reservations.length;
var makeNewFloorIfNeeded = function(floor) {
var floorNo = $.inArray(floor, floors);
if (floorNo == -1) {
floors.push(floor);
floors.sort(Util.cmp);
floorNo = $.inArray(floor, floors);
if (floorNo != 0) {
// copy reservations from the floor below
var parquet = floors[floorNo - 1];
for (var i = 0; i <= reslen; i++) {
if (reservations[i]) {
if (!reservations[i][parquet]) {
reservations[i][parquet] = [];
}
var footroom = floor - parquet;
$.each(reservations[i][parquet], function(resNo, res) {
if (res[2] > footroom) {
if (!reservations[i][floor]) {
reservations[i][floor] = [];
}
reservations[i][floor].push([res[0], res[1], res[2] - footroom]);
}
});
}
}
}
}
return floorNo;
}
var ceiling = carpet + height;
var ceilingNo = makeNewFloorIfNeeded(ceiling);
var carpetNo = makeNewFloorIfNeeded(carpet);
// make the reservation
var floor, floorNo;
for (floorNo = carpetNo;
(floor = floors[floorNo]) !== undefined && floor < ceiling;
floorNo++) {
var headroom = ceiling - floor;
for (var i = i1; i <= i2; i++) {
var from = (i == i1) ? x1 : 0;
var to = (i == i2) ? x2 : inf;
if (!reservations[i]) reservations[i] = {};
if (!reservations[i][floor]) reservations[i][floor] = [];
reservations[i][floor].push([from, to, headroom]); // XXX maybe add fragment; probably unnecessary
}
}
span.floor = carpet + thisCurlyHeight;
});

$.each(data.chunks, function(chunkNo, chunk) {
reservations = new Array();
chunk.group = svg.group(row.group);
chunk.highlightGroup = svg.group(chunk.group);

var y = 0;
var minArcDist;
var hasLeftArcs, hasRightArcs, hasInternalArcs;
var hasAnnotations;
var chunkFrom = Infinity;
var chunkTo = 0;
var chunkHeight = 0;
var spacing = 0;
var spacingChunkId = null;
var spacingRowBreak = 0;

$.each(chunk.fragments, function(fragmentNo, fragment) {
var span = fragment.span;
var spanDesc = spanTypes[span.type];
var bgColor = ((spanDesc && spanDesc.bgColor) ||
(spanTypes.SPAN_DEFAULT &&
spanTypes.SPAN_DEFAULT.bgColor) || '#ffffff');
var fgColor = ((spanDesc && spanDesc.fgColor) ||
(spanTypes.SPAN_DEFAULT &&
spanTypes.SPAN_DEFAULT.fgColor) || '#000000');
var borderColor = ((spanDesc && spanDesc.borderColor) ||
(spanTypes.SPAN_DEFAULT &&
spanTypes.SPAN_DEFAULT.borderColor) || '#000000');

// special case: if the border 'color' value is 'darken',
// then just darken the BG color a bit for the border.
if (borderColor == 'darken') {
borderColor = Util.adjustColorLightness(bgColor, -0.6);
}

fragment.group = svg.group(chunk.group, {
'class': 'span'
});

var fragmentHeight = 0;

if (!y) y = -sizes.texts.height;
var x = (fragment.curly.from + fragment.curly.to) / 2;

// XXX is it maybe sizes.texts?
var yy = y + sizes.fragments.y;
var hh = sizes.fragments.height;
var ww = fragment.width;
var xx = x - ww / 2;

// text margin fine-tuning
yy += boxTextMargin.y;
hh -= 2*boxTextMargin.y;
xx += boxTextMargin.x;
ww -= 2*boxTextMargin.x;
var rectClass = 'span_' + (span.cue || span.type) + ' span_default'; // TODO XXX first part unneeded I think; remove

// attach e.g. "False_positive" into the type
if (span.comment && span.comment.type) { rectClass += ' '+span.comment.type; }
var bx = xx - Configuration.visual.margin.x - boxTextMargin.x;
var by = yy - Configuration.visual.margin.y;
var bw = ww + 2 * Configuration.visual.margin.x;
var bh = hh + 2 * Configuration.visual.margin.y;

if (roundCoordinates) {
x  = (x|0)+0.5;
bx = (bx|0)+0.5;
}

var shadowRect;
var markedRect;
if (span.marked) {
markedRect = svg.rect(chunk.highlightGroup,
bx - markedSpanSize, by - markedSpanSize,
bw + 2 * markedSpanSize, bh + 2 * markedSpanSize, {

// filter: 'url(#Gaussian_Blur)',
'class': "shadow_EditHighlight",
rx: markedSpanSize,
ry: markedSpanSize
});
svg.other(markedRect, 'animate', {
'data-type': span.marked,
attributeName: 'fill',
values: (span.marked == 'match'? highlightMatchSequence
: highlightSpanSequence),
dur: highlightDuration,
repeatCount: 'indefinite',
begin: 'indefinite'
});
chunkFrom = Math.min(bx - markedSpanSize, chunkFrom);
chunkTo = Math.max(bx + bw + markedSpanSize, chunkTo);
fragmentHeight = Math.max(bh + 2 * markedSpanSize, fragmentHeight);
}
// .match() removes unconfigured shadows, which were
// always showing up as black.
// TODO: don't hard-code configured shadowclasses.
if (span.shadowClass &&
span.shadowClass.match('True_positive|False_positive|False_negative|AnnotationError|AnnotationWarning|AnnotatorNotes|Normalized|AnnotationIncomplete|AnnotationUnconfirmed|rectEditHighlight|EditHighlight_arc|MissingAnnotation|ChangedAnnotation ')) {
shadowRect = svg.rect(fragment.group,
bx - rectShadowSize, by - rectShadowSize,
bw + 2 * rectShadowSize, bh + 2 * rectShadowSize, {
'class': 'shadow_' + span.shadowClass,
filter: 'url(#Gaussian_Blur)',
rx: rectShadowRounding,
ry: rectShadowRounding
});
chunkFrom = Math.min(bx - rectShadowSize, chunkFrom);
chunkTo = Math.max(bx + bw + rectShadowSize, chunkTo);
fragmentHeight = Math.max(bh + 2 * rectShadowSize, fragmentHeight);
}
fragment.rect = svg.rect(fragment.group,
bx, by, bw, bh, {

'class': rectClass,
fill: bgColor,
stroke: borderColor,
rx: Configuration.visual.margin.x,
ry: Configuration.visual.margin.y,
'data-span-id': span.id,
'data-fragment-id': fragment.id,
'strokeDashArray': span.attributeMerge.dashArray
});

// TODO XXX: quick nasty hack to allow normalizations
// to be marked visually; do something cleaner!
if (span.normalized) {
$(fragment.rect).addClass(span.normalized);
}

fragment.right = bx + bw; // TODO put it somewhere nicer?
if (!(span.shadowClass || span.marked)) {
chunkFrom = Math.min(bx, chunkFrom);
chunkTo = Math.max(bx + bw, chunkTo);
fragmentHeight = Math.max(bh, fragmentHeight);
}

fragment.rectBox = { x: bx, y: by - span.floor, width: bw, height: bh };
fragment.height = span.floor + hh + 3 * Configuration.visual.margin.y + Configuration.visual.curlyHeight + Configuration.visual.arcSpacing;
var spacedTowerId = fragment.towerId * 2;
if (!fragmentHeights[spacedTowerId] || fragmentHeights[spacedTowerId] < fragment.height) {
fragmentHeights[spacedTowerId] = fragment.height;
}
$(fragment.rect).attr('y', yy - Configuration.visual.margin.y - span.floor);
if (shadowRect) {
$(shadowRect).attr('y', yy - rectShadowSize - Configuration.visual.margin.y - span.floor);
}
if (markedRect) {
$(markedRect).attr('y', yy - markedSpanSize - Configuration.visual.margin.y - span.floor);
}
if (span.attributeMerge.box === "crossed") {
svg.path(fragment.group, svg.createPath().
move(xx, yy - Configuration.visual.margin.y - span.floor).
line(xx + fragment.width,
yy + hh + Configuration.visual.margin.y - span.floor),
{ 'class': 'boxcross' });
svg.path(fragment.group, svg.createPath().
move(xx + fragment.width, yy - Configuration.visual.margin.y - span.floor).
line(xx, yy + hh + Configuration.visual.margin.y - span.floor),
{ 'class': 'boxcross' });
}
var fragmentText = svg.text(fragment.group, x, y - span.floor, data.spanAnnTexts[fragment.glyphedLabelText], { fill: fgColor });

// Make curlies to show the fragment
if (fragment.drawCurly) {
var curlyColor = 'grey';
if (coloredCurlies) {
var spanDesc = spanTypes[span.type];
var bgColor = ((spanDesc && spanDesc.bgColor) ||
(spanTypes.SPAN_DEFAULT &&
spanTypes.SPAN_DEFAULT.fgColor) ||
'#000000');
curlyColor = Util.adjustColorLightness(bgColor, -0.6);
}

var bottom = yy + hh + Configuration.visual.margin.y - span.floor + 1;
svg.path(fragment.group, svg.createPath()
.move(fragment.curly.from, bottom + Configuration.visual.curlyHeight)
.curveC(fragment.curly.from, bottom,
x, bottom + Configuration.visual.curlyHeight,
x, bottom)
.curveC(x, bottom + Configuration.visual.curlyHeight,
fragment.curly.to, bottom,
fragment.curly.to, bottom + Configuration.visual.curlyHeight),
{
'class': 'curly',
'stroke': curlyColor
});
chunkFrom = Math.min(fragment.curly.from, chunkFrom);
chunkTo = Math.max(fragment.curly.to, chunkTo);
fragmentHeight = Math.max(Configuration.visual.curlyHeight, fragmentHeight);
}

if (fragment == span.headFragment) {
// find the gap to fit the backwards arcs, but only on
// head fragment - other fragments don't have arcs
$.each(span.incoming, function(arcId, arc) {
var leftSpan = data.spans[arc.origin];
var origin = leftSpan.headFragment.chunk;
var border;
if (chunk.index == origin.index) {
hasInternalArcs = true;
}
if (origin.row) {
var labels = Util.getArcLabels(spanTypes, leftSpan.type, arc.type, relationTypesHash);
if (!labels.length) labels = [arc.type];
if (origin.row.index == rowIndex) {
// same row, but before this
border = origin.translation.x + leftSpan.fragments[leftSpan.fragments.length - 1].right;
} else {
border = Configuration.visual.margin.x + sentNumMargin + rowPadding;
}
var labelNo = Configuration.abbrevsOn ? labels.length - 1 : 0;
var smallestLabelWidth = sizes.arcs.widths[labels[labelNo]] + 2 * minArcSlant;
var gap = currentX + bx - border;
var arcSpacing = smallestLabelWidth - gap;
if (!hasLeftArcs || spacing < arcSpacing) {
spacing = arcSpacing;
spacingChunkId = origin.index + 1;
}
arcSpacing = smallestLabelWidth - bx;
if (!hasLeftArcs || spacingRowBreak < arcSpacing) {
spacingRowBreak = arcSpacing;
}
hasLeftArcs = true;
} else {
hasRightArcs = true;
}
});
$.each(span.outgoing, function(arcId, arc) {
var leftSpan = data.spans[arc.target];
var target = leftSpan.headFragment.chunk;
var border;
if (target.row) {
var labels = Util.getArcLabels(spanTypes, span.type, arc.type, relationTypesHash);
if (!labels.length) labels = [arc.type];
if (target.row.index == rowIndex) {
// same row, but before this
border = target.translation.x + leftSpan.fragments[leftSpan.fragments.length - 1].right;
} else {
border = Configuration.visual.margin.x + sentNumMargin + rowPadding;
}
var labelNo = Configuration.abbrevsOn ? labels.length - 1 : 0;
var smallestLabelWidth = sizes.arcs.widths[labels[labelNo]] + 2 * minArcSlant;
var gap = currentX + bx - border;
var arcSpacing = smallestLabelWidth - gap;
if (!hasLeftArcs || spacing < arcSpacing) {
spacing = arcSpacing;
spacingChunkId = target.index + 1;
}
arcSpacing = smallestLabelWidth - bx;
if (!hasLeftArcs || spacingRowBreak < arcSpacing) {
spacingRowBreak = arcSpacing;
}
hasLeftArcs = true;
} else {
hasRightArcs = true;
}
});
}
fragmentHeight += span.floor || Configuration.visual.curlyHeight;
if (fragmentHeight > chunkHeight) chunkHeight = fragmentHeight;
hasAnnotations = true;
}); // fragments

// positioning of the chunk
chunk.right = chunkTo;
var textWidth = sizes.texts.widths[chunk.text];
chunkHeight += sizes.texts.height;
var boxX = -Math.min(chunkFrom, 0);
var boxWidth =
Math.max(textWidth, chunkTo) -
Math.min(0, chunkFrom);
// if (hasLeftArcs) {
// TODO change this with smallestLeftArc
// var spacing = arcHorizontalSpacing - (currentX - lastArcBorder);
// arc too small?
if (spacing > 0) currentX += spacing;
// }
var rightBorderForArcs = hasRightArcs ? arcHorizontalSpacing : (hasInternalArcs ? arcSlant : 0);

var lastX = currentX;
var lastRow = row;

if (chunk.sentence) {
while (sentenceNumber < chunk.sentence) {
sentenceNumber++;
row.arcs = svg.group(row.group, { 'class': 'arcs' });
rows.push(row);
row = new Row(svg);
sentenceToggle = 1 - sentenceToggle;
row.backgroundIndex = sentenceToggle;
row.index = ++rowIndex;
}
sentenceToggle = 1 - sentenceToggle;
}

if (chunk.sentence ||
currentX + boxWidth + rightBorderForArcs >= canvasWidth - 2 * Configuration.visual.margin.x) {
// the chunk does not fit
row.arcs = svg.group(row.group, { 'class': 'arcs' });
// TODO: related to issue #571
// replace arcHorizontalSpacing with a calculated value
currentX = Configuration.visual.margin.x + sentNumMargin + rowPadding +
(hasLeftArcs ? arcHorizontalSpacing : (hasInternalArcs ? arcSlant : 0));
if (hasLeftArcs) {
var adjustedCurTextWidth = sizes.texts.widths[chunk.text] + arcHorizontalSpacing;
if (adjustedCurTextWidth > maxTextWidth) {
maxTextWidth = adjustedCurTextWidth;
}
}
if (spacingRowBreak > 0) {
currentX += spacingRowBreak;
spacing = 0; // do not center intervening elements
}

// new row
rows.push(row);

svg.remove(chunk.group);
row = new Row(svg);
row.backgroundIndex = sentenceToggle;
row.index = ++rowIndex;
svg.add(row.group, chunk.group);
chunk.group = row.group.lastElementChild;
$(chunk.group).children("g[class='span']").
each(function(index, element) {
chunk.fragments[index].group = element;
});
$(chunk.group).find("rect[data-span-id]").
each(function(index, element) {
chunk.fragments[index].rect = element;
});
}

// break the text highlights when the row breaks
if (row.index !== lastRow.index) {
$.each(openTextHighlights, function(textId, textDesc) {
if (textDesc[3] != lastX) {
var newDesc = [lastRow, textDesc[3], lastX + boxX, textDesc[4]];
textMarkedRows.push(newDesc);
}
textDesc[3] = currentX;
});
}

// open text highlights
$.each(chunk.markedTextStart, function(textNo, textDesc) {
textDesc[3] += currentX + boxX;
openTextHighlights[textDesc[0]] = textDesc;
});

// close text highlights
$.each(chunk.markedTextEnd, function(textNo, textDesc) {
textDesc[3] += currentX + boxX;
var startDesc = openTextHighlights[textDesc[0]];
delete openTextHighlights[textDesc[0]];
markedRow = [row, startDesc[3], textDesc[3], startDesc[4]];
textMarkedRows.push(markedRow);
});

// XXX check this - is it used? should it be lastRow?
if (hasAnnotations) row.hasAnnotations = true;

if (chunk.sentence) {
row.sentence = ++sentenceNumber;
}

if (spacing > 0) {
// if we added a gap, center the intervening elements
spacing /= 2;
var firstChunkInRow = row.chunks[row.chunks.length - 1];
if (spacingChunkId < firstChunkInRow.index) {
spacingChunkId = firstChunkInRow.index + 1;
}
for (var chunkIndex = spacingChunkId; chunkIndex < chunk.index; chunkIndex++) {
var movedChunk = data.chunks[chunkIndex];
translate(movedChunk, movedChunk.translation.x + spacing, 0);
movedChunk.textX += spacing;
}
}

row.chunks.push(chunk);
chunk.row = row;

translate(chunk, currentX + boxX, 0);
chunk.textX = currentX + boxX;

var spaceWidth = 0;
var spaceLen = chunk.nextSpace && chunk.nextSpace.length || 0;
for (var i = 0; i < spaceLen; i++) spaceWidth += spaceWidths[chunk.nextSpace[i]] || 0;
currentX += spaceWidth + boxWidth;
}); // chunks

// finish the last row
row.arcs = svg.group(row.group, { 'class': 'arcs' });
rows.push(row);

Util.profileEnd('chunks');
Util.profileStart('arcsPrep');

var arrows = {};
var arrow = makeArrow(defs, 'none');
if (arrow) arrows['none'] = arrow;

var len = fragmentHeights.length;
for (var i = 0; i < len; i++) {
if (!fragmentHeights[i] || fragmentHeights[i] < Configuration.visual.arcStartHeight) {
fragmentHeights[i] = Configuration.visual.arcStartHeight;
}
}

// find out how high the arcs have to go
$.each(data.arcs, function(arcNo, arc) {
arc.jumpHeight = 0;
var fromFragment = data.spans[arc.origin].headFragment;
var toFragment = data.spans[arc.target].headFragment;
if (fromFragment.towerId > toFragment.towerId) {
var tmp = fromFragment; fromFragment = toFragment; toFragment = tmp;
}
var from, to;
if (fromFragment.chunk.index == toFragment.chunk.index) {
from = fromFragment.towerId;
to = toFragment.towerId;
} else {
from = fromFragment.towerId + 1;
to = toFragment.towerId - 1;
}
for (var i = from; i <= to; i++) {
if (arc.jumpHeight < fragmentHeights[i * 2]) arc.jumpHeight = fragmentHeights[i * 2];
}
});

// sort the arcs
data.arcs.sort(function(a, b) {
// first write those that have less to jump over
var tmp = a.jumpHeight - b.jumpHeight;
if (tmp) return tmp < 0 ? -1 : 1;
// if equal, then those that span less distance
tmp = a.dist - b.dist;
if (tmp) return tmp < 0 ? -1 : 1;
// if equal, then those where heights of the targets are smaller
tmp = data.spans[a.origin].headFragment.height + data.spans[a.target].headFragment.height -
data.spans[b.origin].headFragment.height - data.spans[b.target].headFragment.height;
if (tmp) return tmp < 0 ? -1 : 1;
// if equal, then those with the lower origin
tmp = data.spans[a.origin].headFragment.height - data.spans[b.origin].headFragment.height;
if (tmp) return tmp < 0 ? -1 : 1;
// if equal, they're just equal.
return 0;
});

// draw the drag arc marker
var arrowhead = svg.marker(defs, 'drag_arrow',
5, 2.5, 5, 5, 'auto',
{
markerUnits: 'strokeWidth',
'class': 'drag_fill'
});
svg.polyline(arrowhead, [[0, 0], [5, 2.5], [0, 5], [0.2, 2.5]]);

Util.profileEnd('arcsPrep');
Util.profileStart('arcs');

// add the arcs
$.each(data.arcs, function(arcNo, arc) {
// separate out possible numeric suffix from type
var noNumArcType;
var splitArcType;
if (arc.type) {
splitArcType = arc.type.match(/^(.*?)(\d*)$/);
noNumArcType = splitArcType[1];
}

var originSpan = data.spans[arc.origin];
var targetSpan = data.spans[arc.target];

var leftToRight = originSpan.headFragment.towerId < targetSpan.headFragment.towerId;
var left, right;
if (leftToRight) {
left = originSpan.headFragment;
right = targetSpan.headFragment;
} else {
left = targetSpan.headFragment;
right = originSpan.headFragment;
}

var spanDesc = spanTypes[originSpan.type];
// TODO: might make more sense to reformat this as dict instead
// of searching through the list every type
var arcDesc;
if (spanDesc && spanDesc.arcs) {
$.each(spanDesc.arcs, function(arcDescNo, arcDescIter) {
if (arcDescIter.type == arc.type) {
arcDesc = arcDescIter;
}
});
}
// fall back on unnumbered type if not found in full
if (!arcDesc && noNumArcType && noNumArcType != arc.type &&
spanDesc && spanDesc.arcs) {
$.each(spanDesc.arcs, function(arcDescNo, arcDescIter) {
if (arcDescIter.type == noNumArcType) {
arcDesc = arcDescIter;
}
});
}
// fall back on relation types in case we still don't have
// an arc description, with final fallback to unnumbered relation
if (!arcDesc) {
arcDesc = $.extend({}, relationTypesHash[arc.type] || relationTypesHash[noNumArcType]);
}
var color = ((arcDesc && arcDesc.color) ||
(spanTypes.ARC_DEFAULT && spanTypes.ARC_DEFAULT.color) ||
'#000000');
var symmetric = arcDesc && arcDesc.properties && arcDesc.properties.symmetric;
var dashArray = arcDesc && arcDesc.dashArray;
var arrowHead = ((arcDesc && arcDesc.arrowHead) ||
(spanTypes.ARC_DEFAULT && spanTypes.ARC_DEFAULT.arrowHead) ||
'triangle,5') + ',' + color;
var labelArrowHead = ((arcDesc && arcDesc.labelArrow) ||
(spanTypes.ARC_DEFAULT && spanTypes.ARC_DEFAULT.labelArrow) ||
'triangle,5') + ',' + color;

var leftBox = rowBBox(left);
var rightBox = rowBBox(right);
var leftRow = left.chunk.row.index;
var rightRow = right.chunk.row.index;

if (!arrows[arrowHead]) {
var arrow = makeArrow(defs, arrowHead);
if (arrow) arrows[arrowHead] = arrow;
}
if (!arrows[labelArrowHead]) {
var arrow = makeArrow(defs, labelArrowHead);
if (arrow) arrows[labelArrowHead] = arrow;
}

// find the next height
var height = 0;

var fromIndex2, toIndex2;
if (left.chunk.index == right.chunk.index) {
fromIndex2 = left.towerId * 2;
toIndex2 = right.towerId * 2;
} else {
fromIndex2 = left.towerId * 2 + 1;
toIndex2 = right.towerId * 2 - 1;
}
for (var i = fromIndex2; i <= toIndex2; i++) {
if (fragmentHeights[i] > height) height = fragmentHeights[i];
}
height += Configuration.visual.arcSpacing;
var leftSlantBound, rightSlantBound;
for (var i = fromIndex2; i <= toIndex2; i++) {
if (fragmentHeights[i] < height) fragmentHeights[i] = height;
}

// Adjust the height to align with pixels when rendered

// TODO: on at least Chrome, this doesn't make a difference:
// the lines come out pixel-width even without it. Check.
height += 0.5

var chunkReverse = false;
var ufoCatcher = originSpan.headFragment.chunk.index == targetSpan.headFragment.chunk.index;
if (ufoCatcher) {
chunkReverse =
leftBox.x + leftBox.width / 2 < rightBox.x + rightBox.width / 2;
}
var ufoCatcherMod = ufoCatcher ? chunkReverse ? -0.5 : 0.5 : 1;

for (var rowIndex = leftRow; rowIndex <= rightRow; rowIndex++) {
var row = rows[rowIndex];
row.hasAnnotations = true;
var arcGroup = svg.group(row.arcs, {
'data-from': arc.origin,
'data-to': arc.target
});
var from, to;

if (rowIndex == leftRow) {
from = leftBox.x + (chunkReverse ? 0 : leftBox.width);
} else {
from = sentNumMargin;
}

if (rowIndex == rightRow) {
to = rightBox.x + (chunkReverse ? rightBox.width : 0);
} else {
to = canvasWidth - 2 * Configuration.visual.margin.y;
}

var originType = data.spans[arc.origin].type;
var arcLabels = Util.getArcLabels(spanTypes, originType, arc.type, relationTypesHash);
var labelText = Util.arcDisplayForm(spanTypes, originType, arc.type, relationTypesHash);
// if (Configuration.abbrevsOn && !ufoCatcher && arcLabels) {
if (Configuration.abbrevsOn && arcLabels) {
var labelIdx = 1; // first abbreviation
// strictly speaking 2*arcSlant would be needed to allow for
// the full-width arcs to fit, but judged unabbreviated text
// to be more important than the space for arcs.
var maxLength = (to - from) - (arcSlant);
while (sizes.arcs.widths[labelText] > maxLength &&
arcLabels[labelIdx]) {
labelText = arcLabels[labelIdx];
labelIdx++;
}
}

var shadowGroup;
if (arc.shadowClass || arc.marked) {
shadowGroup = svg.group(arcGroup);
}
var options = {
'fill': color,
'data-arc-role': arc.type,
'data-arc-origin': arc.origin,
'data-arc-target': arc.target,
// TODO: confirm this is unused and remove.
//'data-arc-id': arc.id,
'data-arc-ed': arc.eventDescId
};

// construct SVG text, showing possible trailing index
// numbers (as in e.g. "Theme2") as subscripts
var svgText;
if (!splitArcType[2]) {
// no subscript, simple string suffices
svgText = labelText;
} else {
// Need to parse out possible numeric suffixes to avoid
// duplicating number in label and its subscript
var splitLabelText = labelText.match(/^(.*?)(\d*)$/);
var noNumLabelText = splitLabelText[1];

svgText = svg.createText();
// TODO: to address issue #453, attaching options also
// to spans, not only primary text. Make sure there
// are no problems with this.
svgText.span(noNumLabelText, options);
var subscriptSettings = {
'dy': '0.3em',
'font-size': '80%'
};
// alternate possibility
//                 var subscriptSettings = {
//                   'baseline-shift': 'sub',
//                   'font-size': '80%'
//                 };
$.extend(subscriptSettings, options);
svgText.span(splitArcType[2], subscriptSettings);
}

// guess at the correct baseline shift to get vertical centering.
// (CSS dominant-baseline can't be used as not all SVG rendereds support it.)
var baseline_shift = sizes.arcs.height / 4;
var text = svg.text(arcGroup, (from + to) / 2, -height + baseline_shift,
svgText, options);

var width = sizes.arcs.widths[labelText];
var textBox = {
x: (from + to - width) / 2,
width: width,
y: -height - sizes.arcs.height / 2,
height: sizes.arcs.height
}
if (arc.marked) {
var markedRect = svg.rect(shadowGroup,
textBox.x - markedArcSize, textBox.y - markedArcSize,
textBox.width + 2 * markedArcSize, textBox.height + 2 * markedArcSize, {
// filter: 'url(#Gaussian_Blur)',
'class': "shadow_EditHighlight",
rx: markedArcSize,
ry: markedArcSize
});
svg.other(markedRect, 'animate', {
'data-type': arc.marked,
attributeName: 'fill',
values: (arc.marked == 'match' ? highlightMatchSequence
: highlightArcSequence),
dur: highlightDuration,
repeatCount: 'indefinite',
begin: 'indefinite'
});
}
if (arc.shadowClass) {
svg.rect(shadowGroup,
textBox.x - arcLabelShadowSize,
textBox.y - arcLabelShadowSize,
textBox.width  + 2 * arcLabelShadowSize,
textBox.height + 2 * arcLabelShadowSize, {
'class': 'shadow_' + arc.shadowClass,
filter: 'url(#Gaussian_Blur)',
rx: arcLabelShadowRounding,
ry: arcLabelShadowRounding
});
}
var textStart = textBox.x;
var textEnd = textBox.x + textBox.width;

// adjust by margin for arc drawing
textStart -= Configuration.visual.arcTextMargin;
textEnd += Configuration.visual.arcTextMargin;

if (from > to) {
var tmp = textStart; textStart = textEnd; textEnd = tmp;
}

var path;

if (roundCoordinates) {
// don't ask
height = (height|0)+0.5;
}
if (height > row.maxArcHeight) row.maxArcHeight = height;

var myArrowHead   = ((arcDesc && arcDesc.arrowHead) ||
(spanTypes.ARC_DEFAULT && spanTypes.ARC_DEFAULT.arrowHead));
var arrowName = (leftToRight ?
symmetric && myArrowHead || 'none' :
myArrowHead || 'triangle,5') + ',' + color;
var arrowType = arrows[arrowName];
var arrowDecl = arrowType && ('url(#' + arrowType + ')');

var arrowAtLabelAdjust = 0;
var labelArrowDecl = null;
var myLabelArrowHead = ((arcDesc && arcDesc.labelArrow) ||
(spanTypes.ARC_DEFAULT && spanTypes.ARC_DEFAULT.labelArrow));
if (myLabelArrowHead) {
var labelArrowName = (leftToRight ?
symmetric && myLabelArrowHead || 'none' :
myLabelArrowHead || 'triangle,5') + ',' + color;
var labelArrowSplit = labelArrowName.split(',');
arrowAtLabelAdjust = labelArrowSplit[0] != 'none' && parseInt(labelArrowSplit[1], 10) || 0;
var labelArrowType = arrows[labelArrowName];
var labelArrowDecl = labelArrowType && ('url(#' + labelArrowType + ')');
if (ufoCatcher) arrowAtLabelAdjust = -arrowAtLabelAdjust;
}
var arrowStart = textStart - arrowAtLabelAdjust;
path = svg.createPath().move(arrowStart, -height);
if (rowIndex == leftRow) {
var cornerx = from + ufoCatcherMod * arcSlant;
// for normal cases, should not be past textStart even if narrow
if (!ufoCatcher && cornerx > arrowStart - 1) { cornerx = arrowStart - 1; }
if (smoothArcCurves) {
var controlx = ufoCatcher ? cornerx + 2*ufoCatcherMod*reverseArcControlx : smoothArcSteepness*from+(1-smoothArcSteepness)*cornerx;
var endy = leftBox.y + (leftToRight || arc.equiv ? leftBox.height / 2 : Configuration.visual.margin.y);
// no curving for short lines covering short vertical
// distances, the arrowheads can go off (#925)
if (Math.abs(-height-endy) < 2 &&
Math.abs(cornerx-from) < 5) {
endy = -height;
}
line = path.line(cornerx, -height).
curveQ(controlx, -height, from, endy);
} else {
path.line(cornerx, -height).
line(from, leftBox.y + (leftToRight || arc.equiv ? leftBox.height / 2 : Configuration.visual.margin.y));
}
} else {
path.line(from, -height);
}
svg.path(arcGroup, path, {
markerEnd: arrowDecl,
markerStart: labelArrowDecl,
style: 'stroke: ' + color,
'strokeDashArray': dashArray
});
if (arc.marked) {
svg.path(shadowGroup, path, {
'class': 'shadow_EditHighlight_arc',
strokeWidth: markedArcStroke,
'strokeDashArray': dashArray
});
svg.other(markedRect, 'animate', {
'data-type': arc.marked,
attributeName: 'fill',
values: (arc.marked == 'match' ? highlightMatchSequence
: highlightArcSequence),
dur: highlightDuration,
repeatCount: 'indefinite',
begin: 'indefinite'
});
}
if (arc.shadowClass) {
svg.path(shadowGroup, path, {
'class': 'shadow_' + arc.shadowClass,
strokeWidth: shadowStroke,
'strokeDashArray': dashArray
});
}
var myArrowHead = ((arcDesc && arcDesc.arrowHead) ||
(spanTypes.ARC_DEFAULT && spanTypes.ARC_DEFAULT.arrowHead));
var arrowName = (leftToRight ?
myArrowHead || 'triangle,5' :
symmetric && myArrowHead || 'none') + ',' + color;
var arrowType = arrows[arrowName];
var arrowDecl = arrowType && ('url(#' + arrowType + ')');

var arrowAtLabelAdjust = 0;
var labelArrowDecl = null;
var myLabelArrowHead = ((arcDesc && arcDesc.labelArrow) ||
(spanTypes.ARC_DEFAULT && spanTypes.ARC_DEFAULT.labelArrow));
if (myLabelArrowHead) {
var labelArrowName = (leftToRight ?
myLabelArrowHead || 'triangle,5' :
symmetric && myLabelArrowHead || 'none') + ',' + color;
var labelArrowSplit = labelArrowName.split(',');
arrowAtLabelAdjust = labelArrowSplit[0] != 'none' && parseInt(labelArrowSplit[1], 10) || 0;
var labelArrowType = arrows[labelArrowName];
var labelArrowDecl = labelArrowType && ('url(#' + labelArrowType + ')');
if (ufoCatcher) arrowAtLabelAdjust = -arrowAtLabelAdjust;
}
var arrowEnd = textEnd + arrowAtLabelAdjust;
path = svg.createPath().move(arrowEnd, -height);
if (rowIndex == rightRow) {
var cornerx  = to - ufoCatcherMod * arcSlant;
// TODO: duplicates above in part, make funcs
// for normal cases, should not be past textEnd even if narrow
if (!ufoCatcher && cornerx < arrowEnd + 1) { cornerx = arrowEnd + 1; }
if (smoothArcCurves) {
var controlx = ufoCatcher ? cornerx - 2*ufoCatcherMod*reverseArcControlx : smoothArcSteepness*to+(1-smoothArcSteepness)*cornerx;
var endy = rightBox.y + (leftToRight && !arc.equiv ? Configuration.visual.margin.y : rightBox.height / 2);
// no curving for short lines covering short vertical
// distances, the arrowheads can go off (#925)
if (Math.abs(-height-endy) < 2 &&
Math.abs(cornerx-to) < 5) {
endy = -height;
}
path.line(cornerx, -height).
curveQ(controlx, -height, to, endy);
} else {
path.line(cornerx, -height).
line(to, rightBox.y + (leftToRight && !arc.equiv ? Configuration.visual.margin.y : rightBox.height / 2));
}
} else {
path.line(to, -height);
}
svg.path(arcGroup, path, {
markerEnd: arrowDecl,
markerStart: labelArrowDecl,
style: 'stroke: ' + color,
'strokeDashArray': dashArray
});
if (arc.marked) {
svg.path(shadowGroup, path, {
'class': 'shadow_EditHighlight_arc',
strokeWidth: markedArcStroke,
'strokeDashArray': dashArray
});
}
if (shadowGroup) {
svg.path(shadowGroup, path, {
'class': 'shadow_' + arc.shadowClass,
strokeWidth: shadowStroke,
'strokeDashArray': dashArray
});
}
} // arc rows
}); // arcs

Util.profileEnd('arcs');
Util.profileStart('fragmentConnectors');

$.each(data.spans, function(spanNo, span) {
var numConnectors = span.fragments.length - 1;
for (var connectorNo = 0; connectorNo < numConnectors; connectorNo++) {
var left = span.fragments[connectorNo];
var right = span.fragments[connectorNo + 1];

var leftBox = rowBBox(left);
var rightBox = rowBBox(right);
var leftRow = left.chunk.row.index;
var rightRow = right.chunk.row.index;

for (var rowIndex = leftRow; rowIndex <= rightRow; rowIndex++) {
var row = rows[rowIndex];
row.hasAnnotations = true;

if (rowIndex == leftRow) {
from = leftBox.x + leftBox.width;
} else {
from = sentNumMargin;
}

if (rowIndex == rightRow) {
to = rightBox.x;
} else {
to = canvasWidth - 2 * Configuration.visual.margin.y;
}

var height = leftBox.y + leftBox.height - Configuration.visual.margin.y;
if (roundCoordinates) {
// don't ask
height = (height|0)+0.5;
}

var path = svg.createPath().move(from, height).line(to, height);
svg.path(row.arcs, path, {
style: 'stroke: ' + fragmentConnectorColor,
'strokeDashArray': fragmentConnectorDashArray
});
} // rowIndex
} // connectorNo
}); // spans

Util.profileEnd('fragmentConnectors');
Util.profileStart('rows');

// position the rows
var y = Configuration.visual.margin.y;
var sentNumGroup = svg.group({'class': 'sentnum'});
var currentSent;
$.each(rows, function(rowId, row) {
$.each(row.chunks, function(chunkId, chunk) {
$.each(chunk.fragments, function(fragmentId, fragment) {
if (row.maxSpanHeight < fragment.height) row.maxSpanHeight = fragment.height;
});
});
if (row.sentence) {
currentSent = row.sentence;
}
// SLOW (#724) and replaced with calculations:
//
// var rowBox = row.group.getBBox();
// // Make it work on IE
// rowBox = { x: rowBox.x, y: rowBox.y, height: rowBox.height, width: rowBox.width };
// // Make it work on Firefox and Opera
// if (rowBox.height == -Infinity) {
//   rowBox = { x: 0, y: 0, height: 0, width: 0 };
// }

// XXX TODO HACK: find out where 5 and 1.5 come from!
// This is the fix for #724, but the numbers are guessed.
var rowBoxHeight = Math.max(row.maxArcHeight + 5, row.maxSpanHeight + 1.5); // XXX TODO HACK: why 5, 1.5?
if (row.hasAnnotations) {
// rowBox.height = -rowBox.y + rowSpacing;
rowBoxHeight += rowSpacing + 1.5; // XXX TODO HACK: why 1.5?
} else {
rowBoxHeight -= 5; // XXX TODO HACK: why -5?
}

rowBoxHeight += rowPadding;
var bgClass;
if (data.markedSent[currentSent]) {
// specifically highlighted
bgClass = 'backgroundHighlight';
} else if (Configuration.textBackgrounds == "striped") {
// give every other sentence a different bg class
bgClass = 'background'+ row.backgroundIndex;
} else {
// plain "standard" bg
bgClass = 'background0';
}
svg.rect(backgroundGroup,
0, y + sizes.texts.y + sizes.texts.height,
canvasWidth, rowBoxHeight + sizes.texts.height + 1, {
'class': bgClass
});
y += rowBoxHeight;
y += sizes.texts.height;
row.textY = y - rowPadding;
if (row.sentence) {
var sentence_hash = new URLHash(coll, doc, { focus: [[ 'sent', row.sentence ]] } );
var link = svg.link(sentNumGroup, sentence_hash.getHash());
var text = svg.text(link, sentNumMargin - Configuration.visual.margin.x, y - rowPadding,
'' + row.sentence, { 'data-sent': row.sentence });
var sentComment = data.sentComment[row.sentence];
if (sentComment) {
var box = text.getBBox();
svg.remove(text);
// TODO: using rectShadowSize, but this shadow should
// probably have its own setting for shadow size
shadowRect = svg.rect(sentNumGroup,
box.x - rectShadowSize, box.y - rectShadowSize,
box.width + 2 * rectShadowSize, box.height + 2 * rectShadowSize, {

'class': 'shadow_' + sentComment.type,
filter: 'url(#Gaussian_Blur)',
rx: rectShadowRounding,
ry: rectShadowRounding,
'data-sent': row.sentence
});
var text = svg.text(sentNumGroup, sentNumMargin - Configuration.visual.margin.x, y - rowPadding,
'' + row.sentence, { 'data-sent': row.sentence });
}
}

var rowY = y - rowPadding;
if (roundCoordinates) {
rowY = rowY|0;
}
translate(row, 0, rowY);
y += Configuration.visual.margin.y;
});
y += Configuration.visual.margin.y;

Util.profileEnd('rows');
Util.profileStart('chunkFinish');

// chunk index sort functions for overlapping fragment drawing
// algorithm; first for left-to-right pass, sorting primarily
// by start offset, second for right-to-left pass by end
// offset. Secondary sort by fragment length in both cases.
var currentChunk;
var lrChunkComp = function(a,b) {
var ac = currentChunk.fragments[a];
var bc = currentChunk.fragments[b];
var startDiff = Util.cmp(ac.from, bc.from);
return startDiff != 0 ? startDiff : Util.cmp(bc.to-bc.from, ac.to-ac.from);
}
var rlChunkComp = function(a,b) {
var ac = currentChunk.fragments[a];
var bc = currentChunk.fragments[b]
var endDiff = Util.cmp(bc.to, ac.to);
return endDiff != 0 ? endDiff : Util.cmp(bc.to-bc.from, ac.to-ac.from);
}

var sentenceText = null;
$.each(data.chunks, function(chunkNo, chunk) {
// context for sort
currentChunk = chunk;

// text rendering
if (chunk.sentence) {
if (sentenceText) {
// svg.text(textGroup, sentenceText); // avoids jQuerySVG bug
svg.text(textGroup, 0, 0, sentenceText);
}
sentenceText = null;
}
if (!sentenceText) {
sentenceText = svg.createText();
}
var nextChunk = data.chunks[chunkNo + 1];
var nextSpace = nextChunk ? nextChunk.space : '';
sentenceText.span(chunk.text + nextSpace, {
x: chunk.textX,
y: chunk.row.textY,
'data-chunk-id': chunk.index
});

// chunk backgrounds
if (chunk.fragments.length) {
var orderedIdx = [];
for (var i=chunk.fragments.length-1; i>=0; i--) {
orderedIdx.push(i);
}

// Mark entity nesting height/depth (number of
// nested/nesting entities). To account for crossing
// brackets in a (mostly) reasonable way, determine
// depth/height separately in a left-to-right traversal
// and a right-to-left traversal.
orderedIdx.sort(lrChunkComp);

var openFragments = [];
for(var i=0; i<orderedIdx.length; i++) {
var current = chunk.fragments[orderedIdx[i]];
current.nestingHeightLR = 0;
current.nestingDepthLR = 0;
var stillOpen = [];
for(var o=0; o<openFragments.length; o++) {
if(openFragments[o].to > current.from) {
stillOpen.push(openFragments[o]);
openFragments[o].nestingHeightLR++;
}
}
openFragments = stillOpen;
current.nestingDepthLR=openFragments.length;
openFragments.push(current);
}

// re-sort for right-to-left traversal by end position
orderedIdx.sort(rlChunkComp);

openFragments = [];
for(var i=0; i<orderedIdx.length; i++) {
var current = chunk.fragments[orderedIdx[i]];
current.nestingHeightRL = 0;
current.nestingDepthRL = 0;
var stillOpen = [];
for(var o=0; o<openFragments.length; o++) {
if(openFragments[o].from < current.to) {
stillOpen.push(openFragments[o]);
openFragments[o].nestingHeightRL++;
}
}
openFragments = stillOpen;
current.nestingDepthRL=openFragments.length;
openFragments.push(current);
}

// the effective depth and height are the max of those
// for the left-to-right and right-to-left traversals.
for(var i=0; i<orderedIdx.length; i++) {
var c = chunk.fragments[orderedIdx[i]];
c.nestingHeight = c.nestingHeightLR > c.nestingHeightRL ? c.nestingHeightLR : c.nestingHeightRL;
c.nestingDepth = c.nestingDepthLR > c.nestingDepthRL ? c.nestingDepthLR : c.nestingDepthRL;
}

// Re-order by nesting height and draw in order
orderedIdx.sort(function(a,b) { return Util.cmp(chunk.fragments[b].nestingHeight, chunk.fragments[a].nestingHeight) });

for(var i=0; i<chunk.fragments.length; i++) {
var fragment=chunk.fragments[orderedIdx[i]];
var spanDesc = spanTypes[fragment.span.type];
var bgColor = ((spanDesc && spanDesc.bgColor) ||
(spanTypes.SPAN_DEFAULT && spanTypes.SPAN_DEFAULT.bgColor) ||
'#ffffff');

// Tweak for nesting depth/height. Recognize just three
// levels for now: normal, nested, and nesting, where
// nested+nesting yields normal. (Currently testing
// minor tweak: don't shrink for depth 1 as the nesting
// highlight will grow anyway [check nestingDepth > 1])
var shrink = 0;
if(fragment.nestingDepth > 1 && fragment.nestingHeight == 0) {
shrink = 1;
} else if(fragment.nestingDepth == 0 && fragment.nestingHeight > 0) {
shrink = -1;
}
var yShrink = shrink * nestingAdjustYStepSize;
var xShrink = shrink * nestingAdjustXStepSize;
// bit lighter
var lightBgColor = Util.adjustColorLightness(bgColor, 0.8);
// tweak for Y start offset (and corresponding height
// reduction): text rarely hits font max height, so this
// tends to look better
var yStartTweak = 1;
// store to have same mouseover highlight without recalc
fragment.highlightPos = {
x: chunk.textX + fragment.curly.from + xShrink,
y: chunk.row.textY + sizes.texts.y + yShrink + yStartTweak,
w: fragment.curly.to - fragment.curly.from - 2*xShrink,
h: sizes.texts.height - 2*yShrink - yStartTweak
};
svg.rect(highlightGroup,
fragment.highlightPos.x, fragment.highlightPos.y,
fragment.highlightPos.w, fragment.highlightPos.h,
{ fill: lightBgColor, //opacity:1,
rx: highlightRounding.x,
ry: highlightRounding.y
});
}
}
});
if (sentenceText) {
// svg.text(textGroup, sentenceText); // avoids jQuerySVG bug
svg.text(textGroup, 0, 0, sentenceText);
}

// draw the markedText
$.each(textMarkedRows, function(textRowNo, textRowDesc) { // row, from, to
var textHighlight = svg.rect(highlightGroup,
textRowDesc[1] - 2, textRowDesc[0].textY - sizes.fragments.height,
textRowDesc[2] - textRowDesc[1] + 4, sizes.fragments.height + 4,
{ fill: 'yellow' } // TODO: put into css file, as default - turn into class
);
// NOTE: changing highlightTextSequence here will give
// different-colored highlights
// TODO: entirely different settings for non-animations?
var markedType = textRowDesc[3];
svg.other(textHighlight, 'animate', {
'data-type': markedType,
attributeName: 'fill',
values: (markedType == 'match' ? highlightMatchSequence
: highlightTextSequence),
dur: highlightDuration,
repeatCount: 'indefinite',
begin: 'indefinite'
});
});


Util.profileEnd('chunkFinish');
Util.profileStart('finish');

svg.path(sentNumGroup, svg.createPath().
move(sentNumMargin, 0).
line(sentNumMargin, y));

// resize the SVG
var width = maxTextWidth + sentNumMargin + 2 * Configuration.visual.margin.x + 1;
if (width > canvasWidth) canvasWidth = width;

$svg.width(canvasWidth);
$svg.height(y);
$svgDiv.height(y);

Util.profileEnd('finish');
Util.profileEnd('render');
Util.profileReport();


drawing = false;
if (redraw) {
redraw = false;
renderDataReal();
}
$svg.find('animate').each(function() {
if (this.beginElement) { // protect against non-SMIL browsers
this.beginElement();
}
});
dispatcher.post('doneRendering', [coll, doc, args]);
};

var renderErrors = {
unableToReadTextFile: true,
annotationFileNotFound: true,
isDirectoryError: true
};
var renderData = function(sourceData) {
Util.profileEnd('invoke getDocument');
if (sourceData && sourceData.exception) {
if (renderErrors[sourceData.exception]) {
dispatcher.post('renderError:' + sourceData.exception, [sourceData]);
} else {
dispatcher.post('unknownError', [sourceData.exception]);
}
} else {
// Fill in default values that don't necessarily go over the protocol
if (sourceData) {
setSourceDataDefaults(sourceData);
}

dispatcher.post('startedRendering', [coll, doc, args]);
dispatcher.post('spin');
setTimeout(function() {
try {
renderDataReal(sourceData);
} catch (e) {
// We are sure not to be drawing anymore, reset the state
drawing = false;
// TODO: Hook printout into dispatch elsewhere?
console.warn('Rendering terminated due to:', e);
dispatcher.post('renderError: Fatal', [sourceData, e]);
}
dispatcher.post('unspin');
}, 0);
}
};

var renderDocument = function() {
Util.profileStart('invoke getDocument');
dispatcher.post('ajax', [{
action: 'getDocument',
collection: coll,
'document': doc
}, 'renderData', {
collection: coll,
'document': doc
}]);
};

var triggerRender = function() {

Visualizer.areFontsLoaded = true;

if (svg && ((isRenderRequested && isCollectionLoaded) || requestedData) && Visualizer.areFontsLoaded) {
isRenderRequested = false;
if (requestedData) {
Util.profileClear();
Util.profileStart('before render');

renderData(requestedData);
} else if (doc.length) {

Util.profileClear();
Util.profileStart('before render');

renderDocument();
} else {
dispatcher.post(0, 'renderError:noFileSpecified');
}
}
};

var requestRenderData = function(sourceData) {
requestedData = sourceData;
triggerRender();
};

var collectionChanged = function() {
isCollectionLoaded = false;
};

var gotCurrent = function(_coll, _doc, _args, reloadData) {
coll = _coll;
doc  = _doc;
args = _args;
if (reloadData) {
isRenderRequested = true;
triggerRender();
}
};


// event handlers

var highlight, highlightArcs, highlightSpans, commentId;

// Start: Change window status so that java ui could be notified; Jingqi, 28/05/2014
var arcDragOrigin = null;

var onContextMenu = function( evt ) {
alert( 'onContextMenu' );
}

var onMouseDown = function( evt ) {
var target = $(evt.target);
var id;
if( id = target.attr( 'data-span-id' ) ) {
// start of a relatin;
arcDragOrigin = id;
}
};

var onMouseUp = function( evt ) {
var target = $(evt.target);
var id;
var sel = window.getSelection();
if( arcDragOrigin != null ) {
// 1. end of a relation;
if( id = target.attr( 'data-span-id' ) ) {
if( id != arcDragOrigin ) {
window.status = "brat:onNewRelation:from=[" + arcDragOrigin + "], to=[" + id + "]";
//alert( window.status );
} else {
window.status = "brat:onEntitySelection:" + id;
//alert( window.status );
}
}
arcDragOrigin = null;
} else if( sel != "" ) {
// 2. handle selection;
var sel = window.getSelection();
var chunkIndexFrom = sel.anchorNode && $(sel.anchorNode.parentNode).attr('data-chunk-id');
var chunkIndexTo = sel.focusNode && $(sel.focusNode.parentNode).attr('data-chunk-id');
var anchorOffset = sel.anchorOffset;
var focusOffset = sel.focusOffset;;
var chunkFrom = data.chunks[chunkIndexFrom];
var chunkTo = data.chunks[chunkIndexTo];
var selectedFrom = chunkFrom.from + anchorOffset;
var selectedTo = chunkTo.from + focusOffset;
//alert( chunkIndexFrom + ":" + chunkIndexTo );
//alert( anchorOffset + ":" + focusOffset );
//alert( selectedFrom + ":" + selectedTo );
window.status = "brat:onNewEntity:from=[" + selectedFrom + "], to=[" + selectedTo + "]";
//alert( window.status );
arcDragOrigin = null;
} else {
// 1. select entity or relation;
if( id = target.attr( 'data-span-id' ) ) {
window.status = "brat:onEntitySelection:" + id;
//alert( window.status );
} else if( id = target.attr( 'data-arc-ed' ) ) {
window.status = "brat:onRelationSelection:" + id;
//alert( window.status );
}
arcDragOrigin = null;
}
};
// End, Jingqi

var onMouseOver = function(evt) {
var target = $(evt.target);
var id;
var commentId;
if (id = target.attr('data-span-id')) {
commentId = id;
var span = data.spans[id];
dispatcher.post('displaySpanComment', [
evt, target, id, span.type, span.attributeText,
span.text,
span.comment && span.comment.text,
span.comment && span.comment.type,
span.normalizations]);

var spanDesc = spanTypes[span.type];
var bgColor = ((spanDesc && spanDesc.bgColor) ||
(spanTypes.SPAN_DEFAULT && spanTypes.SPAN_DEFAULT.bgColor) ||
'#ffffff');
highlight = [];
$.each(span.fragments, function(fragmentNo, fragment) {
highlight.push(svg.rect(highlightGroup,
fragment.highlightPos.x, fragment.highlightPos.y,
fragment.highlightPos.w, fragment.highlightPos.h,
{ 'fill': bgColor, opacity:0.75,
rx: highlightRounding.x,
ry: highlightRounding.y
}));
});

if (that.arcDragOrigin) {
target.parent().addClass('highlight');
} else {
highlightArcs = $svg.
find('g[data-from="' + id + '"], g[data-to="' + id + '"]').
addClass('highlight');
var spans = {};
spans[id] = true;
var spanIds = [];
$.each(span.incoming, function(arcNo, arc) {
spans[arc.origin] = true;
});
$.each(span.outgoing, function(arcNo, arc) {
spans[arc.target] = true;
});
$.each(spans, function(spanId, dummy) {
spanIds.push('rect[data-span-id="' + spanId + '"]');
});
highlightSpans = $svg.
find(spanIds.join(', ')).
parent().
addClass('highlight');
}
forceRedraw();

window.status = "brat:onHightLightEntity:" + id;
} else if (!that.arcDragOrigin && (id = target.attr('data-arc-ed'))) {
var originSpanId = target.attr('data-arc-origin');
var targetSpanId = target.attr('data-arc-target');
var role = target.attr('data-arc-role');
var symmetric = (relationTypesHash &&
relationTypesHash[role] &&
relationTypesHash[role].properties &&
relationTypesHash[role].properties.symmetric);
// NOTE: no commentText, commentType for now
var arcEventDescId = target.attr('data-arc-ed');
var commentText = '';
var commentType = '';
var arcId;
if (arcEventDescId) {
var eventDesc = data.eventDescs[arcEventDescId];
var comment = eventDesc.comment;
if (comment) {
commentText = comment.text;
commentType = comment.type;
if (commentText == '' && commentType) {
// default to type if missing text
commentText = commentType;
}
}
if (eventDesc.relation) {
// among arcs, only ones corresponding to relations have
// "independent" IDs
arcId = arcEventDescId;
}
}
var originSpanType = data.spans[originSpanId].type || '';
var targetSpanType = data.spans[targetSpanId].type || '';
dispatcher.post('displayArcComment', [
evt, target, symmetric, arcId,
originSpanId, originSpanType, role,
targetSpanId, targetSpanType,
commentText, commentType]);
highlightArcs = $svg.
find('g[data-from="' + originSpanId + '"][data-to="' + targetSpanId + '"]').
addClass('highlight');
highlightSpans = $($svg).
find('rect[data-span-id="' + originSpanId + '"], rect[data-span-id="' + targetSpanId + '"]').
parent().
addClass('highlight');
window.status = "brat:onHightLightRelation:" + id;
} else if (id = target.attr('data-sent')) {
var comment = data.sentComment[id];
if (comment) {
dispatcher.post('displaySentComment', [evt, target, comment.text, comment.type]);
}
}
};

var onMouseOut = function(evt) {
var target = $(evt.target);
target.removeClass('badTarget');
dispatcher.post('hideComment');
if (highlight) {
$.each(highlight, function() {
svg.remove(this);
});
highlight = undefined;
window.status = "brat:unHightLight";
}
if (highlightSpans) {
highlightArcs.removeClass('highlight');
highlightSpans.removeClass('highlight');
highlightSpans = undefined;
window.status = "brat:unHightLight";
}
forceRedraw();
};

var setAbbrevs = function(_abbrevsOn) {
// TODO: this is a slightly weird place to tweak the configuration
Configuration.abbrevsOn = _abbrevsOn;
dispatcher.post('configurationChanged');
}

var setTextBackgrounds = function(_textBackgrounds) {
Configuration.textBackgrounds = _textBackgrounds;
dispatcher.post('configurationChanged');
}

var setLayoutDensity = function(_density) {
//dispatcher.post('messages', [[['Setting layout density ' + _density, 'comment']]]);
// TODO: store standard settings instead of hard-coding
// them here (again)
if (_density < 2) {
// dense
Configuration.visual.margin = { x: 1, y: 0 };
Configuration.visual.boxSpacing = 1;
Configuration.visual.curlyHeight = 1;
Configuration.visual.arcSpacing = 7;
Configuration.visual.arcStartHeight = 18
} else if(_density > 2) {
// spacious
Configuration.visual.margin = { x: 2, y: 1 };
Configuration.visual.boxSpacing = 3;
Configuration.visual.curlyHeight = 6;
Configuration.visual.arcSpacing = 12;
Configuration.visual.arcStartHeight = 23;
} else {
// standard
Configuration.visual.margin = { x: 2, y: 1 };
Configuration.visual.boxSpacing = 1;
Configuration.visual.curlyHeight = 4;
Configuration.visual.arcSpacing = 9;
Configuration.visual.arcStartHeight = 19;
}
dispatcher.post('configurationChanged');
}

var setSvgWidth = function(_width) {
$svgDiv.width(_width);
if (Configuration.svgWidth != _width) {
Configuration.svgWidth = _width;
dispatcher.post('configurationChanged');
}
}

$svgDiv = $($svgDiv).hide();

// register event listeners
var registerHandlers = function(element, events) {
$.each(events, function(eventNo, eventName) {
element.bind(eventName,
function(evt) {
dispatcher.post(eventName, [evt], 'all');
}
);
});
};
registerHandlers($svgDiv, [
'mouseover', 'mouseout', 'mousemove',
'mouseup', 'mousedown',
'dragstart',
'dblclick', 'click'
]);
registerHandlers($(document), [
'keydown', 'keypress',
'touchstart', 'touchend'
]);
registerHandlers($(window), [
'resize'
]);

// create the svg wrapper
$svgDiv.svg({
onLoad: function(_svg) {
that.svg = svg = _svg;
$svg = $(svg._svg);

/* XXX HACK REMOVED - not efficient?

// XXX HACK to allow off-DOM SVG element creation
// we need to replace the jQuery SVG's _makeNode function
// with a modified one.
// Be aware of potential breakage upon jQuery SVG upgrade.
svg._makeNode = function(parent, name, settings) {
// COMMENTED OUT: parent = parent || this._svg;
var node = this._svg.ownerDocument.createElementNS($.svg.svgNS, name);
for (var name in settings) {
var value = settings[name];
if (value != null && value != null &&
(typeof value != 'string' || value != '')) {
node.setAttribute($.svg._attrNames[name] || name, value);
}
}
// ADDED IN:
if (parent)
parent.appendChild(node);
return node;
};
*/

triggerRender();
}
});

var loadSpanTypes = function(types) {
$.each(types, function(typeNo, type) {
if (type) {
spanTypes[type.type] = type;
var children = type.children;
if (children && children.length) {
loadSpanTypes(children);
}
}
});
}

var loadAttributeTypes = function(response_types) {
var processed = {};
$.each(response_types, function(aTypeNo, aType) {
processed[aType.type] = aType;
// count the values; if only one, it's a boolean attribute
var values = [];
for (var i in aType.values) {
if (aType.values.hasOwnProperty(i)) {
values.push(i);
}
}
if (values.length == 1) {
aType.bool = values[0];
}
});
return processed;
}

var loadRelationTypes = function(relation_types) {
$.each(relation_types, function(relTypeNo, relType) {
if (relType) {
relationTypesHash[relType.type] = relType;
var children = relType.children;
if (children && children.length) {
loadRelationTypes(children);
}
}
});
}

var collectionLoaded = function(response) {
if (!response.exception) {
setCollectionDefaults(response);
eventAttributeTypes = loadAttributeTypes(response.event_attribute_types);
entityAttributeTypes = loadAttributeTypes(response.entity_attribute_types);
spanTypes = {};
loadSpanTypes(response.entity_types);
loadSpanTypes(response.event_types);
loadSpanTypes(response.unconfigured_types);
relationTypesHash = {};
loadRelationTypes(response.relation_types);
loadRelationTypes(response.unconfigured_types);
// TODO XXX: isn't the following completely redundant with
// loadRelationTypes?
$.each(response.relation_types, function(relTypeNo, relType) {
relationTypesHash[relType.type] = relType;
});

dispatcher.post('spanAndAttributeTypesLoaded', [spanTypes, entityAttributeTypes, eventAttributeTypes, relationTypesHash]);

isCollectionLoaded = true;
triggerRender();
} else {
// exception on collection load; allow visualizer_ui
// collectionLoaded to handle this
}
};

var isReloadOkay = function() {
// do not reload while the user is in the dialog
return !drawing;
};

// If we are yet to load our fonts, dispatch them
if (!Visualizer.areFontsLoaded) {
var webFontConfig = {
custom: {
families: [
'Astloch',
'PT Sans Caption',
//        'Ubuntu',
'Liberation Sans'
],
/* For some cases, in particular for embedding, we need to
allow for fonts being hosted elsewhere */
urls: webFontURLs !== undefined ? webFontURLs : [
'static/fonts/Astloch-Bold.ttf',
'static/fonts/PT_Sans-Caption-Web-Regular.ttf',
//
'static/fonts/Liberation_Sans-Regular.ttf'
]
},
active: proceedWithFonts,
inactive: proceedWithFonts,
fontactive: function(fontFamily, fontDescription) {
// Note: Enable for font debugging
//console.log("font active: ", fontFamily, fontDescription);
},
fontloading: function(fontFamily, fontDescription) {
// Note: Enable for font debugging
//console.log("font loading:", fontFamily, fontDescription);
}
};
WebFont.load(webFontConfig);
setTimeout(function() {
if (!Visualizer.areFontsLoaded) {
console.error('Timeout in loading fonts');
proceedWithFonts();
}
}, fontLoadTimeout);
}

dispatcher.
on('collectionChanged', collectionChanged).
on('collectionLoaded', collectionLoaded).
on('renderData', renderData).
on('triggerRender', triggerRender).
on('requestRenderData', requestRenderData).
on('isReloadOkay', isReloadOkay).
on('resetData', resetData).
on('abbrevs', setAbbrevs).
on('textBackgrounds', setTextBackgrounds).
on('layoutDensity', setLayoutDensity).
on('svgWidth', setSvgWidth).
on('current', gotCurrent).
on('clearSVG', clearSVG).
on('mouseover', onMouseOver).
on('mouseout', onMouseOut).
on('mousedown', onMouseDown).
on('mouseup', onMouseUp);
//on('click', onClick);
};


Visualizer.areFontsLoaded = false;

var proceedWithFonts = function() {
Visualizer.areFontsLoaded = true;
// Note: Enable for font debugging
//console.log("fonts done");
Dispatcher.post('triggerRender');
};

return Visualizer;
})(jQuery, window);
;

</script>
<script>
//mycontent
var collData=$jsonresult->collData;
var docData=$jsonresult->docData;
var webFontURLs = "";

Util.embed('brat_blok',collData,docData,webFontURLs);
</script>

</body>
</html>

